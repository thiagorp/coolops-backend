SCRIPT  /Users/thiago/.vim/ftplugin/haskell.vim
Sourced 3 times
Total time:   0.000313
 Self time:   0.000313

count  total (s)   self (s)
    3              0.000056 setlocal formatprg=hindent
                            

SCRIPT  /Users/thiago/.vim/bundle/haskell-vim/ftplugin/haskell.vim
Sourced 3 times
Total time:   0.000114
 Self time:   0.000114

count  total (s)   self (s)
    3              0.000058 if exists("g:loaded_haskellvim_haskell")
    3              0.000013   finish
                            endif
                            
                            let g:loaded_haskellvim_haskell = 1
                            
                            function! haskell#sortImports(line1, line2)
                              exe a:line1 . "," . a:line2 . "sort /import\\s\\+\\(qualified\\s\\+\\)\\?/"
                            endfunction
                            
                            function! haskell#formatImport(line1, line2)
                              exec a:line1 . ",". a:line2 . "s/import\\s\\+\\([A-Z].*\\)/import           \\1"
                            endfunction
                            
                            command! -buffer -range HaskellSortImports call haskell#sortImports(<line1>, <line2>)
                            command! -buffer -range HaskellFormatImport call haskell#formatImport(<line1>, <line2>)

SCRIPT  /Users/thiago/.vim/bundle/vim-hindent/ftplugin/haskell/hindent.vim
Sourced 3 times
Total time:   0.001350
 Self time:   0.001350

count  total (s)   self (s)
    3              0.000045 if !exists("g:hindent_on_save")
                                let g:hindent_on_save = 1
                            endif
                            
                            
    3              0.000034 function! hindent#HindentEnable()
                                let g:hindent_on_save = 1
                            endfunction
    3              0.000009 function! hindent#HindentDisable()
                                let g:hindent_on_save = 0
                            endfunction
    3              0.000007 function! hindent#HindentToggle()
                                let g:hindent_on_save = !g:hindent_on_save
                            endfunction
                            
                            
    3              0.000006 function! hindent#Hindent()
                                let l:winview = winsaveview()
                            
                                if !executable("hindent")
                                    echomsg "Hindent not found in $PATH, did you installed it?
                                                \ (stack install hindent)"
                                    return
                                endif
                            
                                " Write the buffer to hindent, rather than having it use the
                                " file on disk, because that file might not have been created yet!
                                silent! w !hindent > /dev/null 2>&1
                            
                                if v:shell_error
                                    echohl WarningMsg
                                    echo "Hindent: Parsing error\n"
                                    echohl None
                                else
                                    let l:indent_opt = ""
                                    if exists("g:hindent_indent_size")
                                      let l:indent_opt = " --indent-size " . g:hindent_indent_size
                                    endif
                            
                                    let l:line_length_opt = ""
                                    if exists("g:hindent_line_length")
                                      let l:line_length_opt = " --line-length " . g:hindent_line_length
                                    endif
                            
                                    silent! exe "undojoin"
                                    silent! exe "keepjumps %!hindent" . l:indent_opt . l:line_length_opt
                                endif
                            
                                call winrestview(l:winview)
                            endfunction
                            
    3              0.000013 function! hindent#HindentOnSave()
                                if g:hindent_on_save == 1
                                    call hindent#Hindent()
                                endif
                            endfunction
                            
                            
    3              0.000016 augroup hindent
    3              0.000606     autocmd!
    3              0.000049     autocmd BufWritePre *.hs call hindent#HindentOnSave()
    3              0.000005 augroup END
                            
                            
    3              0.000038 command! Hindent exe "call hindent#Hindent()"
    3              0.000035 command! HindentEnable exe "call hindent#HindentEnable()"
    3              0.000023 command! HindentDisable exe "call hindent#HindentDisable()"
    3              0.000033 command! HindentToggle exe "call hindent#HindentToggle()"

SCRIPT  /usr/local/Cellar/vim/8.0.1400_4/share/vim/vim80/ftplugin/haskell.vim
Sourced 3 times
Total time:   0.000598
 Self time:   0.000598

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:             Haskell
                            " Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
                            " Latest Revision:      2008-07-09
                            
    3              0.000052 if exists("b:did_ftplugin")
                              finish
                            endif
    3              0.000013 let b:did_ftplugin = 1
                            
    3              0.000070 let s:cpo_save = &cpo
    3              0.000047 set cpo&vim
                            
    3              0.000013 let b:undo_ftplugin = "setl com< cms< fo<"
                            
    3              0.000034 setlocal comments=s1fl:{-,mb:-,ex:-},:-- commentstring=--\ %s
    3              0.000027 setlocal formatoptions-=t formatoptions+=croql
                            
    3              0.000029 let &cpo = s:cpo_save
    3              0.000020 unlet s:cpo_save

SCRIPT  /Users/thiago/.vim/bundle/haskell-vim/after/ftplugin/haskell.vim
Sourced 3 times
Total time:   0.000482
 Self time:   0.000482

count  total (s)   self (s)
    3              0.000067 setlocal comments=s1fl:{-,mb:\ \ ,ex:-},:--
    3              0.000181 setlocal iskeyword+='

SCRIPT  /Users/thiago/.vim/bundle/ghcmod-vim/after/ftplugin/haskell/ghcmod.vim
Sourced 3 times
Total time:   0.001220
 Self time:   0.001220

count  total (s)   self (s)
    3              0.000056 if exists('b:did_ftplugin_ghcmod') && b:did_ftplugin_ghcmod
                              finish
                            endif
    3              0.000017 let b:did_ftplugin_ghcmod = 1
                            
    3              0.000015 if !exists('s:has_vimproc')
                              try
                                call vimproc#version()
                                let s:has_vimproc = 1
                              catch /^Vim\%((\a\+)\)\=:E117/
                                let s:has_vimproc = 0
                              endtry
                            endif
                            
    3              0.000007 if !s:has_vimproc
                              echohl ErrorMsg
                              echomsg 'ghcmod: vimproc.vim is not installed!'
                              echohl None
                              finish
                            endif
                            
    3              0.000011 if !exists('s:has_ghc_mod')
                              let s:has_ghc_mod = 0
                            
                              if !executable('ghc-mod')
                                call ghcmod#util#print_error('ghcmod: ghc-mod is not executable!')
                                finish
                              endif
                            
                              let s:required_version = [5, 0, 0]
                              if !ghcmod#util#check_version(s:required_version)
                                call ghcmod#util#print_error(printf('ghcmod: requires ghc-mod %s or higher', join(s:required_version, '.')))
                                finish
                              endif
                            
                              let s:has_ghc_mod = 1
                            endif
                            
    3              0.000005 if !s:has_ghc_mod
                              finish
                            endif
                            
    3              0.000016 if exists('b:undo_ftplugin')
    3              0.000013   let b:undo_ftplugin .= ' | '
    3              0.000004 else
                              let b:undo_ftplugin = ''
                            endif
                            
    3              0.000043 command! -buffer -nargs=0 -bang GhcModType call ghcmod#command#type(<bang>0)
    3              0.000033 command! -buffer -nargs=0 -bang GhcModTypeInsert call ghcmod#command#type_insert(<bang>0)
    3              0.000040 command! -buffer -nargs=0 -bang GhcModSplitFunCase call ghcmod#command#split_function_case(<bang>0)
    3              0.000041 command! -buffer -nargs=0 -bang GhcModSigCodegen call ghcmod#command#initial_code_from_signature(<bang>0)
    3              0.000044 command! -buffer -nargs=? -bang GhcModInfo call ghcmod#command#info(<q-args>, <bang>0)
    3              0.000026 command! -buffer -nargs=0 GhcModTypeClear call ghcmod#command#type_clear()
    3              0.000038 command! -buffer -nargs=? -bang GhcModInfoPreview call ghcmod#command#info_preview(<q-args>, <bang>0)
    3              0.000035 command! -buffer -nargs=0 -bang GhcModCheck call ghcmod#command#make('check', <bang>0)
    3              0.000037 command! -buffer -nargs=0 -bang GhcModLint call ghcmod#command#make('lint', <bang>0)
    3              0.000036 command! -buffer -nargs=0 -bang GhcModCheckAsync call ghcmod#command#async_make('check', <bang>0)
    3              0.000035 command! -buffer -nargs=0 -bang GhcModLintAsync call ghcmod#command#async_make('lint', <bang>0)
    3              0.000035 command! -buffer -nargs=0 -bang GhcModCheckAndLintAsync call ghcmod#command#check_and_lint_async(<bang>0)
    3              0.000046 command! -buffer -nargs=0 -bang GhcModExpand call ghcmod#command#expand(<bang>0)
    3              0.000233 let b:undo_ftplugin .= join(map([
                                  \ 'GhcModType',
                                  \ 'GhcModTypeInsert',
                                  \ 'GhcModSplitFunCase',
                                  \ 'GhcModSigCodegen',
                                  \ 'GhcModInfo',
                                  \ 'GhcModInfoPreview',
                                  \ 'GhcModTypeClear',
                                  \ 'GhcModCheck',
                                  \ 'GhcModLint',
                                  \ 'GhcModCheckAsync',
                                  \ 'GhcModLintAsync',
                                  \ 'GhcModCheckAndLintAsync',
                                  \ 'GhcModExpand'
                                  \ ], '"delcommand " . v:val'), ' | ')
    3              0.000013 let b:undo_ftplugin .= ' | unlet b:did_ftplugin_ghcmod'
                            
                            " Ensure syntax highlighting for ghcmod#detect_module()
    3              0.000037 syntax sync fromstart
                            
                            " vim: set ts=2 sw=2 et fdm=marker:

SCRIPT  /Users/thiago/.vim/bundle/haskell-vim/indent/haskell.vim
Sourced 3 times
Total time:   0.003782
 Self time:   0.003782

count  total (s)   self (s)
                            " indentation for haskell
                            "
                            " author: raichoo (raichoo@googlemail.com)
                            "
                            " Modify g:haskell_indent_if and g:haskell_indent_case to
                            " change indentation for `if'(default 3) and `case'(default 5).
                            " Example (in .vimrc):
                            " > let g:haskell_indent_if = 2
                            
    3              0.000036 if exists('b:did_indent')
                              finish
                            endif
                            
    3              0.000024 if get(g:, 'haskell_indent_disable', 0)
                              finish
                            endif
                            
    3              0.000011 let b:did_indent = 1
                            
    3              0.000012 if !exists('g:haskell_indent_if')
                              " if x
                              " >>>then ...
                              " >>>else ...
                              let g:haskell_indent_if = 3
                            endif
                            
    3              0.000011 if !exists('g:haskell_indent_case')
                              " case xs of
                              " >>[]     -> ...
                              " >>(y:ys) -> ...
                              let g:haskell_indent_case = 2
                            endif
                            
    3              0.000010 if !exists('g:haskell_indent_let')
                              " let x = 0 in
                              " >>>>x
                              "
                              " let x = 0
                              "     y = 1
                              let g:haskell_indent_let = 4
                            endif
                            
    3              0.000013 if !exists('g:haskell_indent_let_no_in')
                              " let x = 0
                              "     x
                              let g:haskell_indent_let_no_in = 4
                            endif
                            
    3              0.000011 if !exists('g:haskell_indent_where')
                              " where f :: Int -> Int
                              " >>>>>>f x = x
                              let g:haskell_indent_where = 6
                            endif
                            
    3              0.000010 if !exists('g:haskell_indent_do')
                              " do x <- a
                              " >>>y <- b
                              let g:haskell_indent_do = 3
                            endif
                            
    3              0.000011 if !exists('g:haskell_indent_in')
                              " let x = 1
                              " >in x
                              let g:haskell_indent_in = 1
                            endif
                            
    3              0.000010 if !exists('g:haskell_indent_guard')
                              " f x y
                              " >>|
                              let g:haskell_indent_guard = 2
                            endif
                            
    3              0.000037 setlocal indentexpr=GetHaskellIndent()
    3              0.000026 setlocal indentkeys=0},0),0],!^F,o,O,0=where,0=let,0=deriving,<space>
                            
    3              0.000028 function! s:isInBlock(hlstack)
                              return index(a:hlstack, 'haskellDelimiter') > -1 || index(a:hlstack, 'haskellParens') > -1 || index(a:hlstack, 'haskellBrackets') > -1 || index(a:hlstack, 'haskellBlock') > -1 || index(a:hlstack, 'haskellBlockComment') > -1 || index(a:hlstack, 'haskellPragma') > -1
                            endfunction
                            
    3              0.000010 function! s:stripComment(line)
                              if a:line =~ '^\s*--\(-*\s\+\|$\)'
                                return ''
                              else
                                let l:stripped = split(a:line, '-- ')
                                if len(l:stripped) > 1
                                  return substitute(l:stripped[0], '\s*$', '', '')
                                else
                                  return a:line
                                endif
                              endif
                            endfunction
                            
    3              0.000021 function! s:isSYN(grp, line, col)
                              return index(s:getHLStack(a:line, a:col), a:grp) != -1
                            endfunction
                            
    3              0.000012 function! s:getNesting(hlstack)
                              return filter(a:hlstack, 'v:val == "haskellBlock" || v:val == "haskellBrackets" || v:val == "haskellParens" || v:val == "haskellBlockComment" || v:val == "haskellPragma" ')
                            endfunction
                            
    3              0.000027 function! s:getHLStack(line, col)
                              return map(synstack(a:line, a:col), 'synIDattr(v:val, "name")')
                            endfunction
                            
                            " indent matching character
    3              0.000011 function! s:indentMatching(char)
                              normal! 0
                              call search(a:char, 'cW')
                              normal! %
                              return col('.') - 1
                            endfunction
                            
                            " backtrack to find guard clause
    3              0.000013 function! s:indentGuard(pos, prevline)
                              let l:l = a:prevline
                              let l:c = 1
                            
                              while v:lnum != l:c
                                " empty line, stop looking
                                if l:l =~ '^$'
                                  return a:pos
                                " guard found
                                elseif l:l =~ '^\s*|\s\+'
                                  return match(l:l, '|')
                                " found less deeper indentation (not starting with `,` or `=`)
                                " stop looking
                                else
                                  let l:m = match(l:l, '\S')
                                  if l:l !~ '^\s*[=,]' && l:m <= a:pos
                                    return l:m + g:haskell_indent_guard
                                  endif
                                endif
                                let l:c += 1
                                let l:l = getline(v:lnum - l:c)
                              endwhile
                            
                              return -1
                            endfunction
                            
    3              0.000013 function! GetHaskellIndent()
                              let l:hlstack = s:getHLStack(line('.'), col('.'))
                            
                              " do not indent in strings and quasiquotes
                              if index(l:hlstack, 'haskellQuasiQuote') > -1 || index(l:hlstack, 'haskellBlockComment') > -1
                                return -1
                              endif
                            
                              let l:prevline = s:stripComment(getline(v:lnum - 1))
                              let l:line     = getline(v:lnum)
                            
                              " indent multiline strings
                              if index(l:hlstack, 'haskellString') > -1
                                if l:line =~ '^\s*\\'
                                  return match(l:prevline, '["\\]')
                                else
                                  return - 1
                                endif
                              endif
                            
                              " reset
                              if l:prevline =~ '^\s*$' && l:line !~ '^\s*\S'
                                return 0
                              endif
                            
                              "   { foo :: Int
                              " >>,
                              "
                              "   |
                              "   ...
                              " >>,
                              if l:line =~ '^\s*,'
                                if s:isInBlock(s:getHLStack(line('.'), col('.')))
                                  normal! 0
                                  call search(',', 'cW')
                                  let l:n = s:getNesting(s:getHLStack(line('.'), col('.')))
                                  call search('[([{]', 'bW')
                                  let l:cl = line('.')
                                  let l:cc = col('.')
                            
                                  while l:n != s:getNesting(s:getHLStack(l:cl, l:cc)) || s:isSYN('haskellString', l:cl, l:cc) || s:isSYN('haskellChar', l:cl, l:cc)
                                    call search('[([{]', 'bW')
                                    let l:cl = line('.')
                                    let l:cc = col('.')
                                  endwhile
                            
                                  return l:cc - 1
                                else
                                  let l:s = s:indentGuard(match(l:line, ','), l:prevline)
                                  if l:s > -1
                                    return l:s
                                  end
                                endif
                              endif
                            
                              " operator at end of previous line
                              if l:prevline =~ '[!#$%&*+./<>?@\\^|~-]\s*$'
                                return match(l:prevline, '\S') + &shiftwidth
                              endif
                            
                              " let foo =
                              " >>>>>>bar
                              if l:prevline =~ '\C\<let\>\s\+[^=]\+=\s*$'
                                return match(l:prevline, '\C\<let\>') + g:haskell_indent_let + &shiftwidth
                              endif
                            
                              " let x = 1 in
                              " >>>>x
                              if l:prevline =~ '\C\<let\>\s\+.\+\<in\>\?$' && l:line !~ '\C^\s*\<in\>'
                                return match(l:prevline, '\C\<let\>') + g:haskell_indent_let
                              endif
                            
                              " let x = 1
                              " let y = 2
                              "
                              " let x = 1
                              " >in x
                              "
                              " let x = 1
                              " >>>>y = 2
                              "
                              " let x = 1
                              " y 2
                              if l:prevline =~ '\C\<let\>\s\+.\+$'
                                if l:line =~ '\C^\s*\<let\>'
                                  let l:s = match(l:prevline, '\C\<let\>')
                                  if s:isSYN('haskellLet', v:lnum - 1, l:s + 1)
                                    return l:s
                                  endif
                                elseif l:line =~ '\C^\s*\<in\>'
                                  let l:s = match(l:prevline, '\C\<let\>')
                                  if s:isSYN('haskellLet', v:lnum - 1, l:s + 1)
                                    return l:s + g:haskell_indent_in
                                  endif
                                elseif l:line =~ '\s=\s'
                                  let l:s = match(l:prevline, '\C\<let\>')
                                  if s:isSYN('haskellLet', v:lnum - 1, l:s + 1)
                                    return l:s + g:haskell_indent_let
                                  endif
                                else
                                  let l:s = match(l:prevline, '\C\<let\>')
                                  if s:isSYN('haskellLet', v:lnum - 1, l:s + 1)
                                    return l:s + g:haskell_indent_let_no_in
                                  endif
                                endif
                              endif
                            
                              " if handling
                              if l:prevline !~ '\C\<else\>'
                                let l:s = match(l:prevline, '\C\<if\>.*\&.*\zs\<then\>')
                                if l:s > 0
                                  return l:s
                                endif
                            
                                let l:s = match(l:prevline, '\C\<if\>')
                                if l:s > 0
                                  return l:s + g:haskell_indent_if
                                endif
                              endif
                            
                              " where
                              " >>foo
                              "
                              if l:prevline =~ '\C\<where\>\s*$'
                                return match(l:prevline, '\S') + get(g:, 'haskell_indent_after_bare_where', &shiftwidth)
                              endif
                            
                              " do
                              " >>foo
                              "
                              " foo =
                              " >>bar
                              if l:prevline =~ '\C\(\<do\>\|=\)\s*$'
                                return match(l:prevline, '\S') + &shiftwidth
                              endif
                            
                              " do foo
                              " >>>bar
                              if l:prevline =~ '\C\<do\>\s\+\S\+.*$'
                                let l:s = match(l:prevline, '\C\<do\>')
                                if s:isSYN('haskellKeyword', v:lnum - 1, l:s + 1)
                                  return l:s + g:haskell_indent_do
                                endif
                              endif
                            
                              " case foo of
                              " >>bar -> quux
                              if l:prevline =~ '\C\<case\>.\+\<of\>\s*$'
                                if get(g:,'haskell_indent_case_alternative', 0)
                                  return match(l:prevline, '\S') + &shiftwidth
                                else
                                  return match(l:prevline, '\C\<case\>') + g:haskell_indent_case
                                endif
                              endif
                            
                              "" where foo
                              "" >>>>>>bar
                              if l:prevline =~ '\C\<where\>\s\+\S\+.*$'
                                if  l:line =~ '^\s*[=-]>\s' && l:prevline =~ ' :: '
                                  return match(l:prevline, ':: ')
                                else
                                  let l:s = match(l:prevline, '\C\<where\>')
                                  if s:isSYN('haskellWhere', v:lnum - 1, l:s + 1)
                                    return l:s + g:haskell_indent_where
                                  endif
                                endif
                              endif
                            
                              " newtype Foo = Foo
                              " >>deriving
                              if l:prevline =~ '\C\s*\<\(newtype\|data\)\>[^{]\+' && l:line =~ '\C^\s*\<deriving\>'
                                return match(l:prevline, '\S') + &shiftwidth
                              endif
                            
                              " foo :: Int
                              " >>>>-> Int
                              "
                              " foo
                              "   :: Int
                              " foo
                              if l:prevline =~ '\s::\s'
                                if l:line =~ '^\s*[-=]>'
                                  return match(l:prevline, '::\s')
                                elseif match(l:prevline, '^\s\+::') > -1
                                  return match(l:prevline, '::\s') - &shiftwidth
                                endif
                              endif
                            
                              " foo :: Int
                              "     -> Int
                              " >>>>-> Int
                              "
                              " foo :: Monad m
                              "     => Functor f
                              " >>>>=> Int
                              "
                              " foo :: Int
                              "     -> Int
                              " foo x
                              "
                              " foo
                              "   :: Int
                              "   -> Int
                              " foo x
                              if l:prevline =~ '^\s*[-=]>'
                                if l:line =~ '^\s*[-=]>'
                                  return match(l:prevline, '[-=]')
                                else
                                  if s:isInBlock(l:hlstack)
                                    return match(l:prevline, '[^-=]')
                                  else
                                    let l:m = matchstr(l:line, '^\s*\zs\<\S\+\>\ze')
                                    let l:l = l:prevline
                                    let l:c = 1
                            
                                    while v:lnum != l:c
                                      " fun decl
                                      if l:l =~ ('^\s*' . l:m . '\(\s*::\|\n\s\+::\)')
                                        let l:s = match(l:l, l:m)
                                        if match(l:l, '\C^\s*\<default\>') > -1
                                          return l:s - 8
                                        else
                                          return l:s
                                        endif
                                      " empty line, stop looking
                                      elseif l:l =~ '^$'
                                         return 0
                                      endif
                                      let l:c += 1
                                      let l:l = getline(v:lnum - l:c)
                                    endwhile
                            
                                    return 0
                                  endif
                                endif
                              endif
                            
                              "   | otherwise = ...
                              " foo
                              "
                              "   | foo
                              " >>, bar
                              "
                              "   | foo
                              " >>= bar
                              "
                              "   | Foo
                              " >>deriving
                              if l:prevline =~ '^\s\+|' && !s:isInBlock(l:hlstack)
                                if l:line =~ '\s*[,=]'
                                  return match(l:prevline, '|')
                                elseif l:line =~ '\C^\s*\<deriving\>'
                                  return match(l:prevline, '|')
                                elseif l:line !~ '^\s*|'
                                  return match(l:prevline, '|') - g:haskell_indent_guard
                                endif
                              endif
                            
                              " foo :: ( Monad m
                              "        , Functor f
                              "        )
                              ">>>>>=> Int
                              if l:prevline =~ '^\s*)' && l:line =~ '^\s*=>'
                                let l:s = match(l:prevline, ')')
                                return l:s - (&shiftwidth + 1)
                              endif
                            
                              " module Foo
                              " >>( bar
                              if l:prevline =~ '\C^\<module\>'
                                return &shiftwidth
                              endif
                            
                              " foo
                              " >>{
                              if l:line =~ '^\s*{ '
                                let l:s = match(l:prevline, '\S')
                                if l:s >= 0
                                  return l:s + &shiftwidth
                                endif
                              endif
                            
                              "  in foo
                              " where bar
                              "
                              " or
                              "
                              " foo
                              " >>where
                              if l:line =~ '\C^\s*\<where\>'
                                if match(l:prevline, '\C^\s\+in\s\+') == 0
                                  return match(l:prevline, 'in') - g:haskell_indent_in
                                endif
                            
                                return match(l:prevline, '\S') + get(g:, 'haskell_indent_before_where', &shiftwidth)
                              endif
                            
                              " let x = 1
                              "     y = 2
                              " >in x + 1
                              if l:line =~ '\C^\s*\<in\>'
                                return match(l:prevline, '\S') - (4 - g:haskell_indent_in)
                              endif
                            
                              " data Foo
                              " >>= Bar
                              "
                              "   |
                              "   ...
                              " >>=
                              "
                              " foo
                              " >>=
                              if l:line =~ '^\s*='
                                if l:prevline =~ '\C^\<data\>\s\+[^=]\+\s*$'
                                  return match(l:prevline, '\C\<data\>') + &shiftwidth
                                else
                                  let l:s = s:indentGuard(match(l:line, '='), l:prevline)
                                  if l:s > 0
                                    return l:s
                                  else
                                    return &shiftwidth
                                  endif
                                endif
                              endif
                            
                              "   |
                              "   ...
                              " >>|
                              "
                              " data Foo = Bar
                              " >>>>>>>>>|
                              if l:line =~ '^\s*|\s'
                                if l:prevline =~ '\C^\s*\<data\>.\+=.\+$'
                                  return match(l:prevline, '=')
                                else
                                  let l:s = s:indentGuard(match(l:line, '|'), l:prevline)
                                  if l:s > -1
                                    return l:s
                                  endif
                                endif
                              endif
                            
                              " foo
                              " >>:: Int
                              if l:line =~ '^\s*::\s'
                                return match(l:prevline, '\S') + &shiftwidth
                              endif
                            
                              " indent closing brace, paren or bracket
                              if l:line =~ '^\s*}'
                                return s:indentMatching('}')
                              endif
                            
                              if l:line =~ '^\s*)'
                                return s:indentMatching(')')
                              endif
                            
                              if l:line =~ '^\s*]'
                                return s:indentMatching(']')
                              endif
                            
                              return -1
                            endfunction

SCRIPT  /Users/thiago/.vim/syntax/haskell.vim
Sourced 3 times
Total time:   0.015423
 Self time:   0.015423

count  total (s)   self (s)
                            " Vim syntax file
                            "
                            " Modification of vims Haskell syntax file:
                            "   - match types using regular expression
                            "   - highlight toplevel functions
                            "   - use "syntax keyword" instead of "syntax match" where appropriate
                            "   - functions and types in import and module declarations are matched
                            "   - removed hs_highlight_more_types (just not needed anymore)
                            "   - enable spell checking in comments and strings only
                            "   - FFI highlighting
                            "   - QuasiQuotation
                            "   - top level Template Haskell slices
                            "   - PackageImport
                            "
                            " TODO: find out which vim versions are still supported
                            "
                            " From Original file:
                            " ===================
                            "
                            " Language:		    Haskell
                            " Maintainer:		Haskell Cafe mailinglist <haskell-cafe@haskell.org>
                            " Last Change:		2010 Feb 21
                            " Original Author:	John Williams <jrw@pobox.com>
                            "
                            " Thanks to Ryan Crumley for suggestions and John Meacham for
                            " pointing out bugs. Also thanks to Ian Lynagh and Donald Bruce Stewart
                            " for providing the inspiration for the inclusion of the handling
                            " of C preprocessor directives, and for pointing out a bug in the
                            " end-of-line comment handling.
                            "
                            " Options-assign a value to these variables to turn the option on:
                            "
                            " hs_highlight_delimiters - Highlight delimiter characters--users
                            "			    with a light-colored background will
                            "			    probably want to turn this on.
                            " hs_highlight_boolean - Treat True and False as keywords.
                            " hs_highlight_types - Treat names of primitive types as keywords.
                            " hs_highlight_debug - Highlight names of debugging functions.
                            " hs_allow_hash_operator - Don't highlight seemingly incorrect C
                            "			   preprocessor directives but assume them to be
                            "			   operators
                            " 
                            " 
                            
    3              0.000021 if version < 600
                              syn clear
                            elseif exists("b:current_syntax")
                              finish
                            endif
                            
                            "syntax sync fromstart "mmhhhh.... is this really ok to do so?
    3              0.000018 syntax sync linebreaks=15 minlines=50 maxlines=500
                            
    3              0.000189 syn match  hsSpecialChar	contained "\\\([0-9]\+\|o[0-7]\+\|x[0-9a-fA-F]\+\|[\"\\'&\\abfnrtv]\|^[A-Z^_\[\\\]]\)"
    3              0.000115 syn match  hsSpecialChar	contained "\\\(NUL\|SOH\|STX\|ETX\|EOT\|ENQ\|ACK\|BEL\|BS\|HT\|LF\|VT\|FF\|CR\|SO\|SI\|DLE\|DC1\|DC2\|DC3\|DC4\|NAK\|SYN\|ETB\|CAN\|EM\|SUB\|ESC\|FS\|GS\|RS\|US\|SP\|DEL\)"
    3              0.000088 syn match  hsSpecialCharError	contained "\\&\|'''\+"
    3              0.000195 sy region  hsString		start=+"+  skip=+\\\\\|\\"+  end=+"+  contains=hsSpecialChar,@Spell
    3              0.000203 sy match   hsCharacter		"[^a-zA-Z0-9_']'\([^\\]\|\\[^']\+\|\\'\)'"lc=1 contains=hsSpecialChar,hsSpecialCharError
    3              0.000115 sy match   hsCharacter		"^'\([^\\]\|\\[^']\+\|\\'\)'" contains=hsSpecialChar,hsSpecialCharError
                            
                            " (Qualified) identifiers (no default highlighting)
    3              0.000048 syn match ConId "\(\<[A-Z][a-zA-Z0-9_']*\.\)\=\<[A-Z][a-zA-Z0-9_']*\>"
    3              0.000050 syn match VarId "\(\<[A-Z][a-zA-Z0-9_']*\.\)\=\<[a-z][a-zA-Z0-9_']*\>"
                            
                            " Infix operators--most punctuation characters and any (qualified) identifier
                            " enclosed in `backquotes`. An operator starting with : is a constructor,
                            " others are variables (e.g. functions).
    3              0.000056 syn match hsVarSym "\(\<[A-Z][a-zA-Z0-9_']*\.\)\=[-!#$%&\*\+/<=>\?@\\^|~.][-!#$%&\*\+/<=>\?@\\^|~:.]*"
    3              0.000041 syn match hsConSym "\(\<[A-Z][a-zA-Z0-9_']*\.\)\=:[-!#$%&\*\+./<=>\?@\\^|~:]*"
    3              0.000039 syn match hsVarSym "`\(\<[A-Z][a-zA-Z0-9_']*\.\)\=[a-z][a-zA-Z0-9_']*`"
    3              0.000039 syn match hsConSym "`\(\<[A-Z][a-zA-Z0-9_']*\.\)\=[A-Z][a-zA-Z0-9_']*`"
                            
                            " Toplevel Template Haskell support
                            "sy match hsTHTopLevel "^[a-z]\(\(.\&[^=]\)\|\(\n[^a-zA-Z0-9]\)\)*"
    3              0.000034 sy match hsTHIDTopLevel "^[a-z]\S*" 
    3              0.000074 sy match hsTHTopLevel "^\$(\?" nextgroup=hsTHTopLevelName 
    3              0.000043 sy match hsTHTopLevelName "[a-z]\S*" contained
                            
                            " Reserved symbols--cannot be overloaded.
    3              0.000046 syn match hsDelimiter  "(\|)\|\[\|\]\|,\|;\|_\|{\|}"
                            
    3              0.000264 sy region hsInnerParen start="(" end=")" contained contains=hsInnerParen,hsConSym,hsType,hsVarSym
    3              0.000194 sy region hs_InfixOpFunctionName start="^(" end=")\s*[^:`]\(\W\&\S\&[^'\"`()[\]{}@]\)\+"re=s
                                \ contained keepend contains=hsInnerParen,hs_HlInfixOp
                            
    3              0.000065 sy match hs_hlFunctionName "[a-z_]\(\S\&[^,\(\)\[\]]\)*" contained 
    3              0.000117 sy match hs_FunctionName "^[a-z_]\(\S\&[^,\(\)\[\]]\)*" contained contains=hs_hlFunctionName
    3              0.000120 sy match hs_HighliteInfixFunctionName "`[a-z_][^`]*`" contained
    3              0.000385 sy match hs_InfixFunctionName "^\S[^=]*`[a-z_][^`]*`"me=e-1 contained contains=hs_HighliteInfixFunctionName,hsType,hsConSym,hsVarSym,hsString,hsCharacter
    3              0.000111 sy match hs_HlInfixOp "\(\W\&\S\&[^`(){}'[\]]\)\+" contained contains=hsString
    3              0.000150 sy match hs_InfixOpFunctionName "^\(\(\w\|[[\]{}]\)\+\|\(\".*\"\)\|\('.*'\)\)\s*[^:]=*\(\W\&\S\&[^='\"`()[\]{}@]\)\+"
                                \ contained contains=hs_HlInfixOp,hsCharacter
                            
    3              0.000060 sy match hs_OpFunctionName        "(\(\W\&[^(),\"]\)\+)" contained
                            "sy region hs_Function start="^["'a-z_([{]" end="=\(\s\|\n\|\w\|[([]\)" keepend extend
    3              0.000407 sy region hs_Function start="^["'a-zA-Z_([{]\(\(.\&[^=]\)\|\(\n\s\)\)*=" end="\(\s\|\n\|\w\|[([]\)" 
                                    \ contains=hs_OpFunctionName,hs_InfixOpFunctionName,hs_InfixFunctionName,hs_FunctionName,hsType,hsConSym,hsVarSym,hsString,hsCharacter
                            
    3              0.000193 sy match hs_DeclareFunction "^[a-z_(]\S*\(\s\|\n\)*::" contains=hs_FunctionName,hs_OpFunctionName
                            
                            " hi hs_InfixOpFunctionName guibg=bg
                            " hi hs_Function guibg=green
                            " hi hs_InfixFunctionName guibg=red
                            " hi hs_DeclareFunction guibg=red
                            
    3              0.000064 sy keyword hsStructure data family class where instance default deriving
    3              0.000043 sy keyword hsTypedef type newtype
                            
    3              0.000043 sy keyword hsInfix infix infixl infixr
    3              0.000052 sy keyword hsStatement  do case of let in
    3              0.000039 sy keyword hsConditional if then else
                            
                            "if exists("hs_highlight_types")
                              " Primitive types from the standard prelude and libraries.
    3              0.000056   sy match hsType "\<[A-Z]\(\S\&[^,.]\)*\>"
    3              0.000047   sy match hsType "()"
                            "endif
                            
                            " Not real keywords, but close.
    3              0.000061 if exists("hs_highlight_boolean")
                              " Boolean constants from the standard prelude.
    3              0.000039   syn keyword hsBoolean True False
    3              0.000007 endif
                            
    3              0.000144 syn region	hsPackageString	start=+L\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial contained
    3              0.000049 sy match   hsModuleName  excludenl "\([A-Z]\w*\.\?\)*" contained 
                            
    3              0.000259 sy match hsImport "\<import\>\s\+\(qualified\s\+\)\?\(\<\(\w\|\.\)*\>\)" 
                                \ contains=hsModuleName,hsImportLabel
                                \ nextgroup=hsImportParams,hsImportIllegal skipwhite
    3              0.000035 sy keyword hsImportLabel import qualified contained
                            
    3              0.000031 sy match hsImportIllegal "\w\+" contained
                            
    3              0.000023 sy keyword hsAsLabel as contained
    3              0.000035 sy keyword hsHidingLabel hiding contained
                            
    3              0.000238 sy match hsImportParams "as\s\+\(\w\+\)" contained
                                \ contains=hsModuleName,hsAsLabel
                                \ nextgroup=hsImportParams,hsImportIllegal skipwhite
    3              0.000185 sy match hsImportParams "hiding" contained
                                \ contains=hsHidingLabel
                                \ nextgroup=hsImportParams,hsImportIllegal skipwhite 
    3              0.000446 sy match hsImportParams "\(\w\*\)" contained
                                \ contains=hsBlockComment,hsLineComment,hsType,hsDelimTypeExport,hs_hlFunctionName,hs_OpFunctionName
                                \ nextgroup=hsImportIllegal skipwhite
                            
                            "hi hsImport guibg=red
                            "hi hsImportParams guibg=bg
                            "hi hsImportIllegal guibg=bg
                            "hi hsModuleName guibg=bg
                            
                            "sy match hsImport		"\<import\>\(.\|[^(]\)*\((.*)\)\?" 
                            "         \ contains=hsPackageString,hsImportLabel,hsImportMod,hsModuleName,hsImportList
                            "sy keyword hsImportLabel import contained
                            "sy keyword hsImportMod		as qualified hiding contained
                            "sy region hsImportListInner start="(" end=")" contained keepend extend contains=hs_OpFunctionName
                            "sy region  hsImportList matchgroup=hsImportListParens start="("rs=s+1 end=")"re=e-1
                            "        \ contained 
                            "        \ keepend extend
                            "        \ contains=hsType,hsLineComment,hsBlockComment,hs_hlFunctionName,hsImportListInner
                            
                            
                            
                            " new module highlighting
    3              0.000167 syn region hsDelimTypeExport start="\<[A-Z]\(\S\&[^,.]\)*\>(" end=")" contained
                               \ contains=hsType
                            
    3              0.000044 sy keyword hsExportModuleLabel module contained
    3              0.000155 sy match hsExportModule "\<module\>\(\s\|\t\|\n\)*\([A-Z]\w*\.\?\)*" contained contains=hsExportModuleLabel,hsModuleName
                            
    3              0.000035 sy keyword hsModuleStartLabel module contained
    3              0.000029 sy keyword hsModuleWhereLabel where contained
                            
    3              0.000203 syn match hsModuleStart "^module\(\s\|\n\)*\(\<\(\w\|\.\)*\>\)\(\s\|\n\)*" 
                              \ contains=hsModuleStartLabel,hsModuleName
                              \ nextgroup=hsModuleCommentA,hsModuleExports,hsModuleWhereLabel
                            
    3              0.000203 syn region hsModuleCommentA start="{-" end="-}"
                              \ contains=hsModuleCommentA,hsCommentTodo,@Spell contained
                              \ nextgroup=hsModuleCommentA,hsModuleExports,hsModuleWhereLabel skipwhite skipnl
                            
    3              0.000316 syn match hsModuleCommentA "--.*\n"
                              \ contains=hsCommentTodo,@Spell contained
                              \ nextgroup=hsModuleCommentA,hsModuleExports,hsModuleWhereLabel skipwhite skipnl
                            
    3              0.000540 syn match hsModuleExports "\(\w\*\)" contained
                               \ nextgroup=hsModuleCommentB,hsModuleWhereLabel skipwhite skipnl
                               \ contains=hsBlockComment,hsLineComment,hsType,hsDelimTypeExport,hs_hlFunctionName,hs_OpFunctionName,hsExportModule
                            
    3              0.000194 syn match hsModuleCommentB "--.*\n"
                              \ contains=hsCommentTodo,@Spell contained
                              \ nextgroup=hsModuleCommentB,hsModuleWhereLabel skipwhite skipnl
                            
    3              0.000227 syn region hsModuleCommentB start="{-" end="-}"
                               \ contains=hsModuleCommentB,hsCommentTodo,@Spell contained
                               \ nextgroup=hsModuleCommentB,hsModuleWhereLabel skipwhite skipnl
                            " end module highlighting
                            
                            " FFI support
    3              0.000030 sy keyword hsFFIForeign foreign contained
                            "sy keyword hsFFIImportExport import export contained
    3              0.000023 sy keyword hsFFIImportExport export contained
    3              0.000024 sy keyword hsFFICallConvention ccall stdcall contained
    3              0.000024 sy keyword hsFFISafety safe unsafe contained
    3              0.000086 sy region  hsFFIString		start=+"+  skip=+\\\\\|\\"+  end=+"+  contained contains=hsSpecialChar
    3              0.000423 sy match hsFFI excludenl "\<foreign\>\(.\&[^\"]\)*\"\(.\)*\"\(\s\|\n\)*\(.\)*::"
                              \ keepend
                              \ contains=hsFFIForeign,hsFFIImportExport,hsFFICallConvention,hsFFISafety,hsFFIString,hs_OpFunctionName,hs_hlFunctionName
                            
                            
    3              0.000058 sy match   hsNumber		"\<[0-9]\+\>\|\<0[xX][0-9a-fA-F]\+\>\|\<0[oO][0-7]\+\>"
    3              0.000049 sy match   hsFloat		"\<[0-9]\+\.[0-9]\+\([eE][-+]\=[0-9]\+\)\=\>"
                            
                            " Comments
    3              0.000075 sy keyword hsCommentTodo    TODO FIXME XXX TBD contained
    3              0.000111 sy match   hsLineComment      "---*\([^-!#$%&\*\+./<=>\?@\\^|~].*\)\?$" contains=hsCommentTodo,@Spell
    3              0.000153 sy region  hsBlockComment     start="{-"  end="-}" contains=hsBlockComment,hsCommentTodo,@Spell
    3              0.000052 sy region  hsPragma	       start="{-#" end="#-}"
                            
                            " QuasiQuotation
    3              0.000191 sy region hsQQ start="\[\$" end="|\]"me=e-2 keepend contains=hsQQVarID,hsQQContent nextgroup=hsQQEnd
    3              0.000207 sy region hsQQNew start="\[\(.\&[^|]\&\S\)*|" end="|\]"me=e-2 keepend contains=hsQQVarIDNew,hsQQContent nextgroup=hsQQEnd
    3              0.000042 sy match hsQQContent ".*" contained
    3              0.000040 sy match hsQQEnd "|\]" contained
    3              0.000049 sy match hsQQVarID "\[\$\(.\&[^|]\)*|" contained
    3              0.000037 sy match hsQQVarIDNew "\[\(.\&[^|]\)*|" contained
                            
    3              0.000029 if exists("hs_highlight_debug")
                              " Debugging functions from the standard prelude.
                              syn keyword hsDebug undefined error trace
                            endif
                            
                            
                            " C Preprocessor directives. Shamelessly ripped from c.vim and trimmed
                            " First, see whether to flag directive-like lines or not
    3              0.000016 if (!exists("hs_allow_hash_operator"))
    3              0.000053     syn match	cError		display "^\s*\(%:\|#\).*$"
    3              0.000005 endif
                            " Accept %: for # (C99)
    3              0.000219 syn region	cPreCondit	start="^\s*\(%:\|#\)\s*\(if\|ifdef\|ifndef\|elif\)\>" skip="\\$" end="$" end="//"me=s-1 contains=cComment,cCppString,cCommentError
    3              0.000050 syn match	cPreCondit	display "^\s*\(%:\|#\)\s*\(else\|endif\)\>"
    3              0.000094 syn region	cCppOut		start="^\s*\(%:\|#\)\s*if\s\+0\+\>" end=".\@=\|$" contains=cCppOut2
    3              0.000112 syn region	cCppOut2	contained start="0" end="^\s*\(%:\|#\)\s*\(endif\>\|else\>\|elif\>\)" contains=cCppSkip
    3              0.000116 syn region	cCppSkip	contained start="^\s*\(%:\|#\)\s*\(if\>\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\(%:\|#\)\s*endif\>" contains=cCppSkip
    3              0.000045 syn region	cIncluded	display contained start=+"+ skip=+\\\\\|\\"+ end=+"+
    3              0.000029 syn match	cIncluded	display contained "<[^>]*>"
    3              0.000102 syn match	cInclude	display "^\s*\(%:\|#\)\s*include\>\s*["<]" contains=cIncluded
    3              0.000268 syn cluster	cPreProcGroup	contains=cPreCondit,cIncluded,cInclude,cDefine,cCppOut,cCppOut2,cCppSkip,cCommentStartError
    3              0.000087 syn region	cDefine		matchgroup=cPreCondit start="^\s*\(%:\|#\)\s*\(define\|undef\)\>" skip="\\$" end="$"
    3              0.000118 syn region	cPreProc	matchgroup=cPreCondit start="^\s*\(%:\|#\)\s*\(pragma\>\|line\>\|warning\>\|warn\>\|error\>\)" skip="\\$" end="$" keepend
                            
    3              0.000130 syn region	cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=cCommentStartError,cSpaceError contained
    3              0.000028 syntax match	cCommentError	display "\*/" contained
    3              0.000025 syntax match	cCommentStartError display "/\*"me=e-1 contained
    3              0.000103 syn region	cCppString	start=+L\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial contained
                            
                            
    3              0.000031 if version >= 508 || !exists("did_hs_syntax_inits")
    3              0.000005   if version < 508
                                let did_hs_syntax_inits = 1
                                command -nargs=+ HiLink hi link <args>
                              else
    3              0.000082     command -nargs=+ HiLink hi def link <args>
    3              0.000007   endif
                            
    3              0.000104   HiLink hs_hlFunctionName    Function
    3              0.000074   HiLink hs_HighliteInfixFunctionName Function
    3              0.000073   HiLink hs_HlInfixOp       Function
    3              0.000091   HiLink hs_OpFunctionName  Function
    3              0.000071   HiLink hsTypedef          Typedef
    3              0.000054   HiLink hsVarSym           hsOperator
    3              0.000059   HiLink hsConSym           hsOperator
    3              0.000024   if exists("hs_highlight_delimiters")
                                " Some people find this highlighting distracting.
    3              0.000066 	HiLink hsDelimiter        Delimiter
    3              0.000006   endif
                            
    3              0.000068   HiLink hsModuleStartLabel Structure
    3              0.000097   HiLink hsExportModuleLabel Keyword
    3              0.000070   HiLink hsModuleWhereLabel Structure
    3              0.000072   HiLink hsModuleName       Normal
                              
    3              0.000069   HiLink hsImportIllegal    Error
    3              0.000064   HiLink hsAsLabel          hsImportLabel
    3              0.000066   HiLink hsHidingLabel      hsImportLabel
    3              0.000070   HiLink hsImportLabel      Include
    3              0.000062   HiLink hsImportMod        Include
    3              0.000068   HiLink hsPackageString    hsString
                            
    3              0.000056   HiLink hsOperator         Operator
                            
    3              0.000051   HiLink hsInfix            Keyword
    3              0.000057   HiLink hsStructure        Structure
    3              0.000060   HiLink hsStatement        Statement
    3              0.000068   HiLink hsConditional      Conditional
                            
    3              0.000057   HiLink hsSpecialCharError Error
    3              0.000073   HiLink hsSpecialChar      SpecialChar
    3              0.000075   HiLink hsString           String
    3              0.000056   HiLink hsFFIString        String
    3              0.000055   HiLink hsCharacter        Character
    3              0.000053   HiLink hsNumber           Number
    3              0.000053   HiLink hsFloat            Float
                            
    3              0.000048   HiLink hsLiterateComment		  hsComment
    3              0.000049   HiLink hsBlockComment     hsComment
    3              0.000048   HiLink hsLineComment      hsComment
    3              0.000048   HiLink hsModuleCommentA   hsComment
    3              0.000039   HiLink hsModuleCommentB   hsComment
    3              0.000045   HiLink hsComment          Comment
    3              0.000089   HiLink hsCommentTodo      Todo
    3              0.000054   HiLink hsPragma           SpecialComment
    3              0.000054   HiLink hsBoolean			  Boolean
                            
    3              0.000023   if exists("hs_highlight_types")
                                  HiLink hsDelimTypeExport  hsType
                                  HiLink hsType             Type
                              endif
                            
    3              0.000053   HiLink hsDebug            Debug
                            
    3              0.000054   HiLink cCppString         hsString
    3              0.000048   HiLink cCommentStart      hsComment
    3              0.000048   HiLink cCommentError      hsError
    3              0.000048   HiLink cCommentStartError hsError
    3              0.000051   HiLink cInclude           Include
    3              0.000064   HiLink cPreProc           PreProc
    3              0.000044   HiLink cDefine            Macro
    3              0.000043   HiLink cIncluded          hsString
    3              0.000045   HiLink cError             Error
    3              0.000046   HiLink cPreCondit         PreCondit
    3              0.000046   HiLink cComment           Comment
    3              0.000038   HiLink cCppSkip           cCppOut
    3              0.000040   HiLink cCppOut2           cCppOut
    3              0.000056   HiLink cCppOut            Comment
                            
    3              0.000053   HiLink hsFFIForeign       Keyword
    3              0.000043   HiLink hsFFIImportExport  Structure
    3              0.000040   HiLink hsFFICallConvention Keyword
    3              0.000042   HiLink hsFFISafety         Keyword
                            
    3              0.000039   HiLink hsTHIDTopLevel   Macro
    3              0.000069   HiLink hsTHTopLevelName Macro
                            
    3              0.000042   HiLink hsQQVarID Keyword
    3              0.000041   HiLink hsQQVarIDNew Keyword
    3              0.000042   HiLink hsQQEnd   Keyword
    3              0.000051   HiLink hsQQContent String
                            
    3              0.000010   delcommand HiLink
    3              0.000004 endif
                            
    3              0.000036 let b:current_syntax = "haskell"

SCRIPT  /Users/thiago/.vim/bundle/haskell-vim/syntax/haskell.vim
Sourced 3 times
Total time:   0.000148
 Self time:   0.000148

count  total (s)   self (s)
                            " syntax highlighting for haskell
                            "
                            " Heavily modified version of the haskell syntax
                            " highlighter to support haskell.
                            "
                            " author: raichoo (raichoo@googlemail.com)
                            
    3              0.000020 if version < 600
                              syn clear
                            elseif exists("b:current_syntax")
    3              0.000008   finish
                            endif
                            
                            if get(g:, 'haskell_backpack', 0)
                              syn keyword haskellBackpackStructure unit signature
                              syn keyword haskellBackpackDependency dependency
                            endif
                            
                            syn spell notoplevel
                            syn match haskellRecordField contained containedin=haskellBlock
                              \ "[_a-z][a-zA-Z0-9_']*\(,\s*[_a-z][a-zA-Z0-9_']*\)*\_s\+::\s"
                              \ contains=
                              \ haskellIdentifier,
                              \ haskellOperators,
                              \ haskellSeparator,
                              \ haskellParens
                            syn match haskellTypeSig
                              \ "^\s*\(where\s\+\|let\s\+\|default\s\+\)\?[_a-z][a-zA-Z0-9_']*#\?\(,\s*[_a-z][a-zA-Z0-9_']*#\?\)*\_s\+::\s"
                              \ contains=
                              \ haskellWhere,
                              \ haskellLet,
                              \ haskellDefault,
                              \ haskellIdentifier,
                              \ haskellOperators,
                              \ haskellSeparator,
                              \ haskellParens
                            syn keyword haskellWhere where
                            syn keyword haskellLet let
                            syn keyword haskellDeclKeyword module class instance newtype deriving in
                            syn match haskellDecl "\<\(type\|data\)\>\s\+\(\<family\>\)\?"
                            syn keyword haskellDefault default
                            syn keyword haskellImportKeywords import qualified safe as hiding contained
                            syn keyword haskellForeignKeywords foreign export import ccall safe unsafe interruptible capi prim contained
                            syn region haskellForeignImport start="\<foreign\>" end="\_s\+::\s" keepend
                              \ contains=
                              \ haskellString,
                              \ haskellOperators,
                              \ haskellForeignKeywords,
                              \ haskellIdentifier
                            syn match haskellImport "^\s*\<import\>\s\+\(\<safe\>\s\+\)\?\(\<qualified\>\s\+\)\?.\+\(\s\+\<as\>\s\+.\+\)\?\(\s\+\<hiding\>\)\?"
                              \ contains=
                              \ haskellParens,
                              \ haskellOperators,
                              \ haskellImportKeywords,
                              \ haskellType,
                              \ haskellLineComment,
                              \ haskellBlockComment,
                              \ haskellPragma
                            syn keyword haskellKeyword do case of
                            if get(g:, 'haskell_enable_static_pointers', 0)
                              syn keyword haskellStatic static
                            endif
                            syn keyword haskellConditional if then else
                            syn match haskellNumber "\<[0-9]\+\>\|\<0[xX][0-9a-fA-F]\+\>\|\<0[oO][0-7]\+\>\|\<0[bB][10]\+\>"
                            syn match haskellFloat "\<[0-9]\+\.[0-9]\+\([eE][-+]\=[0-9]\+\)\=\>"
                            syn match haskellSeparator  "[,;]"
                            syn region haskellParens matchgroup=haskellDelimiter start="(" end=")" contains=TOP,haskellTypeSig,@Spell
                            syn region haskellBrackets matchgroup=haskellDelimiter start="\[" end="]" contains=TOP,haskellTypeSig,@Spell
                            syn region haskellBlock matchgroup=haskellDelimiter start="{" end="}" contains=TOP,@Spell
                            syn keyword haskellInfix infix infixl infixr
                            syn keyword haskellBottom undefined error
                            syn match haskellOperators "[-!#$%&\*\+/<=>\?@\\^|~:.]\+\|\<_\>"
                            syn match haskellQuote "\<'\+" contained
                            syn match haskellQuotedType "[A-Z][a-zA-Z0-9_']*\>" contained
                            syn region haskellQuoted start="\<'\+" end="\>"
                              \ contains=
                              \ haskellType,
                              \ haskellQuote,
                              \ haskellQuotedType,
                              \ haskellSeparator,
                              \ haskellParens,
                              \ haskellOperators,
                              \ haskellIdentifier
                            syn match haskellLineComment "---*\([^-!#$%&\*\+./<=>\?@\\^|~].*\)\?$"
                              \ contains=
                              \ haskellTodo,
                              \ @Spell
                            syn match haskellBacktick "`[A-Za-z_][A-Za-z0-9_\.']*#\?`"
                            syn region haskellString start=+"+ skip=+\\\\\|\\"+ end=+"+
                              \ contains=@Spell
                            syn match haskellIdentifier "[_a-z][a-zA-z0-9_']*" contained
                            syn match haskellChar "\<'[^'\\]'\|'\\.'\|'\\u[0-9a-fA-F]\{4}'\>"
                            syn match haskellType "\<[A-Z][a-zA-Z0-9_']*\>"
                            syn region haskellBlockComment start="{-" end="-}"
                              \ contains=
                              \ haskellBlockComment,
                              \ haskellTodo,
                              \ @Spell
                            syn region haskellPragma start="{-#" end="#-}"
                            syn match haskellPreProc "^#.*$"
                            syn keyword haskellTodo TODO FIXME contained
                            " Treat a shebang line at the start of the file as a comment
                            syn match haskellShebang "\%^#!.*$"
                            if !get(g:, 'haskell_disable_TH', 0)
                                syn match haskellQuasiQuoted "." containedin=haskellQuasiQuote contained
                                syn region haskellQuasiQuote matchgroup=haskellTH start="\[[_a-zA-Z][a-zA-z0-9._']*|" end="|\]"
                                syn region haskellTHBlock matchgroup=haskellTH start="\[\(d\|t\|p\)\?|" end="|]" contains=TOP
                                syn region haskellTHDoubleBlock matchgroup=haskellTH start="\[||" end="||]" contains=TOP
                            endif
                            if get(g:, 'haskell_enable_typeroles', 0)
                              syn keyword haskellTypeRoles phantom representational nominal contained
                              syn region haskellTypeRoleBlock matchgroup=haskellTypeRoles start="type\s\+role" end="$" keepend
                                \ contains=
                                \ haskellType,
                                \ haskellTypeRoles
                            endif
                            if get(g:, 'haskell_enable_quantification', 0)
                              syn keyword haskellForall forall
                            endif
                            if get(g:, 'haskell_enable_recursivedo', 0)
                              syn keyword haskellRecursiveDo mdo rec
                            endif
                            if get(g:, 'haskell_enable_arrowsyntax', 0)
                              syn keyword haskellArrowSyntax proc
                            endif
                            if get(g:, 'haskell_enable_pattern_synonyms', 0)
                              syn keyword haskellPatternKeyword pattern
                            endif
                            
                            highlight def link haskellBottom Macro
                            highlight def link haskellTH Boolean
                            highlight def link haskellIdentifier Identifier
                            highlight def link haskellForeignKeywords Structure
                            highlight def link haskellKeyword Keyword
                            highlight def link haskellDefault Keyword
                            highlight def link haskellConditional Conditional
                            highlight def link haskellNumber Number
                            highlight def link haskellFloat Float
                            highlight def link haskellSeparator Delimiter
                            highlight def link haskellDelimiter Delimiter
                            highlight def link haskellInfix Keyword
                            highlight def link haskellOperators Operator
                            highlight def link haskellQuote Operator
                            highlight def link haskellShebang Comment
                            highlight def link haskellLineComment Comment
                            highlight def link haskellBlockComment Comment
                            highlight def link haskellPragma SpecialComment
                            highlight def link haskellString String
                            highlight def link haskellChar String
                            highlight def link haskellBacktick Operator
                            highlight def link haskellQuasiQuoted String
                            highlight def link haskellTodo Todo
                            highlight def link haskellPreProc PreProc
                            highlight def link haskellAssocType Type
                            highlight def link haskellQuotedType Type
                            highlight def link haskellType Type
                            highlight def link haskellImportKeywords Include
                            if get(g:, 'haskell_classic_highlighting', 0)
                              highlight def link haskellDeclKeyword Keyword
                              highlight def link haskellDecl Keyword
                              highlight def link haskellWhere Keyword
                              highlight def link haskellLet Keyword
                            else
                              highlight def link haskellDeclKeyword Structure
                              highlight def link haskellDecl Structure
                              highlight def link haskellWhere Structure
                              highlight def link haskellLet Structure
                            endif
                            
                            if get(g:, 'haskell_enable_quantification', 0)
                              highlight def link haskellForall Operator
                            endif
                            if get(g:, 'haskell_enable_recursivedo', 0)
                              highlight def link haskellRecursiveDo Keyword
                            endif
                            if get(g:, 'haskell_enable_arrowsyntax', 0)
                              highlight def link haskellArrowSyntax Keyword
                            endif
                            if get(g:, 'haskell_enable_static_pointers', 0)
                              highlight def link haskellStatic Keyword
                            endif
                            if get(g:, 'haskell_classic_highlighting', 0)
                              if get(g:, 'haskell_enable_pattern_synonyms', 0)
                                highlight def link haskellPatternKeyword Keyword
                              endif
                              if get(g:, 'haskell_enable_typeroles', 0)
                                highlight def link haskellTypeRoles Keyword
                              endif
                            else
                              if get(g:, 'haskell_enable_pattern_synonyms', 0)
                                highlight def link haskellPatternKeyword Structure
                              endif
                              if get(g:, 'haskell_enable_typeroles', 0)
                                highlight def link haskellTypeRoles Structure
                              endif
                            endif
                            
                            if get(g:, 'haskell_backpack', 0)
                              highlight def link haskellBackpackStructure Structure
                              highlight def link haskellBackpackDependency Include
                            endif
                            let b:current_syntax = "haskell"

SCRIPT  /usr/local/Cellar/vim/8.0.1400_4/share/vim/vim80/syntax/haskell.vim
Sourced 3 times
Total time:   0.000145
 Self time:   0.000145

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:		Haskell
                            " Maintainer:		Haskell Cafe mailinglist <haskell-cafe@haskell.org>
                            " Last Change:		2017 Jun 04
                            " Original Author:	John Williams <jrw@pobox.com>
                            "
                            " Thanks to Ryan Crumley for suggestions and John Meacham for
                            " pointing out bugs. Also thanks to Ian Lynagh and Donald Bruce Stewart
                            " for providing the inspiration for the inclusion of the handling
                            " of C preprocessor directives, and for pointing out a bug in the
                            " end-of-line comment handling.
                            "
                            " Options-assign a value to these variables to turn the option on:
                            "
                            " hs_highlight_delimiters - Highlight delimiter characters--users
                            "			    with a light-colored background will
                            "			    probably want to turn this on.
                            " hs_highlight_boolean - Treat True and False as keywords.
                            " hs_highlight_types - Treat names of primitive types as keywords.
                            " hs_highlight_more_types - Treat names of other common types as keywords.
                            " hs_highlight_debug - Highlight names of debugging functions.
                            " hs_allow_hash_operator - Don't highlight seemingly incorrect C
                            "			   preprocessor directives but assume them to be
                            "			   operators
                            "
                            " 2004 Feb 19: Added C preprocessor directive handling, corrected eol comments
                            "	       cleaned away literate haskell support (should be entirely in
                            "	       lhaskell.vim)
                            " 2004 Feb 20: Cleaned up C preprocessor directive handling, fixed single \
                            "	       in eol comment character class
                            " 2004 Feb 23: Made the leading comments somewhat clearer where it comes
                            "	       to attribution of work.
                            " 2008 Dec 15: Added comments as contained element in import statements
                            
                            " quit when a syntax file was already loaded
    3              0.000021 if exists("b:current_syntax")
    3              0.000014   finish
                            endif
                            
                            " (Qualified) identifiers (no default highlighting)
                            syn match ConId "\(\<[A-Z][a-zA-Z0-9_']*\.\)\=\<[A-Z][a-zA-Z0-9_']*\>"
                            syn match VarId "\(\<[A-Z][a-zA-Z0-9_']*\.\)\=\<[a-z][a-zA-Z0-9_']*\>"
                            
                            " Infix operators--most punctuation characters and any (qualified) identifier
                            " enclosed in `backquotes`. An operator starting with : is a constructor,
                            " others are variables (e.g. functions).
                            syn match hsVarSym "\(\<[A-Z][a-zA-Z0-9_']*\.\)\=[-!#$%&\*\+/<=>\?@\\^|~.][-!#$%&\*\+/<=>\?@\\^|~:.]*"
                            syn match hsConSym "\(\<[A-Z][a-zA-Z0-9_']*\.\)\=:[-!#$%&\*\+./<=>\?@\\^|~:]*"
                            syn match hsVarSym "`\(\<[A-Z][a-zA-Z0-9_']*\.\)\=[a-z][a-zA-Z0-9_']*`"
                            syn match hsConSym "`\(\<[A-Z][a-zA-Z0-9_']*\.\)\=[A-Z][a-zA-Z0-9_']*`"
                            
                            " Reserved symbols--cannot be overloaded.
                            syn match hsDelimiter  "(\|)\|\[\|\]\|,\|;\|_\|{\|}"
                            
                            " Strings and constants
                            syn match   hsSpecialChar	contained "\\\([0-9]\+\|o[0-7]\+\|x[0-9a-fA-F]\+\|[\"\\'&\\abfnrtv]\|^[A-Z^_\[\\\]]\)"
                            syn match   hsSpecialChar	contained "\\\(NUL\|SOH\|STX\|ETX\|EOT\|ENQ\|ACK\|BEL\|BS\|HT\|LF\|VT\|FF\|CR\|SO\|SI\|DLE\|DC1\|DC2\|DC3\|DC4\|NAK\|SYN\|ETB\|CAN\|EM\|SUB\|ESC\|FS\|GS\|RS\|US\|SP\|DEL\)"
                            syn match   hsSpecialCharError	contained "\\&\|'''\+"
                            syn region  hsString		start=+"+  skip=+\\\\\|\\"+  end=+"+  contains=hsSpecialChar
                            syn match   hsCharacter		"[^a-zA-Z0-9_']'\([^\\]\|\\[^']\+\|\\'\)'"lc=1 contains=hsSpecialChar,hsSpecialCharError
                            syn match   hsCharacter		"^'\([^\\]\|\\[^']\+\|\\'\)'" contains=hsSpecialChar,hsSpecialCharError
                            syn match   hsNumber		"\<[0-9]\+\>\|\<0[xX][0-9a-fA-F]\+\>\|\<0[oO][0-7]\+\>"
                            syn match   hsFloat		"\<[0-9]\+\.[0-9]\+\([eE][-+]\=[0-9]\+\)\=\>"
                            
                            " Keyword definitions. These must be patterns instead of keywords
                            " because otherwise they would match as keywords at the start of a
                            " "literate" comment (see lhs.vim).
                            syn match hsModule		"\<module\>"
                            syn match hsImport		"\<import\>.*"he=s+6 contains=hsImportMod,hsLineComment,hsBlockComment
                            syn match hsImportMod		contained "\<\(as\|qualified\|hiding\)\>"
                            syn match hsInfix		"\<\(infix\|infixl\|infixr\)\>"
                            syn match hsStructure		"\<\(class\|data\|deriving\|instance\|default\|where\)\>"
                            syn match hsTypedef		"\<\(type\|newtype\)\>"
                            syn match hsStatement		"\<\(do\|case\|of\|let\|in\)\>"
                            syn match hsConditional		"\<\(if\|then\|else\)\>"
                            
                            " Not real keywords, but close.
                            if exists("hs_highlight_boolean")
                              " Boolean constants from the standard prelude.
                              syn match hsBoolean "\<\(True\|False\)\>"
                            endif
                            if exists("hs_highlight_types")
                              " Primitive types from the standard prelude and libraries.
                              syn match hsType "\<\(Int\|Integer\|Char\|Bool\|Float\|Double\|IO\|Void\|Addr\|Array\|String\)\>"
                            endif
                            if exists("hs_highlight_more_types")
                              " Types from the standard prelude libraries.
                              syn match hsType "\<\(Maybe\|Either\|Ratio\|Complex\|Ordering\|IOError\|IOResult\|ExitCode\)\>"
                              syn match hsMaybe    "\<Nothing\>"
                              syn match hsExitCode "\<\(ExitSuccess\)\>"
                              syn match hsOrdering "\<\(GT\|LT\|EQ\)\>"
                            endif
                            if exists("hs_highlight_debug")
                              " Debugging functions from the standard prelude.
                              syn match hsDebug "\<\(undefined\|error\|trace\)\>"
                            endif
                            
                            
                            " Comments
                            syn match   hsLineComment      "---*\([^-!#$%&\*\+./<=>\?@\\^|~].*\)\?$"
                            syn region  hsBlockComment     start="{-"  end="-}" contains=hsBlockComment
                            syn region  hsPragma	       start="{-#" end="#-}"
                            
                            " C Preprocessor directives. Shamelessly ripped from c.vim and trimmed
                            " First, see whether to flag directive-like lines or not
                            if (!exists("hs_allow_hash_operator"))
                                syn match	cError		display "^\s*\(%:\|#\).*$"
                            endif
                            " Accept %: for # (C99)
                            syn region	cPreCondit	start="^\s*\(%:\|#\)\s*\(if\|ifdef\|ifndef\|elif\)\>" skip="\\$" end="$" end="//"me=s-1 contains=cComment,cCppString,cCommentError
                            syn match	cPreCondit	display "^\s*\(%:\|#\)\s*\(else\|endif\)\>"
                            syn region	cCppOut		start="^\s*\(%:\|#\)\s*if\s\+0\+\>" end=".\@=\|$" contains=cCppOut2
                            syn region	cCppOut2	contained start="0" end="^\s*\(%:\|#\)\s*\(endif\>\|else\>\|elif\>\)" contains=cCppSkip
                            syn region	cCppSkip	contained start="^\s*\(%:\|#\)\s*\(if\>\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\(%:\|#\)\s*endif\>" contains=cCppSkip
                            syn region	cIncluded	display contained start=+"+ skip=+\\\\\|\\"+ end=+"+
                            syn match	cIncluded	display contained "<[^>]*>"
                            syn match	cInclude	display "^\s*\(%:\|#\)\s*include\>\s*["<]" contains=cIncluded
                            syn cluster	cPreProcGroup	contains=cPreCondit,cIncluded,cInclude,cDefine,cCppOut,cCppOut2,cCppSkip,cCommentStartError
                            syn region	cDefine		matchgroup=cPreCondit start="^\s*\(%:\|#\)\s*\(define\|undef\)\>" skip="\\$" end="$"
                            syn region	cPreProc	matchgroup=cPreCondit start="^\s*\(%:\|#\)\s*\(pragma\>\|line\>\|warning\>\|warn\>\|error\>\)" skip="\\$" end="$" keepend
                            
                            syn region	cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=cCommentStartError,cSpaceError contained
                            syntax match	cCommentError	display "\*/" contained
                            syntax match	cCommentStartError display "/\*"me=e-1 contained
                            syn region	cCppString	start=+L\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial contained
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
                            hi def link hsModule			  hsStructure
                            hi def link hsImport			  Include
                            hi def link hsImportMod			  hsImport
                            hi def link hsInfix			  PreProc
                            hi def link hsStructure			  Structure
                            hi def link hsStatement			  Statement
                            hi def link hsConditional			  Conditional
                            hi def link hsSpecialChar			  SpecialChar
                            hi def link hsTypedef			  Typedef
                            hi def link hsVarSym			  hsOperator
                            hi def link hsConSym			  hsOperator
                            hi def link hsOperator			  Operator
                            if exists("hs_highlight_delimiters")
                            " Some people find this highlighting distracting.
                            hi def link hsDelimiter			  Delimiter
                            endif
                            hi def link hsSpecialCharError		  Error
                            hi def link hsString			  String
                            hi def link hsCharacter			  Character
                            hi def link hsNumber			  Number
                            hi def link hsFloat			  Float
                            hi def link hsConditional			  Conditional
                            hi def link hsLiterateComment		  hsComment
                            hi def link hsBlockComment		  hsComment
                            hi def link hsLineComment			  hsComment
                            hi def link hsComment			  Comment
                            hi def link hsPragma			  SpecialComment
                            hi def link hsBoolean			  Boolean
                            hi def link hsType			  Type
                            hi def link hsMaybe			  hsEnumConst
                            hi def link hsOrdering			  hsEnumConst
                            hi def link hsEnumConst			  Constant
                            hi def link hsDebug			  Debug
                            
                            hi def link cCppString		hsString
                            hi def link cCommentStart		hsComment
                            hi def link cCommentError		hsError
                            hi def link cCommentStartError	hsError
                            hi def link cInclude		Include
                            hi def link cPreProc		PreProc
                            hi def link cDefine		Macro
                            hi def link cIncluded		hsString
                            hi def link cError			Error
                            hi def link cPreCondit		PreCondit
                            hi def link cComment		Comment
                            hi def link cCppSkip		cCppOut
                            hi def link cCppOut2		cCppOut
                            hi def link cCppOut		Comment
                            
                            
                            let b:current_syntax = "haskell"
                            
                            " Options for vi: ts=8 sw=2 sts=2 nowrap noexpandtab ft=vim

SCRIPT  /usr/local/Cellar/vim/8.0.1400_4/share/vim/vim80/ftplugin/yaml.vim
Sourced 1 time
Total time:   0.000252
 Self time:   0.000252

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:             YAML (YAML Ain't Markup Language)
                            " Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
                            " Latest Revision:      2008-07-09
                            
    1              0.000025 if exists("b:did_ftplugin")
                              finish
                            endif
    1              0.000007 let b:did_ftplugin = 1
                            
    1              0.000017 let s:cpo_save = &cpo
    1              0.000051 set cpo&vim
                            
    1              0.000007 let b:undo_ftplugin = "setl com< cms< et< fo<"
                            
    1              0.000019 setlocal comments=:# commentstring=#\ %s expandtab
    1              0.000010 setlocal formatoptions-=t formatoptions+=croql
                            
    1              0.000023 let &cpo = s:cpo_save
    1              0.000013 unlet s:cpo_save

SCRIPT  /usr/local/Cellar/vim/8.0.1400_4/share/vim/vim80/indent/yaml.vim
Sourced 1 time
Total time:   0.000141
 Self time:   0.000141

count  total (s)   self (s)
                            " Vim indent file
                            " Language:         YAML
                            " Maintainer:       Nikolai Pavlov <zyx.vim@gmail.com>
                            " Last Change:	    2017 Jun 13
                            
                            " Only load this indent file when no other was loaded.
    1              0.000014 if exists('b:did_indent')
                              finish
                            endif
                            
    1              0.000018 let s:save_cpo = &cpo
    1              0.000016 set cpo&vim
                            
    1              0.000016 let b:did_indent = 1
                            
    1              0.000007 setlocal indentexpr=GetYAMLIndent(v:lnum)
    1              0.000005 setlocal indentkeys=!^F,o,O,0#,0},0],<:>,0-
    1              0.000009 setlocal nosmartindent
                            
    1              0.000005 let b:undo_indent = 'setlocal indentexpr< indentkeys< smartindent<'
                            
                            " Only define the function once.
    1              0.000006 if exists('*GetYAMLIndent')
    1              0.000002     finish
                            endif
                            
                            function s:FindPrevLessIndentedLine(lnum, ...)
                                let prevlnum = prevnonblank(a:lnum-1)
                                let curindent = a:0 ? a:1 : indent(a:lnum)
                                while           prevlnum
                                            \&&  indent(prevlnum) >=  curindent
                                            \&& getline(prevlnum) =~# '^\s*#'
                                    let prevlnum = prevnonblank(prevlnum-1)
                                endwhile
                                return prevlnum
                            endfunction
                            
                            function s:FindPrevLEIndentedLineMatchingRegex(lnum, regex)
                                let plilnum = s:FindPrevLessIndentedLine(a:lnum, indent(a:lnum)+1)
                                while plilnum && getline(plilnum) !~# a:regex
                                    let plilnum = s:FindPrevLessIndentedLine(plilnum)
                                endwhile
                                return plilnum
                            endfunction
                            
                            let s:mapkeyregex='\v^\s*\#@!\S@=%(\''%([^'']|\''\'')*\'''.
                                            \                 '|\"%([^"\\]|\\.)*\"'.
                                            \                 '|%(%(\:\ )@!.)*)\:%(\ |$)'
                            let s:liststartregex='\v^\s*%(\-%(\ |$))'
                            
                            let s:c_ns_anchor_char = '\v%([\n\r\uFEFF \t,[\]{}]@!\p)'
                            let s:c_ns_anchor_name = s:c_ns_anchor_char.'+'
                            let s:c_ns_anchor_property =  '\v\&'.s:c_ns_anchor_name
                            
                            let s:ns_word_char = '\v[[:alnum:]_\-]'
                            let s:ns_tag_char  = '\v%(%\x\x|'.s:ns_word_char.'|[#/;?:@&=+$.~*''()])'
                            let s:c_named_tag_handle     = '\v\!'.s:ns_word_char.'+\!'
                            let s:c_secondary_tag_handle = '\v\!\!'
                            let s:c_primary_tag_handle   = '\v\!'
                            let s:c_tag_handle = '\v%('.s:c_named_tag_handle.
                                        \            '|'.s:c_secondary_tag_handle.
                                        \            '|'.s:c_primary_tag_handle.')'
                            let s:c_ns_shorthand_tag = '\v'.s:c_tag_handle . s:ns_tag_char.'+'
                            let s:c_non_specific_tag = '\v\!'
                            let s:ns_uri_char  = '\v%(%\x\x|'.s:ns_word_char.'\v|[#/;?:@&=+$,.!~*''()[\]])'
                            let s:c_verbatim_tag = '\v\!\<'.s:ns_uri_char.'+\>'
                            let s:c_ns_tag_property = '\v'.s:c_verbatim_tag.
                                        \               '\v|'.s:c_ns_shorthand_tag.
                                        \               '\v|'.s:c_non_specific_tag
                            
                            let s:block_scalar_header = '\v[|>]%([+-]?[1-9]|[1-9]?[+-])?'
                            
                            function GetYAMLIndent(lnum)
                                if a:lnum == 1 || !prevnonblank(a:lnum-1)
                                    return 0
                                endif
                            
                                let prevlnum = prevnonblank(a:lnum-1)
                                let previndent = indent(prevlnum)
                            
                                let line = getline(a:lnum)
                                if line =~# '^\s*#' && getline(a:lnum-1) =~# '^\s*#'
                                    " Comment blocks should have identical indent
                                    return previndent
                                elseif line =~# '^\s*[\]}]'
                                    " Lines containing only closing braces should have previous indent
                                    return indent(s:FindPrevLessIndentedLine(a:lnum))
                                endif
                            
                                " Ignore comment lines when calculating indent
                                while getline(prevlnum) =~# '^\s*#'
                                    let prevlnum = prevnonblank(prevlnum-1)
                                    if !prevlnum
                                        return previndent
                                    endif
                                endwhile
                            
                                let prevline = getline(prevlnum)
                                let previndent = indent(prevlnum)
                            
                                " Any examples below assume that shiftwidth=2
                                if prevline =~# '\v[{[:]$|[:-]\ [|>][+\-]?%(\s+\#.*|\s*)$'
                                    " Mapping key:
                                    "     nested mapping: ...
                                    "
                                    " - {
                                    "     key: [
                                    "         list value
                                    "     ]
                                    " }
                                    "
                                    " - |-
                                    "     Block scalar without indentation indicator
                                    return previndent+shiftwidth()
                                elseif prevline =~# '\v[:-]\ [|>]%(\d+[+\-]?|[+\-]?\d+)%(\#.*|\s*)$'
                                    " - |+2
                                    "   block scalar with indentation indicator
                                    "#^^ indent+2, not indent+shiftwidth
                                    return previndent + str2nr(matchstr(prevline,
                                                \'\v([:-]\ [|>])@<=[+\-]?\d+%([+\-]?%(\s+\#.*|\s*)$)@='))
                                elseif prevline =~# '\v\"%([^"\\]|\\.)*\\$'
                                    "    "Multiline string \
                                    "     with escaped end"
                                    let qidx = match(prevline, '\v\"%([^"\\]|\\.)*\\')
                                    return virtcol([prevlnum, qidx+1])
                                elseif line =~# s:liststartregex
                                    " List line should have indent equal to previous list line unless it was 
                                    " caught by one of the previous rules
                                    return indent(s:FindPrevLEIndentedLineMatchingRegex(a:lnum,
                                                \                                       s:liststartregex))
                                elseif line =~# s:mapkeyregex
                                    " Same for line containing mapping key
                                    let prevmapline = s:FindPrevLEIndentedLineMatchingRegex(a:lnum,
                                                \                                           s:mapkeyregex)
                                    if getline(prevmapline) =~# '^\s*- '
                                        return indent(prevmapline) + 2
                                    else
                                        return indent(prevmapline)
                                    endif
                                elseif prevline =~# '^\s*- '
                                    " - List with
                                    "   multiline scalar
                                    return previndent+2
                                elseif prevline =~# s:mapkeyregex . '\v\s*%(%('.s:c_ns_tag_property.
                                            \                              '\v|'.s:c_ns_anchor_property.
                                            \                              '\v|'.s:block_scalar_header.
                                            \                             '\v)%(\s+|\s*%(\#.*)?$))*'
                                    " Mapping with: value
                                    "     that is multiline scalar
                                    return previndent+shiftwidth()
                                endif
                                return previndent
                            endfunction
                            
                            let &cpo = s:save_cpo

SCRIPT  /usr/local/Cellar/vim/8.0.1400_4/share/vim/vim80/syntax/yaml.vim
Sourced 1 time
Total time:   0.003602
 Self time:   0.003227

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:         YAML (YAML Ain't Markup Language) 1.2
                            " Maintainer:       Nikolai Pavlov <zyx.vim@gmail.com>
                            " First author:     Nikolai Weibull <now@bitwi.se>
                            " Latest Revision:  2015-03-28
                            
    1              0.000014 if exists('b:current_syntax')
                                finish
                            endif
                            
    1              0.000021 let s:cpo_save = &cpo
    1              0.000017 set cpo&vim
                            
                            " Choose the schema to use
                            " TODO: Validate schema
    1              0.000006 if !exists('b:yaml_schema')
                              if exists('g:yaml_schema')
                                let b:yaml_schema = g:yaml_schema
                              else
                                let b:yaml_schema = 'core'
                              endif
                            endif
                            
    1              0.000004 let s:ns_char = '\%([\n\r\uFEFF \t]\@!\p\)'
    1              0.000003 let s:ns_word_char = '[[:alnum:]_\-]'
    1              0.000006 let s:ns_uri_char  = '\%(%\x\x\|'.s:ns_word_char.'\|[#/;?:@&=+$,.!~*''()[\]]\)'
    1              0.000005 let s:ns_tag_char  = '\%(%\x\x\|'.s:ns_word_char.'\|[#/;?:@&=+$.~*''()]\)'
    1              0.000004 let s:c_ns_anchor_char = '\%([\n\r\uFEFF \t,[\]{}]\@!\p\)'
    1              0.000003 let s:c_indicator      = '[\-?:,[\]{}#&*!|>''"%@`]'
    1              0.000003 let s:c_flow_indicator = '[,[\]{}]'
                            
    1              0.000024 let s:ns_char_without_c_indicator = substitute(s:ns_char, '\v\C[\zs', '\=s:c_indicator[1:-2]', '')
                            
    1              0.000004 let s:_collection = '[^\@!\(\%(\\\.\|\[^\\\]]\)\+\)]'
    1              0.000012 let s:_neg_collection = '[^\(\%(\\\.\|\[^\\\]]\)\+\)]'
    1              0.000006 function s:SimplifyToAssumeAllPrintable(p)
                                return substitute(a:p, '\V\C\\%('.s:_collection.'\\@!\\p\\)', '[^\1]', '')
                            endfunction
    1   0.000101   0.000042 let s:ns_char = s:SimplifyToAssumeAllPrintable(s:ns_char)
    1   0.000082   0.000010 let s:ns_char_without_c_indicator = s:SimplifyToAssumeAllPrintable(s:ns_char_without_c_indicator)
    1   0.000063   0.000010 let s:c_ns_anchor_char = s:SimplifyToAssumeAllPrintable(s:c_ns_anchor_char)
                            
    1              0.000004 function s:SimplifyAdjacentCollections(p)
                                return substitute(a:p, '\V\C'.s:_collection.'\\|'.s:_collection, '[\1\2]', 'g')
                            endfunction
    1   0.000114   0.000051 let s:ns_uri_char = s:SimplifyAdjacentCollections(s:ns_uri_char)
    1   0.000069   0.000015 let s:ns_tag_char = s:SimplifyAdjacentCollections(s:ns_tag_char)
                            
    1              0.000006 let s:c_verbatim_tag = '!<'.s:ns_uri_char.'\+>'
    1              0.000005 let s:c_named_tag_handle     = '!'.s:ns_word_char.'\+!'
    1              0.000003 let s:c_secondary_tag_handle = '!!'
    1              0.000004 let s:c_primary_tag_handle   = '!'
    1              0.000011 let s:c_tag_handle = '\%('.s:c_named_tag_handle.
                                        \         '\|'.s:c_secondary_tag_handle.
                                        \         '\|'.s:c_primary_tag_handle.'\)'
    1              0.000006 let s:c_ns_shorthand_tag = s:c_tag_handle . s:ns_tag_char.'\+'
    1              0.000003 let s:c_non_specific_tag = '!'
    1              0.000010 let s:c_ns_tag_property = s:c_verbatim_tag.
                                        \        '\|'.s:c_ns_shorthand_tag.
                                        \        '\|'.s:c_non_specific_tag
                            
    1              0.000006 let s:c_ns_anchor_name = s:c_ns_anchor_char.'\+'
    1              0.000004 let s:c_ns_anchor_property =  '&'.s:c_ns_anchor_name
    1              0.000003 let s:c_ns_alias_node      = '\*'.s:c_ns_anchor_name
                            
    1              0.000004 let s:ns_directive_name = s:ns_char.'\+'
                            
    1              0.000004 let s:ns_local_tag_prefix  = '!'.s:ns_uri_char.'*'
    1              0.000005 let s:ns_global_tag_prefix = s:ns_tag_char.s:ns_uri_char.'*'
    1              0.000007 let s:ns_tag_prefix = s:ns_local_tag_prefix.
                                        \    '\|'.s:ns_global_tag_prefix
                            
    1              0.000004 let s:ns_plain_safe_out = s:ns_char
    1              0.000007 let s:ns_plain_safe_in  = '\%('.s:c_flow_indicator.'\@!'.s:ns_char.'\)'
                            
    1              0.000081 let s:ns_plain_safe_in = substitute(s:ns_plain_safe_in, '\V\C\\%('.s:_collection.'\\@!'.s:_neg_collection.'\\)', '[^\1\2]', '')
    1              0.000055 let s:ns_plain_safe_in_without_colhash = substitute(s:ns_plain_safe_in, '\V\C'.s:_neg_collection, '[^\1:#]', '')
    1              0.000042 let s:ns_plain_safe_out_without_colhash = substitute(s:ns_plain_safe_out, '\V\C'.s:_neg_collection, '[^\1:#]', '')
                            
    1              0.000006 let s:ns_plain_first_in  = '\%('.s:ns_char_without_c_indicator.'\|[?:\-]\%('.s:ns_plain_safe_in.'\)\@=\)'
    1              0.000004 let s:ns_plain_first_out = '\%('.s:ns_char_without_c_indicator.'\|[?:\-]\%('.s:ns_plain_safe_out.'\)\@=\)'
                            
    1              0.000006 let s:ns_plain_char_in  = '\%('.s:ns_char.'#\|:'.s:ns_plain_safe_in.'\|'.s:ns_plain_safe_in_without_colhash.'\)'
    1              0.000005 let s:ns_plain_char_out = '\%('.s:ns_char.'#\|:'.s:ns_plain_safe_out.'\|'.s:ns_plain_safe_out_without_colhash.'\)'
                            
    1              0.000003 let s:ns_plain_out = s:ns_plain_first_out . s:ns_plain_char_out.'*'
    1              0.000004 let s:ns_plain_in  = s:ns_plain_first_in  . s:ns_plain_char_in.'*'
                            
                            
    1              0.000027 syn keyword yamlTodo            contained TODO FIXME XXX NOTE
                            
    1              0.000024 syn region  yamlComment         display oneline start='\%\(^\|\s\)#' end='$'
                                        \                   contains=yamlTodo
                            
    1              0.000096 execute 'syn region yamlDirective oneline start='.string('^\ze%'.s:ns_directive_name.'\s\+').' '.
                                        \                            'end="$" '.
                                        \                            'contains=yamlTAGDirective,'.
                                        \                                     'yamlYAMLDirective,'.
                                        \                                     'yamlReservedDirective '.
                                        \                            'keepend'
                            
    1              0.000031 syn match yamlTAGDirective '%TAG\s\+' contained nextgroup=yamlTagHandle
    1              0.000045 execute 'syn match yamlTagHandle contained nextgroup=yamlTagPrefix '.string(s:c_tag_handle.'\s\+')
    1              0.000053 execute 'syn match yamlTagPrefix contained nextgroup=yamlComment ' . string(s:ns_tag_prefix)
                            
    1              0.000028 syn match yamlYAMLDirective '%YAML\s\+'  contained nextgroup=yamlYAMLVersion
    1              0.000025 syn match yamlYAMLVersion   '\d\+\.\d\+' contained nextgroup=yamlComment
                            
    1              0.000046 execute 'syn match yamlReservedDirective contained nextgroup=yamlComment '.
                                        \string('%\%(\%(TAG\|YAML\)\s\)\@!'.s:ns_directive_name)
                            
    1              0.000061 syn region yamlFlowString matchgroup=yamlFlowStringDelimiter start='"' skip='\\"' end='"'
                                        \ contains=yamlEscape
                                        \ nextgroup=yamlKeyValueDelimiter
    1              0.000047 syn region yamlFlowString matchgroup=yamlFlowStringDelimiter start="'" skip="''"  end="'"
                                        \ contains=yamlSingleEscape
                                        \ nextgroup=yamlKeyValueDelimiter
    1              0.000013 syn match  yamlEscape contained '\\\%([\\"abefnrtv\^0_ NLP\n]\|x\x\x\|u\x\{4}\|U\x\{8}\)'
    1              0.000007 syn match  yamlSingleEscape contained "''"
                            
    1              0.000010 syn match yamlBlockScalarHeader contained '\s\+\zs[|>]\%([+-]\=[1-9]\|[1-9]\=[+-]\)\='
                            
    1              0.000016 syn cluster yamlConstant contains=yamlBool,yamlNull
                            
    1              0.000021 syn cluster yamlFlow contains=yamlFlowString,yamlFlowMapping,yamlFlowCollection
    1              0.000016 syn cluster yamlFlow      add=yamlFlowMappingKey,yamlFlowMappingMerge
    1              0.000016 syn cluster yamlFlow      add=@yamlConstant,yamlPlainScalar,yamlFloat
    1              0.000040 syn cluster yamlFlow      add=yamlTimestamp,yamlInteger,yamlMappingKeyStart
    1              0.000038 syn cluster yamlFlow      add=yamlComment
    1              0.000030 syn region yamlFlowMapping    matchgroup=yamlFlowIndicator start='{' end='}' contains=@yamlFlow
    1              0.000026 syn region yamlFlowCollection matchgroup=yamlFlowIndicator start='\[' end='\]' contains=@yamlFlow
                            
    1              0.000034 execute 'syn match yamlPlainScalar /'.s:ns_plain_out.'/'
    1              0.000032 execute 'syn match yamlPlainScalar contained /'.s:ns_plain_in.'/'
                            
    1              0.000014 syn match yamlMappingKeyStart '?\ze\s'
    1              0.000013 syn match yamlMappingKeyStart '?' contained
                            
    1              0.000075 execute 'syn match yamlFlowMappingKey /\%#=1'.s:ns_plain_in.'\%(\s\+'.s:ns_plain_in.'\)*\ze\s*:/ contained '.
                                        \'nextgroup=yamlKeyValueDelimiter'
    1              0.000017 syn match yamlFlowMappingMerge /<<\ze\s*:/ contained nextgroup=yamlKeyValueDelimiter
                            
    1              0.000022 syn match yamlBlockCollectionItemStart '^\s*\zs-\%(\s\+-\)*\s' nextgroup=yamlBlockMappingKey,yamlBlockMappingMerge
                            " Use the old regexp engine, the NFA engine doesn't like all the \@ items.
    1              0.000042 execute 'syn match yamlBlockMappingKey /\%#=1^\s*\zs'.s:ns_plain_out.'\%(\s\+'.s:ns_plain_out.'\)*\ze\s*:\%(\s\|$\)/ '.
                                        \'nextgroup=yamlKeyValueDelimiter'
    1              0.000052 execute 'syn match yamlBlockMappingKey /\%#=1\s*\zs'.s:ns_plain_out.'\%(\s\+'.s:ns_plain_out.'\)*\ze\s*:\%(\s\|$\)/ contained '.
                                        \'nextgroup=yamlKeyValueDelimiter'
    1              0.000083 syn match yamlBlockMappingMerge /^\s*\zs<<\ze:\%(\s\|$\)/ nextgroup=yamlKeyValueDelimiter
    1              0.000039 syn match yamlBlockMappingMerge /<<\ze\s*:\%(\s\|$\)/ nextgroup=yamlKeyValueDelimiter contained
                            
    1              0.000020 syn match   yamlKeyValueDelimiter /\s*:/ contained
    1              0.000017 syn match   yamlKeyValueDelimiter /\s*:/ contained
                            
    1              0.000044 syn cluster yamlScalarWithSpecials contains=yamlPlainScalar,yamlBlockMappingKey,yamlFlowMappingKey
                            
    1   0.000092   0.000018 let s:_bounder = s:SimplifyToAssumeAllPrintable('\%([[\]{}, \t]\@!\p\)')
    1              0.000005 if b:yaml_schema is# 'json'
                                syn keyword yamlNull null contained containedin=@yamlScalarWithSpecials
                                syn keyword yamlBool true false
                                exe 'syn match   yamlInteger /'.s:_bounder.'\@1<!\%(0\|-\=[1-9][0-9]*\)'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
                                exe 'syn match   yamlFloat   /'.s:_bounder.'\@1<!\%(-\=[1-9][0-9]*\%(\.[0-9]*\)\=\(e[-+]\=[0-9]\+\)\=\|0\|-\=\.inf\|\.nan\)'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
                            elseif b:yaml_schema is# 'core'
    1              0.000027     syn keyword yamlNull null Null NULL contained containedin=@yamlScalarWithSpecials
    1              0.000024     syn keyword yamlBool true True TRUE false False FALSE contained containedin=@yamlScalarWithSpecials
    1              0.000028     exe 'syn match   yamlNull /'.s:_bounder.'\@1<!\~'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
    1              0.000045     exe 'syn match   yamlInteger /'.s:_bounder.'\@1<!\%([+-]\=\%(0\%(b[0-1_]\+\|[0-7_]\+\|x[0-9a-fA-F_]\+\)\=\|\%([1-9][0-9_]*\%(:[0-5]\=\d\)\+\)\)\|[1-9][0-9_]*\)'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
    1              0.000049     exe 'syn match   yamlFloat /'.s:_bounder.'\@1<!\%([+-]\=\%(\%(\d[0-9_]*\)\.[0-9_]*\%([eE][+-]\=\d\+\)\=\|\.[0-9_]\+\%([eE][-+]\=[0-9]\+\)\=\|\d[0-9_]*\%(:[0-5]\=\d\)\+\.[0-9_]*\|\.\%(inf\|Inf\|INF\)\)\|\%(\.\%(nan\|NaN\|NAN\)\)\)'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
    1              0.000003 elseif b:yaml_schema is# 'pyyaml'
                                syn keyword yamlNull null Null NULL contained containedin=@yamlScalarWithSpecials
                                syn keyword yamlBool true True TRUE false False FALSE yes Yes YES no No NO on On ON off Off OFF contained containedin=@yamlScalarWithSpecials
                                exe 'syn match   yamlNull /'.s:_bounder.'\@1<!\~'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
                                exe 'syn match  yamlFloat /'.s:_bounder.'\@1<!\%(\v[-+]?%(\d[0-9_]*)\.[0-9_]*%([eE][-+]\d+)?|\.[0-9_]+%([eE][-+]\d+)?|[-+]?\d[0-9_]*%(\:[0-5]?\d)+\.[0-9_]*|[-+]?\.%(inf|Inf|INF)|\.%(nan|NaN|NAN)\m\)'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
                                exe 'syn match  yamlInteger /'.s:_bounder.'\@1<!\%(\v[-+]?0b[0-1_]+|[-+]?0[0-7_]+|[-+]?%(0|[1-9][0-9_]*)|[-+]?0x[0-9a-fA-F_]+|[-+]?[1-9][0-9_]*%(:[0-5]?\d)+\m\)'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
                                exe 'syn match  yamlTimestamp /'.s:_bounder.'\@1<!\%(\v\d\d\d\d\-\d\d\-\d\d|\d\d\d\d \-\d\d? \-\d\d?%([Tt]|[ \t]+)\d\d?\:\d\d \:\d\d %(\.\d*)?%([ \t]*%(Z|[-+]\d\d?%(\:\d\d)?))?\m\)'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
                            elseif b:yaml_schema is# 'failsafe'
                                " Nothing
                            endif
    1              0.000004 unlet s:_bounder
                            
                            
    1              0.000045 execute 'syn match yamlNodeTag '.string(s:c_ns_tag_property)
    1              0.000024 execute 'syn match yamlAnchor  '.string(s:c_ns_anchor_property)
    1              0.000022 execute 'syn match yamlAlias   '.string(s:c_ns_alias_node)
                            
    1              0.000014 syn match yamlDocumentStart '^---\ze\%(\s\|$\)'
    1              0.000012 syn match yamlDocumentEnd   '^\.\.\.\ze\%(\s\|$\)'
                            
    1              0.000025 hi def link yamlTodo                     Todo
    1              0.000020 hi def link yamlComment                  Comment
                            
    1              0.000018 hi def link yamlDocumentStart            PreProc
    1              0.000018 hi def link yamlDocumentEnd              PreProc
                            
    1              0.000017 hi def link yamlDirectiveName            Keyword
                            
    1              0.000016 hi def link yamlTAGDirective             yamlDirectiveName
    1              0.000016 hi def link yamlTagHandle                String
    1              0.000016 hi def link yamlTagPrefix                String
                            
    1              0.000015 hi def link yamlYAMLDirective            yamlDirectiveName
    1              0.000017 hi def link yamlReservedDirective        Error
    1              0.000016 hi def link yamlYAMLVersion              Number
                            
    1              0.000016 hi def link yamlString                   String
    1              0.000015 hi def link yamlFlowString               yamlString
    1              0.000015 hi def link yamlFlowStringDelimiter      yamlString
    1              0.000117 hi def link yamlEscape                   SpecialChar
    1              0.000038 hi def link yamlSingleEscape             SpecialChar
                            
    1              0.000025 hi def link yamlBlockCollectionItemStart Label
    1              0.000021 hi def link yamlBlockMappingKey          Identifier
    1              0.000023 hi def link yamlBlockMappingMerge        Special
                            
    1              0.000063 hi def link yamlFlowMappingKey           Identifier
    1              0.000033 hi def link yamlFlowMappingMerge         Special
                            
    1              0.000022 hi def link yamlMappingKeyStart          Special
    1              0.000019 hi def link yamlFlowIndicator            Special
    1              0.000017 hi def link yamlKeyValueDelimiter        Special
                            
    1              0.000019 hi def link yamlConstant                 Constant
                            
    1              0.000015 hi def link yamlNull                     yamlConstant
    1              0.000016 hi def link yamlBool                     yamlConstant
                            
    1              0.000019 hi def link yamlAnchor                   Type
    1              0.000020 hi def link yamlAlias                    Type
    1              0.000020 hi def link yamlNodeTag                  Type
                            
    1              0.000018 hi def link yamlInteger                  Number
    1              0.000018 hi def link yamlFloat                    Float
    1              0.000025 hi def link yamlTimestamp                Number
                            
    1              0.000008 let b:current_syntax = "yaml"
                            
    1              0.000048 unlet s:ns_word_char s:ns_uri_char s:c_verbatim_tag s:c_named_tag_handle s:c_secondary_tag_handle s:c_primary_tag_handle s:c_tag_handle s:ns_tag_char s:c_ns_shorthand_tag s:c_non_specific_tag s:c_ns_tag_property s:c_ns_anchor_char s:c_ns_anchor_name s:c_ns_anchor_property s:c_ns_alias_node s:ns_char s:ns_directive_name s:ns_local_tag_prefix s:ns_global_tag_prefix s:ns_tag_prefix s:c_indicator s:ns_plain_safe_out s:c_flow_indicator s:ns_plain_safe_in s:ns_plain_first_in s:ns_plain_first_out s:ns_plain_char_in s:ns_plain_char_out s:ns_plain_out s:ns_plain_in s:ns_char_without_c_indicator s:ns_plain_safe_in_without_colhash s:ns_plain_safe_out_without_colhash
    1              0.000005 unlet s:_collection s:_neg_collection
    1              0.000010 delfunction s:SimplifyAdjacentCollections
    1              0.000023 delfunction s:SimplifyToAssumeAllPrintable
                            
    1              0.000018 let &cpo = s:cpo_save
    1              0.000007 unlet s:cpo_save

FUNCTION  neocomplete#available_sources()
Called 1 time
Total time:   0.000072
 Self time:   0.000058

count  total (s)   self (s)
    1   0.000072   0.000058   return copy(neocomplete#variables#get_sources())

FUNCTION  <SNR>99_check_in_do_auto_complete()
Called 23 times
Total time:   0.003064
 Self time:   0.001312

count  total (s)   self (s)
   23   0.001808   0.000250   if neocomplete#is_locked() || (a:event !=# 'InsertEnter' && mode() !=# 'i')
                                return 1
                              endif
                            
                              " Detect completefunc.
   23              0.000063   if &l:completefunc != '' && &l:buftype =~ 'nofile'
                                return 1
                              endif
                            
   23   0.000317   0.000123   let neocomplete = neocomplete#get_current_neocomplete()
                              " Detect foldmethod.
   23              0.000139   if (&l:foldmethod ==# 'expr' || &l:foldmethod ==# 'syntax') && !neocomplete.detected_foldmethod && a:event !=# 'InsertEnter' && line('.') > 1000
                                let neocomplete.detected_foldmethod = 1
                                call neocomplete#print_error( printf('foldmethod = "%s" is detected.', &foldmethod))
                                redir => foldmethod
                                  verbose setlocal foldmethod?
                                redir END
                                for msg in split(substitute(foldmethod, '\t', '', 'g'), "\n")
                                  call neocomplete#print_error(msg)
                                endfor
                                call neocomplete#print_error( 'You should disable it or install FastFold plugin.')
                              endif

FUNCTION  ale#sign#SetSigns()
Called 46 times
Total time:   0.028856
 Self time:   0.005554

count  total (s)   self (s)
   46              0.000270     if !bufexists(str2nr(a:buffer))
                                    " Stop immediately when attempting to set signs for a buffer which
                                    " does not exist.
                                    return
                                endif
                            
                                " Find the current markers
   46   0.009438   0.000635     let [l:is_dummy_sign_set, l:current_sign_list] =   ale#sign#FindCurrentSigns(a:buffer)
                            
                                " Update the line numbers for items from before which may have moved.
   46   0.002709   0.000869     call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                            
                                " Group items after updating the line numbers.
   46   0.002019   0.000672     let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                            
                                " Build a map of current and new signs, with the lines as the keys.
   46   0.007547   0.000569     let l:sign_map = s:BuildSignMap(   a:buffer,   l:current_sign_list,   l:grouped_items,)
                            
   46   0.004973   0.000639     let l:command_list = ale#sign#GetSignCommands(   a:buffer,   l:is_dummy_sign_set,   l:sign_map,)
                            
                                " Change the sign column color if the option is on.
   46              0.000143     if g:ale_change_sign_column_color && !empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithErrors
                                endif
                            
   46              0.000100     for l:command in l:command_list
                                    silent! execute l:command
                                endfor
                            
                                " Reset the sign column color when there are no more errors.
   46              0.000120     if g:ale_change_sign_column_color && empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithoutErrors
                                endif

FUNCTION  <SNR>21_buffer_spec()
Called 24 times
Total time:   0.001855
 Self time:   0.001231

count  total (s)   self (s)
   24              0.000112     let bufname = bufname(self['#'])
   24   0.001714   0.001090     return s:shellslash(bufname == '' ? '' : fnamemodify(bufname,':p'))

FUNCTION  ale#job#IsRunning()
Called 48 times
Total time:   0.001657
 Self time:   0.001657

count  total (s)   self (s)
   48              0.000299     if has('nvim')
                                    try
                                        " In NeoVim, if the job isn't running, jobpid() will throw.
                                        call jobpid(a:job_id)
                                        return 1
                                    catch
                                    endtry
                                elseif has_key(s:job_map, a:job_id)
                                    let l:job = s:job_map[a:job_id].job
                                    return job_status(l:job) is# 'run'
                                endif
                            
   48              0.000065     return 0

FUNCTION  necoghc#caching_modules()
Called 5 times
Total time:   0.023956
 Self time:   0.000220

count  total (s)   self (s)
    5   0.023903   0.000167   let b:necoghc_modules_cache = s:extract_modules()
    5              0.000009   if s:is_async
                                for l:mod in keys(b:necoghc_modules_cache)
                                  call necoghc#browse(l:mod)
                                endfor
                              endif

FUNCTION  <SNR>21_repo()
Called 12 times
Total time:   0.000367
 Self time:   0.000367

count  total (s)   self (s)
   12              0.000087   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
   12              0.000023   if dir !=# ''
   12              0.000041     if has_key(s:repos, dir)
   12              0.000048       let repo = get(s:repos, dir)
   12              0.000012     else
                                  let repo = {'git_dir': dir}
                                  let s:repos[dir] = repo
                                endif
   12              0.000089     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  <SNR>99_is_delimiter()
Called 2 times
Total time:   0.000582
 Self time:   0.000076

count  total (s)   self (s)
                              " Check delimiter pattern.
    2              0.000005   let is_delimiter = 0
    2   0.000525   0.000019   let cur_text = neocomplete#get_cur_text(1)
                            
    4              0.000009   for delimiter in ['/']
    2              0.000014     if stridx(cur_text, delimiter, len(cur_text) - len(delimiter)) >= 0
                                  let is_delimiter = 1
                                  break
                                endif
    2              0.000002   endfor
                            
    2              0.000004   return is_delimiter

FUNCTION  <SNR>95_get_omni_funcs()
Called 11 times
Total time:   0.003031
 Self time:   0.002019

count  total (s)   self (s)
   11              0.000020   let funcs = []
   33              0.000130   for ft in insert(split(a:filetype, '\.'), '_')
   22   0.000397   0.000262     let omnifuncs = neocomplete#util#convert2list( get(g:neocomplete#sources#omni#functions, ft, &l:omnifunc))
                            
   44              0.000058     for omnifunc in omnifuncs
   22   0.000290   0.000101       if neocomplete#helper#check_invalid_omnifunc(omnifunc)
                                    " omnifunc is irregal.
                                    continue
                                  endif
                            
   22              0.000105       if get(g:neocomplete#sources#omni#input_patterns, omnifunc, '') != ''
                                    let pattern = g:neocomplete#sources#omni#input_patterns[omnifunc]
                                  elseif get(g:neocomplete#sources#omni#input_patterns, ft, '') != ''
                                    let pattern = g:neocomplete#sources#omni#input_patterns[ft]
                                  else
   22              0.000027         let pattern = ''
   22              0.000013       endif
                            
   22              0.000031       if pattern == ''
   22              0.000027         continue
                                  endif
                            
                                  call add(funcs, [omnifunc, pattern])
                                endfor
   22              0.000026   endfor
                            
   11   0.000811   0.000123   return s:List.uniq(funcs)

FUNCTION  <SNR>17_SynSet()
Called 4 times
Total time:   0.026522
 Self time:   0.006766

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    4              0.000027   syn clear
    4              0.000024   if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
    4              0.000022   let s = expand("<amatch>")
    4              0.000010   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
    4              0.000007   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
    8              0.000063     for name in split(s, '\.')
    4   0.026200   0.006444       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    4              0.000037     endfor
    4              0.000004   endif

FUNCTION  neocomplete#helper#match_word()
Called 44 times
Total time:   0.003019
 Self time:   0.003019

count  total (s)   self (s)
   44              0.000206   let pattern = a:0 >= 1 ? a:1 : neocomplete#get_keyword_pattern_end()
                            
                              " Check wildcard.
   44              0.002349   let complete_pos = match(a:cur_text, pattern)
                            
   44              0.000207   let complete_str = (complete_pos >=0) ? a:cur_text[complete_pos :] : ''
                            
   44              0.000120   return [complete_pos, complete_str]

FUNCTION  <SNR>54_ALELintImpl()
Called 28 times
Total time:   0.370670
 Self time:   0.005665

count  total (s)   self (s)
   28   0.006280   0.000283     if ale#ShouldDoNothing(a:buffer)
                                    return
                                endif
                            
                                " Use the filetype from the buffer
   28   0.015953   0.001137     let l:linters = ale#linter#Get(getbufvar(a:buffer, '&filetype'))
   28              0.000074     let l:should_lint_file = 0
                            
                                " Check if we previously requested checking the file.
   28              0.000180     if has_key(s:should_lint_file_for_buffer, a:buffer)
   14              0.000052         unlet s:should_lint_file_for_buffer[a:buffer]
                                    " Lint files if they exist.
   14              0.000977         let l:should_lint_file = filereadable(expand('#' . a:buffer . ':p'))
   14              0.000022     endif
                            
   28   0.346723   0.002531     call ale#engine#RunLinters(a:buffer, l:linters, l:should_lint_file)

FUNCTION  <SNR>108_pgroup_open()
Called 8 times
Total time:   0.162801
 Self time:   0.007172

count  total (s)   self (s)
    8              0.000022   let proc = {}
                            
    8              0.000030   let cwd = getcwd()
    8              0.000010   try
    8   0.002448   0.000134     call vimproc#util#cd(a:statements[0].cwd)
                            
    8   0.144701   0.000347     let proc.current_proc = vimproc#plineopen{a:npipe}(a:statements[0].statement, a:is_pty)
    8              0.000041   finally
    8   0.004145   0.000149     call vimproc#util#cd(cwd)
    8              0.000029   endtry
                            
    8              0.000059   let proc.pid = proc.current_proc.pid
    8              0.000030   let proc.pid_list = proc.current_proc.pid_list
    8              0.000090   let proc.condition = a:statements[0].condition
    8              0.000044   let proc.statements = a:statements[1:]
    8   0.001864   0.000180   let proc.stdin = s:fdopen_pgroup(proc, proc.current_proc.stdin, 'vp_pgroup_close', 'read_pgroup', 'write_pgroup')
    8   0.001493   0.000091   let proc.stdout = s:fdopen_pgroup(proc, proc.current_proc.stdout, 'vp_pgroup_close', 'read_pgroup', 'write_pgroup')
    8   0.001580   0.000074   let proc.stderr = s:fdopen_pgroup(proc, proc.current_proc.stderr, 'vp_pgroup_close', 'read_pgroup', 'write_pgroup')
    8   0.000203   0.000055   let proc.kill = s:funcref('vp_pgroup_kill')
    8   0.002612   0.002387   let proc.waitpid = s:funcref('vp_pgroup_waitpid')
    8              0.000022   let proc.is_valid = 1
    8              0.002886   let proc.is_pty = 0
                              " echomsg expand('<sfile>')
                              " echomsg 'open:' string(map(copy(proc.current_proc.stdin.fd), 'v:val.fd'))
                              " echomsg 'open:' string(map(copy(proc.current_proc.stdout.fd), 'v:val.fd'))
                              " echomsg 'open:' string(map(copy(proc.current_proc.stderr.fd), 'v:val.fd'))
                            
    8              0.000035   return proc

FUNCTION  <SNR>123_RunJob()
Called 48 times
Total time:   0.245682
 Self time:   0.041671

count  total (s)   self (s)
   48              0.000143     let l:command = a:options.command
   48              0.000113     let l:buffer = a:options.buffer
   48              0.000102     let l:linter = a:options.linter
   48              0.000121     let l:output_stream = a:options.output_stream
   48              0.000130     let l:next_chain_index = a:options.next_chain_index
   48              0.000127     let l:read_buffer = a:options.read_buffer
   48              0.000590     let l:info = g:ale_buffer_info[l:buffer]
                            
   48              0.000260     if empty(l:command)
                                    return 0
                                endif
                            
   48   0.023673   0.002176     let [l:temporary_file, l:command] = ale#command#FormatCommand(l:buffer, l:command, l:read_buffer)
                            
   48   0.052095   0.002720     if s:CreateTemporaryFileForJob(l:buffer, l:temporary_file)
                                    " If a temporary filename has been formatted in to the command, then
                                    " we do not need to send the Vim buffer to the command.
   48              0.000284         let l:read_buffer = 0
   48              0.000095     endif
                            
                                " Add a newline to commands which need it.
                                " This is only used for Flow for now, and is not documented.
   48              0.000195     if l:linter.add_newline
                                    if has('win32')
                                        let l:command = l:command . '; echo.'
                                    else
                                        let l:command = l:command . '; echo'
                                    endif
                                endif
                            
   48   0.010089   0.000923     let l:command = ale#job#PrepareCommand(l:command)
   48              0.000651     let l:job_options = {   'mode': 'nl',   'exit_cb': function('s:HandleExit'),}
                            
   48              0.000155     if l:output_stream is# 'stderr'
                                    let l:job_options.err_cb = function('s:GatherOutput')
                                elseif l:output_stream is# 'both'
                                    let l:job_options.out_cb = function('s:GatherOutput')
                                    let l:job_options.err_cb = function('s:GatherOutput')
                                else
   48              0.000365         let l:job_options.out_cb = function('s:GatherOutput')
   48              0.000048     endif
                            
   48              0.000207     if get(g:, 'ale_run_synchronously') == 1
                                    " Find a unique Job value to use, which will be the same as the ID for
                                    " running commands synchronously. This is only for test code.
                                    let l:job_id = len(s:job_info_map) + 1
                            
                                    while has_key(s:job_info_map, l:job_id)
                                        let l:job_id += 1
                                    endwhile
                                else
   48   0.118691   0.011216         let l:job_id = ale#job#Start(l:command, l:job_options)
   48              0.000259     endif
                            
   48              0.000315     let l:status = 'failed'
                            
                                " Only proceed if the job is being run.
   48              0.000102     if l:job_id
                                    " Add the job to the list of jobs, so we can track them.
   48              0.003366         call add(l:info.job_list, l:job_id)
                            
   48              0.001043         if index(l:info.active_linter_list, l:linter.name) < 0
   48              0.000692             call add(l:info.active_linter_list, l:linter.name)
   48              0.000058         endif
                            
   48              0.000123         let l:status = 'started'
                                    " Store the ID for the job in the map to read back again.
   48              0.002685         let s:job_info_map[l:job_id] = {   'linter': l:linter,   'buffer': l:buffer,   'output': [],   'next_chain_index': l:next_chain_index,}
   48              0.000077     endif
                            
   48              0.000125     if g:ale_history_enabled
   48   0.018278   0.001780         call ale#history#Add(l:buffer, l:status, l:job_id, l:command)
   48              0.000248     endif
                            
   48              0.000385     if get(g:, 'ale_run_synchronously') == 1
                                    " Run a command synchronously if this test option is set.
                                    let s:job_info_map[l:job_id].output = systemlist(   type(l:command) == type([])   ?  join(l:command[0:1]) . ' ' . ale#Escape(l:command[2])   : l:command)
                            
                                    call l:job_options.exit_cb(l:job_id, v:shell_error)
                                endif
                            
   48              0.001197     return l:job_id != 0

FUNCTION  neocomplete#is_cache_disabled()
Called 65 times
Total time:   0.004570
 Self time:   0.002279

count  total (s)   self (s)
   65              0.000298   let ignore_filetypes = ['fuf', 'ku']
   65              0.000472   let bufnr = a:0 > 0 ? a:1 : bufnr('%')
   65   0.003647   0.001356   return !neocomplete#is_enabled() || index(ignore_filetypes, &filetype) >= 0 || neocomplete#get_current_neocomplete().lock || (g:neocomplete#lock_buffer_name_pattern != '' &&   bufname(bufnr) =~ g:neocomplete#lock_buffer_name_pattern)

FUNCTION  ale#linter#Get()
Called 63 times
Total time:   0.033263
 Self time:   0.022545

count  total (s)   self (s)
   63              0.000240     let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
  126              0.001041     for l:original_filetype in split(a:original_filetypes, '\.')
   63   0.005709   0.000767         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
   63   0.002533   0.000611         let l:linter_names = s:GetLinterNames(l:original_filetype)
   63   0.004497   0.000643         let l:all_linters = ale#linter#GetAll(l:filetype)
   63              0.000144         let l:filetype_linters = []
                            
   63              0.000303         if type(l:linter_names) == type('') && l:linter_names is# 'all'
    8              0.000022             let l:filetype_linters = l:all_linters
    8              0.000026         elseif type(l:linter_names) == type([])
                                        " Select only the linters we or the user has specified.
  440              0.000689             for l:linter in l:all_linters
  385              0.001875                 let l:name_list = [l:linter.name] + l:linter.aliases
                            
  660              0.001082                 for l:name in l:name_list
  385              0.001338                     if index(l:linter_names, l:name) >= 0
  110              0.000423                         call add(l:filetype_linters, l:linter)
  110              0.000136                         break
                                                endif
  275              0.000299                 endfor
  385              0.000482             endfor
   55              0.000117         endif
                            
   63              0.000291         call extend(l:possibly_duplicated_linters, l:filetype_linters)
   63              0.000125     endfor
                            
   63              0.000147     let l:name_list = []
   63              0.000144     let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
  189              0.000425     for l:linter in reverse(l:possibly_duplicated_linters)
  126              0.000426         if index(l:name_list, l:linter.name) < 0
  126              0.000467             call add(l:name_list, l:linter.name)
  126              0.000390             call add(l:combined_linters, l:linter)
  126              0.000098         endif
  126              0.000126     endfor
                            
   63              0.000188     return reverse(l:combined_linters)

FUNCTION  <SNR>108_SID_PREFIX()
Called 536 times
Total time:   0.016105
 Self time:   0.016105

count  total (s)   self (s)
  536              0.002868   if !exists('s:sid_prefix')
                                let s:sid_prefix = matchstr(expand('<sfile>'), '<SNR>\d\+_\zeSID_PREFIX$')
                              endif
  536              0.000793   return s:sid_prefix

FUNCTION  <SNR>85_make_cache_current_buffer()
Called 5 times
Total time:   0.027648
 Self time:   0.019998

count  total (s)   self (s)
    5              0.000020   let srcname = bufnr('%')
                            
                              " Make cache from current buffer.
    5   0.000471   0.000030   if !s:should_create_cache(srcname)
                                return
                              endif
                            
    5   0.000260   0.000054   if !s:exists_current_source()
                                call s:initialize_source(srcname)
                              endif
                            
    5              0.000013   let source = s:buffer_sources[srcname]
    5              0.000012   let keyword_pattern = source.keyword_pattern
    5              0.000008   if keyword_pattern == ''
                                return
                              endif
                            
    5              0.000007   let words = []
                            
    5              0.000005   lua << EOF
                            do
                              local words = vim.eval('words')
                              local dup = {}
                              local min_length = vim.eval('g:neocomplete#min_keyword_length')
                              for linenr = vim.eval('a:start'), vim.eval('a:end') do
                                local match = 0
                                while 1 do
                                  local match_str = vim.eval('matchstr(getline('..linenr..
                                  '), keyword_pattern, ' .. match .. ')')
                                  if match_str == '' then
                                    break
                                  end
                                  if dup[match_str] == nil
                                    and string.len(match_str) >= min_length then
                                    dup[match_str] = 1
                                    words:add(match_str)
                                  end
                            
                                  -- Next match.
                                  match = vim.eval('matchend(getline(' .. linenr ..
                                    '), keyword_pattern, ' .. match .. ')')
                                end
                              end
                            end
                            EOF
                            
    5   0.007293   0.000290   let source.words = neocomplete#util#uniq(source.words + words)

FUNCTION  neocomplete#util#uniq()
Called 5 times
Total time:   0.007003
 Self time:   0.000103

count  total (s)   self (s)
    5   0.006999   0.000099   return call(s:get_list().uniq, a:000)

FUNCTION  neocomplete#helper#get_force_omni_complete_pos()
Called 11 times
Total time:   0.000838
 Self time:   0.000492

count  total (s)   self (s)
   11   0.000307   0.000058   let filetype = neocomplete#get_context_filetype()
   11              0.000021   let omnifunc = &l:omnifunc
                            
   11   0.000228   0.000131   if neocomplete#helper#check_invalid_omnifunc(omnifunc)
                                return -1
                              endif
                            
   11              0.000013   let pattern = ''
                            
   11              0.000063   if has_key(g:neocomplete#force_omni_input_patterns, omnifunc)
                                let pattern = g:neocomplete#force_omni_input_patterns[omnifunc]
                              elseif filetype != '' && get(g:neocomplete#force_omni_input_patterns, filetype, '') != ''
                                let pattern = g:neocomplete#force_omni_input_patterns[filetype]
                              endif
                            
   11              0.000029   if pattern == ''
   11              0.000011     return -1
                              endif
                            
                              return match(a:cur_text, '\%(' . pattern . '\m\)$')

FUNCTION  neocomplete#sources#buffer#get_frequencies()
Called 2 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    2              0.000021   return get(get(s:buffer_sources, bufnr('%'), {}), 'frequencies', {})

FUNCTION  <SNR>128_CloseWindowIfNeeded()
Called 25 times
Total time:   0.002161
 Self time:   0.000456

count  total (s)   self (s)
   25   0.002091   0.000386     if ale#Var(a:buffer, 'keep_list_window_open') || !s:ShouldOpen(a:buffer)
   25              0.000039         return
                                endif
                            
                                try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
                                    if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                        endif
                                    else
                                        let l:win_id = s:BufWinId(a:buffer)
                            
                                        if g:ale_set_loclist && empty(getloclist(l:win_id))
                                            lclose
                                        endif
                                    endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
                                endtry

FUNCTION  neocomplete#helper#get_syn_name()
Called 11 times
Total time:   0.006484
 Self time:   0.006484

count  total (s)   self (s)
   11              0.006472   return len(getline('.')) < 200 ? synIDattr(synIDtrans(synID(line('.'), mode() ==# 'i' ?          col('.')-1 : col('.'), a:is_trans)), 'name') : ''

FUNCTION  vimproc#system_bg()
Called 6 times
Total time:   0.158950
 Self time:   0.001574

count  total (s)   self (s)
                              " Open pipe.
    6              0.000030   if type(a:cmdline) == type('')
                                if a:cmdline =~ '&\s*$'
                                  let cmdline = substitute(a:cmdline, '&\s*$', '', '')
                                  return vimproc#system_bg(cmdline)
                                endif
                            
                                let args = vimproc#parser#parse_statements(a:cmdline)
                                for arg in args
                                  let arg.statement = vimproc#parser#parse_pipe(arg.statement)
                                endfor
                              else
    6              0.000092     let args = [{ 'statement' : [ { 'fd' : { 'stdin' : '', 'stdout' : '', 'stderr' : '' }, 'args' : a:cmdline  }], 'condition' : 'always', 'cwd' : getcwd(), }]
    6              0.000006   endif
                            
    6   0.152280   0.001001   let subproc = vimproc#pgroup_open(args)
    6              0.000027   if empty(subproc)
                                " Not supported path error.
                                return ''
                              endif
                            
                              " Close handles.
    6   0.006227   0.000130   call s:close_all(subproc)
                            
    6              0.000059   let s:bg_processes[subproc.pid] = subproc.pid
                            
    6              0.000027   return ''

FUNCTION  <SNR>85_check_async_cache()
Called 3 times
Total time:   0.019871
 Self time:   0.001658

count  total (s)   self (s)
   60   0.000705   0.000138   for source in s:get_sources_list(a:context)
   57              0.000237     if !has_key(s:async_dictionary_list, source.path)
   26              0.000022       continue
                                endif
                            
                                " Load from cache.
   31   0.018117   0.000471     let [loaded, file_cache] = neocomplete#cache#get_cache_list( 'buffer_cache', s:async_dictionary_list[source.path])
   31              0.000040     if loaded
   16              0.000196       let source.words = file_cache
   16              0.000016     endif
                            
   31              0.000130     if empty(s:async_dictionary_list[source.path])
   13              0.000073       call remove(s:async_dictionary_list, source.path)
   13              0.000012     endif
   31              0.000033   endfor

FUNCTION  neocomplete#helper#check_invalid_omnifunc()
Called 33 times
Total time:   0.000286
 Self time:   0.000286

count  total (s)   self (s)
   33              0.000247   return a:omnifunc == '' || (a:omnifunc !~ '#' && !exists('*' . a:omnifunc))

FUNCTION  neocomplete#cache#check_cache()
Called 12 times
Total time:   0.000194
 Self time:   0.000194

count  total (s)   self (s)
   12              0.000042   if !has_key(a:async_cache_dictionary, a:key)
    9              0.000007     return
                              endif
                            
    3              0.000010   let cache_list = a:async_cache_dictionary[a:key]
                            
    3              0.000006   if !has_key(a:keyword_cache, a:key)
    2              0.000007     let a:keyword_cache[a:key] = []
    2              0.000001   endif
    3              0.000017   for cache in filter(copy(cache_list), 'filereadable(v:val.cachename)')
                                let a:keyword_cache[a:key] += neocomplete#cache#load_from_cache( a:cache_dir, cache.filename, a:is_string)
                              endfor
                            
    3              0.000008   call filter(cache_list, '!filereadable(v:val.cachename)')
                            
    3              0.000006   if empty(cache_list)
                                " Delete from dictionary.
    3              0.000028     call remove(a:async_cache_dictionary, a:key)
    3              0.000004     return
                              endif

FUNCTION  ale#events#QuitRecently()
Called 5 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    5              0.000028     let l:time = getbufvar(a:buffer, 'ale_quitting', 0)
                            
    5              0.000015     return l:time && ale#util#ClockMilliseconds() - l:time < 1000

FUNCTION  vimproc#system()
Called 2 times
Total time:   0.624654
 Self time:   0.000269

count  total (s)   self (s)
    2              0.000008   if type(a:cmdline) == type('')
                                if a:cmdline =~ '&\s*$'
                                  let cmdline = substitute(a:cmdline, '&\s*$', '', '')
                                  return vimproc#system_bg(cmdline)
                                endif
                            
                                let args = vimproc#parser#parse_statements(a:cmdline)
                                for arg in args
                                  let arg.statement = vimproc#parser#parse_pipe(arg.statement)
                                endfor
                              else
    2              0.000024     let args = [{ 'statement' : [ { 'fd' : { 'stdin' : '', 'stdout' : '', 'stderr' : '' }, 'args' : a:cmdline  }], 'condition' : 'always', 'cwd' : getcwd(), }]
    2              0.000002   endif
                            
    2              0.000005   let timeout = get(a:000, 1, 0)
    2              0.000005   let input = get(a:000, 0, '')
                            
    2   0.624571   0.000186   return s:system(args, 0, input, timeout, 0)

FUNCTION  <SNR>108_vp_pgroup_waitpid()
Called 2 times
Total time:   0.000187
 Self time:   0.000041

count  total (s)   self (s)
    2   0.000160   0.000014   call s:close_all(self)
                            
    2              0.000003   let self.is_valid = 0
                            
    2              0.000008   if !has_key(self, 'cond') || !has_key(self, 'status')
                                return s:waitpid(self.pid)
                              endif
                            
    2              0.000004   return [self.cond, self.status]

FUNCTION  <SNR>108_libcall()
Called 3585 times
Total time:   1.649938
 Self time:   1.217819

count  total (s)   self (s)
 3585   1.079192   0.923457   let stack_buf = libcall(g:vimproc#dll_path, a:func, s:encode_list(a:args))
 3585              0.025784   if empty(stack_buf)
   24              0.000043     return []
                              endif
 3561   0.152082   0.081228   let [result, err] = s:decode_list(stack_buf)
 3561              0.004106   if err
 3543              0.009535     let s:lasterr = result
 3543   0.301515   0.095985     let msg = vimproc#util#iconv(string(result), vimproc#util#systemencoding(), &encoding)
                            
 3542             17.458575     throw printf('vimproc: %s: %s', a:func, msg)
                              endif
   18              0.000075   return result

FUNCTION  vimproc#pgroup_open()
Called 8 times
Total time:   0.163358
 Self time:   0.000557

count  total (s)   self (s)
    8              0.000045   if type(a:statements) == type('')
                                let statements = vimproc#parser#parse_statements(a:statements)
                                for statement in statements
                                  let statement.statement = vimproc#parser#parse_pipe(statement.statement)
                                endfor
                              else
    8              0.000019     let statements = a:statements
    8              0.000006   endif
                            
    8              0.000030   let is_pty = get(a:000, 0, 0)
    8              0.000022   let npipe = get(a:000, 1, 3)
                            
    8   0.163032   0.000231   return s:pgroup_open(statements, is_pty && !vimproc#util#is_windows(), npipe)

FUNCTION  vimproc#plineopen3()
Called 8 times
Total time:   0.144354
 Self time:   0.005542

count  total (s)   self (s)
    8              0.000073   let commands = type(a:commands) == type('') ? vimproc#parser#parse_pipe(a:commands) : a:commands
    8              0.000029   let is_pty = get(a:000, 0, 0)
                            
    8   0.144177   0.005365   return s:plineopen(3, commands, is_pty)

FUNCTION  <SNR>91_make_cache()
Called 4 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    4              0.000038   if !has_key(s:dictionary_cache, a:filetype) && !has_key(s:async_dictionary_list, a:filetype)
                                call neocomplete#sources#dictionary#remake_cache(a:filetype)
                              endif

FUNCTION  <SNR>43_fzf_exec()
Called 5 times
Total time:   0.000520
 Self time:   0.000305

count  total (s)   self (s)
    5              0.000026   if !exists('s:exec')
                                if executable(s:fzf_go)
                                  let s:exec = s:fzf_go
                                elseif executable('fzf')
                                  let s:exec = 'fzf'
                                elseif s:is_win && !has('win32unix')
                                  call s:warn('fzf executable not found.')
                                  call s:warn('Download fzf binary for Windows from https://github.com/junegunn/fzf-bin/releases/')
                                  call s:warn('and place it as '.s:base_dir.'\bin\fzf.exe')
                                  throw 'fzf executable not found'
                                elseif !s:installed && executable(s:install) && input('fzf executable not found. Download binary? (y/n) ') =~? '^y'
                                  redraw
                                  echo
                                  call s:warn('Downloading fzf binary. Please wait ...')
                                  let s:installed = 1
                                  call system(s:install.' --bin')
                                  return s:fzf_exec()
                                else
                                  redraw
                                  throw 'fzf executable not found'
                                endif
                              endif
    5   0.000257   0.000042   return fzf#shellescape(s:exec)

FUNCTION  <SNR>21_buffer_commit()
Called 4 times
Total time:   0.000477
 Self time:   0.000105

count  total (s)   self (s)
    4   0.000461   0.000089   return matchstr(self.spec(),'^fugitive://.\{-\}//\zs\w*')

FUNCTION  <SNR>85_check_source()
Called 26 times
Total time:   0.215583
 Self time:   0.029510

count  total (s)   self (s)
                              " Check new buffer.
   26   0.211014   0.024941   call map(filter(range(1, bufnr('$')), " (v:val != bufnr('%') || neocomplete#has_vimproc()) && (!has_key(s:buffer_sources, v:val) && buflisted(v:val)   || (has_key(s:buffer_sources, v:val) &&     s:buffer_sources[v:val].cached_time         < getftime(s:buffer_sources[v:val].path))) && (!neocomplete#is_locked(v:val) ||    g:neocomplete#disable_auto_complete) && s:should_create_cache(v:val) "), 's:make_cache_file(v:val)')
                            
                              " Remove unlisted buffers.
   26              0.004370   call filter(s:buffer_sources, "v:key == bufnr('%') || buflisted(str2nr(v:key))")

FUNCTION  ale#highlight#RemoveHighlights()
Called 58 times
Total time:   0.000954
 Self time:   0.000954

count  total (s)   self (s)
   58              0.000289     for l:match in getmatches()
                                    if l:match.group =~# '^ALE'
                                        call matchdelete(l:match.id)
                                    endif
                                endfor

FUNCTION  <SNR>108_is_pseudo_device()
Called 16 times
Total time:   0.000270
 Self time:   0.000233

count  total (s)   self (s)
   16   0.000161   0.000124   if vimproc#util#is_windows() && (    a:filename ==# '/dev/stdin' || a:filename ==# '/dev/stdout' || a:filename ==# '/dev/stderr')
                                return 1
                              endif
                            
   16              0.000048   return a:filename == '' || a:filename ==# '/dev/clip' || a:filename ==# '/dev/quickfix'

FUNCTION  <SNR>22_abbrev()
Called 4 times
Total time:   0.000101
 Self time:   0.000101

count  total (s)   self (s)
    4              0.000041   if exists('g:endwise_abbreviations')
                                for word in split(get(b:, 'endwise_words', ''), ',')
                                  execute 'iabbrev <buffer><script>' word word.'<CR><SID>DiscretionaryEnd<Space><C-U><BS>'
                                endfor
                              endif

FUNCTION  neocomplete#get_keyword_pattern()
Called 48 times
Total time:   0.002290
 Self time:   0.001737

count  total (s)   self (s)
   48              0.000192   let filetype = a:0 != 0? a:1 : neocomplete#get_context_filetype()
   48              0.000061   if a:0 < 2
                                return neocomplete#helper#unite_patterns( g:neocomplete#keyword_patterns, filetype)
                              endif
                            
   48   0.000900   0.000347   let source = neocomplete#variables#get_source(a:2)
   48              0.000155   if !has_key(source, 'neocomplete__keyword_patterns')
                                let source.neocomplete__keyword_patterns = {}
                              endif
   48              0.000193   if !has_key(source.neocomplete__keyword_patterns, filetype)
                                let source.neocomplete__keyword_patterns[filetype] = neocomplete#helper#unite_patterns(         source.keyword_patterns, filetype)
                              endif
                            
   48              0.000112   return source.neocomplete__keyword_patterns[filetype]

FUNCTION  neocomplete#handler#_do_auto_complete()
Called 12 times
Total time:   0.002248
 Self time:   0.000759

count  total (s)   self (s)
   12   0.001654   0.000165   if s:check_in_do_auto_complete(a:event)
                                return
                              endif
                            
   12              0.000201   if g:neocomplete#auto_complete_delay > 0 && has('timers') && (!has('gui_macvim') || has('patch-8.0.95'))
   12              0.000034     if exists('s:timer')
    1              0.000010       call timer_stop(s:timer.id)
    1              0.000001     endif
   12              0.000021     if a:event !=# 'Manual'
   12              0.000067       let s:timer = { 'event': a:event }
   12              0.000145       let s:timer.id = timer_start( g:neocomplete#auto_complete_delay, function('s:complete_delay'))
   12              0.000015       return
                                endif
                              endif
                            
                              return s:do_auto_complete(a:event)

FUNCTION  vimproc#util#substitute_path_separator()
Called 8 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    8              0.000036   return s:is_windows ? substitute(a:path, '\\', '/', 'g') : a:path

FUNCTION  ale#job#PrepareCommand()
Called 48 times
Total time:   0.009166
 Self time:   0.008214

count  total (s)   self (s)
                                " The command will be executed in a subshell. This fixes a number of
                                " issues, including reading the PATH variables correctly, %PATHEXT%
                                " expansion on Windows, etc.
                                "
                                " NeoVim handles this issue automatically if the command is a String,
                                " but we'll do this explicitly, so we use thes same exact command for both
                                " versions.
   48   0.002398   0.001446     if ale#Has('win32')
                                    return 'cmd /c ' . a:command
                                endif
                            
   48              0.001345     if &shell =~? 'fish$'
                                    return ['/bin/sh', '-c', a:command]
                                endif
                            
   48              0.004509     return split(&shell) + split(&shellcmdflag) + [a:command]

FUNCTION  neocomplete#util#expand()
Called 53 times
Total time:   0.001305
 Self time:   0.001305

count  total (s)   self (s)
   53              0.001223   return expand(escape(a:path, '*?[]"={}'), 1)

FUNCTION  <SNR>43_has_any()
Called 10 times
Total time:   0.000416
 Self time:   0.000416

count  total (s)   self (s)
   45              0.000075   for key in a:keys
   35              0.000127     if has_key(a:dict, key)
                                  return 1
                                endif
   35              0.000042   endfor
   10              0.000013   return 0

FUNCTION  ale#util#FuzzyJSONDecode()
Called 21 times
Total time:   0.000128
 Self time:   0.000128

count  total (s)   self (s)
   21              0.000077     if empty(a:data)
   21              0.000032         return a:default
                                endif
                            
                                let l:str = type(a:data) == type('') ? a:data : join(a:data, '')
                            
                                try
                                    return json_decode(l:str)
                                catch /E474/
                                    return a:default
                                endtry

FUNCTION  <SNR>85_check_changed_buffer()
Called 5 times
Total time:   0.000121
 Self time:   0.000121

count  total (s)   self (s)
    5              0.000017   let source = s:buffer_sources[a:bufnr]
                            
    5              0.000017   let ft = getbufvar(a:bufnr, '&filetype')
    5              0.000007   if ft == ''
                                let ft = 'nothing'
                              endif
                            
    5              0.000021   let filename = fnamemodify(bufname(a:bufnr), ':t')
    5              0.000008   if filename == ''
                                let filename = '[No Name]'
                              endif
                            
    5              0.000018   return source.name != filename || source.filetype != ft

FUNCTION  neocomplete#complete#_get_results()
Called 11 times
Total time:   0.732480
 Self time:   0.001208

count  total (s)   self (s)
   11   0.000165   0.000094   call neocomplete#print_debug('start get_complete_sources')
                            
   11   0.000166   0.000055   let neocomplete = neocomplete#get_current_neocomplete()
   11              0.000054   let neocomplete.start_time = reltime()
                            
                              " Comment check.
   11   0.006651   0.000167   let neocomplete.within_comment = neocomplete#helper#get_syn_name(1) ==# 'Comment'
                            
   11   0.046583   0.000366   let complete_sources = call( 'neocomplete#complete#_set_results_pos', [a:cur_text] + a:000)
   11              0.000031   if empty(complete_sources)
    7   0.000092   0.000051     call neocomplete#print_debug('Skipped.')
    7              0.000013     return []
                              endif
                            
    4   0.000062   0.000015   if neocomplete#is_auto_complete()
    4   0.000136   0.000045     let complete_pos = neocomplete#complete#_get_complete_pos(complete_sources)
    4   0.000111   0.000029     call neocomplete#complete#_set_previous_position(a:cur_text, complete_pos)
    4              0.000030   endif
                            
    4   0.678246   0.000118   call neocomplete#complete#_set_results_words(complete_sources)
                            
    4              0.000068   return filter(copy(complete_sources), '!empty(v:val.neocomplete__context.candidates)')

FUNCTION  <SNR>85_initialize_source()
Called 2 times
Total time:   0.002672
 Self time:   0.000320

count  total (s)   self (s)
    2              0.000091   let path = fnamemodify(bufname(a:srcname), ':p')
    2              0.000012   let filename = fnamemodify(path, ':t')
    2              0.000005   if filename == ''
                                let filename = '[No Name]'
                                let path .= '/[No Name]'
                              endif
                            
    2              0.000012   let ft = getbufvar(a:srcname, '&filetype')
    2              0.000004   if ft == ''
                                let ft = 'nothing'
                              endif
                            
    2   0.000292   0.000086   let keyword_pattern = neocomplete#get_keyword_pattern(ft, s:source.name)
                            
    2   0.002235   0.000089   let s:buffer_sources[a:srcname] = { 'words' : [], 'frequencies' : {}, 'name' : filename, 'filetype' : ft, 'keyword_pattern' : keyword_pattern, 'cached_time' : 0, 'path' : path, 'cache_name' : neocomplete#cache#encode_name('buffer_cache', path),}

FUNCTION  <SNR>21_buffer()
Called 14 times
Total time:   0.000654
 Self time:   0.000552

count  total (s)   self (s)
   14              0.000126   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
   14              0.000239   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
   14   0.000242   0.000140   if buffer.getvar('git_dir') !=# ''
   14              0.000022     return buffer
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  neocomplete#util#substitute_path_separator()
Called 53 times
Total time:   0.002196
 Self time:   0.001064

count  total (s)   self (s)
   53   0.002129   0.000997   return call(s:get_prelude().substitute_path_separator, a:000)

FUNCTION  fugitive#buffer()
Called 6 times
Total time:   0.000381
 Self time:   0.000086

count  total (s)   self (s)
    6   0.000368   0.000073   return s:buffer(a:0 ? a:1 : '%')

FUNCTION  <SNR>108_read()
Called 8 times
Total time:   0.606687
 Self time:   0.000866

count  total (s)   self (s)
    8              0.000030   if self.__eof
                                let self.eof = 1
                                return ''
                              endif
                            
    8              0.000023   let maxsize = get(a:000, 0, -1)
    8              0.000022   let timeout = get(a:000, 1, s:read_timeout)
    8              0.000011   let buf = []
    8              0.000010   let eof = 0
                            
   10              0.000019   while maxsize != 0 && !eof
    8   0.606262   0.000441     let [out, eof] = self.f_read(maxsize, (timeout < s:read_timeout ? timeout : s:read_timeout))
    8              0.000016     if out ==# ''
    6              0.000017       let timeout -= s:read_timeout
    6              0.000008       if timeout <= 0
    6              0.000008         break
                                  endif
                                else
    2              0.000004       let buf += [out]
    2              0.000007       let maxsize -= len(out)
    2              0.000003       let timeout = 0
    2              0.000001     endif
    2              0.000002   endwhile
                            
    8              0.000019   let self.eof = eof
    8              0.000014   let self.__eof = eof
                            
    8              0.000028   return join(buf, '')

FUNCTION  <SNR>108_fdopen()
Called 24 times
Total time:   0.008439
 Self time:   0.002360

count  total (s)   self (s)
   24   0.008373   0.002294   return { 'fd' : a:fd, 'eof' : 0, '__eof' : 0, 'is_valid' : 1, 'buffer' : [], 'f_close' : s:funcref(a:f_close), 'f_read' : s:funcref(a:f_read), 'f_write' : s:funcref(a:f_write), 'close' : s:funcref('close'), 'read' : s:funcref('read'), 'write' : s:funcref('write'), 'read_line' : s:funcref('read_line'), 'read_lines' : s:funcref('read_lines'),}

FUNCTION  ale#highlight#UpdateHighlights()
Called 58 times
Total time:   0.004936
 Self time:   0.003982

count  total (s)   self (s)
   58              0.000512     let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled   ? get(b:, 'ale_highlight_items', [])   : []
                            
   58   0.001431   0.000477     call ale#highlight#RemoveHighlights()
                            
   58              0.000145     for l:item in l:item_list
                                    if l:item.type is# 'W'
                                        if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
                                        else
                                            let l:group = 'ALEWarning'
                                        endif
                                    elseif l:item.type is# 'I'
                                        let l:group = 'ALEInfo'
                                    elseif get(l:item, 'sub_type', '') is# 'style'
                                        let l:group = 'ALEStyleError'
                                    else
                                        let l:group = 'ALEError'
                                    endif
                            
                                    let l:line = l:item.lnum
                                    let l:col = l:item.col
                                    let l:end_line = get(l:item, 'end_lnum', l:line)
                                    let l:end_col = get(l:item, 'end_col', l:col)
                            
                                    " Set all of the positions, which are chunked into Lists which
                                    " are as large as will be accepted by matchaddpos.
                                    call map(   ale#highlight#CreatePositions(l:line, l:col, l:end_line, l:end_col),   'matchaddpos(l:group, v:val)')
                                endfor

FUNCTION  <SNR>21_repo_tree()
Called 6 times
Total time:   0.000410
 Self time:   0.000338

count  total (s)   self (s)
    6   0.000182   0.000144   if self.dir() =~# '/\.git$'
    6   0.000089   0.000055     let dir = self.dir()[0:-6]
    6              0.000023     if dir !~# '/'
                                  let dir .= '/'
                                endif
    6              0.000004   else
                                let dir = s:configured_tree(self.git_dir)
                              endif
    6              0.000010   if dir ==# ''
                                call s:throw('no work tree')
                              else
    6              0.000029     return join([dir]+a:000,'/')
                              endif

FUNCTION  <SNR>43_wrap_cmds()
Called 5 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    5              0.000009     return a:cmds

FUNCTION  <SNR>123_RemoveProblemsForDisabledLinters()
Called 32 times
Total time:   0.001393
 Self time:   0.001393

count  total (s)   self (s)
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
   32              0.000105     let l:name_map = {}
                            
   88              0.000173     for l:linter in a:linters
   56              0.000267         let l:name_map[l:linter.name] = 1
   56              0.000077     endfor
                            
   32              0.000435     call filter(   get(g:ale_buffer_info[a:buffer], 'loclist', []),   'get(l:name_map, get(v:val, ''linter_name''))',)

FUNCTION  ale#job#Start()
Called 48 times
Total time:   0.107475
 Self time:   0.092507

count  total (s)   self (s)
   48   0.001277   0.000448     call ale#job#ValidateArguments(a:command, a:options)
                            
   48              0.000355     let l:job_info = copy(a:options)
   48              0.000222     let l:job_options = {}
                            
   48              0.000233     if has('nvim')
                                    if has_key(a:options, 'out_cb')
                                        let l:job_options.on_stdout = function('s:NeoVimCallback')
                                        let l:job_info.out_cb_line = ''
                                    endif
                            
                                    if has_key(a:options, 'err_cb')
                                        let l:job_options.on_stderr = function('s:NeoVimCallback')
                                        let l:job_info.err_cb_line = ''
                                    endif
                            
                                    if has_key(a:options, 'exit_cb')
                                        let l:job_options.on_exit = function('s:NeoVimCallback')
                                    endif
                            
                                    let l:job_info.job = jobstart(a:command, l:job_options)
                                    let l:job_id = l:job_info.job
                                else
   48              0.000465         let l:job_options = {   'in_mode': l:job_info.mode,   'out_mode': l:job_info.mode,   'err_mode': l:job_info.mode,}
                            
   48              0.000228         if has_key(a:options, 'out_cb')
   48              0.000401             let l:job_options.out_cb = function('s:VimOutputCallback')
   48              0.000048         endif
                            
   48              0.000138         if has_key(a:options, 'err_cb')
                                        let l:job_options.err_cb = function('s:VimErrorCallback')
                                    endif
                            
   48              0.000127         if has_key(a:options, 'exit_cb')
                                        " Set a close callback to which simply calls job_status()
                                        " when the channel is closed, which can trigger the exit callback
                                        " earlier on.
   48              0.000338             let l:job_options.close_cb = function('s:VimCloseCallback')
   48              0.000381             let l:job_options.exit_cb = function('s:VimExitCallback')
   48              0.000050         endif
                            
                                    " Vim 8 will read the stdin from the file's buffer.
   48              0.075810         let l:job_info.job = job_start(a:command, l:job_options)
   48   0.019844   0.005705         let l:job_id = ale#job#ParseVim8ProcessID(string(l:job_info.job))
   48              0.000253     endif
                            
   48              0.000154     if l:job_id > 0
                                    " Store the job in the map for later only if we can get the ID.
   48              0.001168         let s:job_map[l:job_id] = l:job_info
   48              0.001662     endif
                            
   48              0.000440     return l:job_id

FUNCTION  <SNR>43_callback()
Called 5 times
Total time:   0.301282
 Self time:   0.000817

count  total (s)   self (s)
                              " Since anything can be done in the sink function, there is no telling that
                              " the change of the working directory was made by &autochdir setting.
                              "
                              " We use the following heuristic to determine whether to restore CWD:
                              " - Always restore the current directory when &autochdir is disabled.
                              "   FIXME This makes it impossible to change directory from inside the sink
                              "   function when &autochdir is not used.
                              " - In case of an error or an interrupt, a:lines will be empty.
                              "   And it will be an array of a single empty string when fzf was finished
                              "   without a match. In these cases, we presume that the change of the
                              "   directory is not expected and should be undone.
    5              0.000074   let popd = has_key(a:dict, 'prev_dir') && (!&autochdir || (empty(a:lines) || len(a:lines) == 1 && empty(a:lines[0])))
    5              0.000012   if popd
                                let w:fzf_dir = [a:dict.prev_dir, a:dict.dir]
                              endif
                            
    5              0.000006   try
    5              0.000021     if has_key(a:dict, 'sink')
                                  for line in a:lines
                                    if type(a:dict.sink) == 2
                                      call a:dict.sink(line)
                                    else
                                      execute a:dict.sink s:escape(line)
                                    endif
                                  endfor
                                endif
    5              0.000017     if has_key(a:dict, 'sink*')
    5   0.300756   0.000291       call a:dict['sink*'](a:lines)
    5              0.000017     endif
    5              0.000007   catch
                                if stridx(v:exception, ':E325:') < 0
                                  echoerr v:exception
                                endif
                              endtry
                            
                              " We may have opened a new window or tab
    5              0.000015   if popd
                                let w:fzf_dir = [a:dict.prev_dir, a:dict.dir]
                                call s:dopopd()
                              endif

FUNCTION  neocomplete#variables#get_sources()
Called 3 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    3              0.000012   if !exists('s:sources')
                                let s:sources = {}
                              endif
    3              0.000004   return s:sources

FUNCTION  <SNR>99_check_fallback()
Called 9 times
Total time:   0.000565
 Self time:   0.000481

count  total (s)   self (s)
    9              0.000020   let cur_text = a:cur_text
    9              0.000284   let complete_pos = match(cur_text, '\h\w*$')
    9   0.000141   0.000057   let neocomplete = neocomplete#get_current_neocomplete()
    9              0.000086   if empty(g:neocomplete#fallback_mappings) || len(matchstr(cur_text, '\h\w*$'))   < g:neocomplete#auto_completion_start_length || neocomplete.skip_next_complete || neocomplete#complete#_check_previous_position(      cur_text, complete_pos)
    9              0.000010     return
                              endif
                            
                              let key = ''
                              for i in range(0, len(g:neocomplete#fallback_mappings)-1)
                                let key .= '<C-r>=neocomplete#mappings#fallback(' . i . ')<CR>'
                              endfor
                              execute 'inoremap <silent> <Plug>(neocomplete_fallback)' key
                            
                              " Fallback
                              call s:complete_key("\<Plug>(neocomplete_fallback)")

FUNCTION  <SNR>78_get_list()
Called 5 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    5              0.000027   if !exists('s:List')
                                let s:List = neocomplete#util#get_vital().import('Data.List')
                              endif
    5              0.000005   return s:List

FUNCTION  neocomplete#complete#_set_results_words()
Called 4 times
Total time:   0.678128
 Self time:   0.012567

count  total (s)   self (s)
                              " Try source completion.
                            
                              " Save options.
    4              0.000017   let ignorecase_save = &ignorecase
    4              0.000020   let pos = winsaveview()
                            
    4              0.000004   try
   19              0.000035     for source in a:sources
   16   0.001605   0.000120       if neocomplete#complete_check()
    1              0.000001         return
                                  endif
                            
   15              0.000029       let context = source.neocomplete__context
                            
   15              0.000198       let &ignorecase = (g:neocomplete#enable_smart_case || g:neocomplete#enable_camel_case) ?   context.complete_str !~ '\u' : g:neocomplete#enable_ignore_case
                            
   15   0.001017   0.000115       if s:use_previous_result(source, context)
                                    " Use previous candidates.
                                    let context.candidates = deepcopy(context.prev_candidates)
                                  else
   15              0.000011         try
   15              0.000035           let winwidth = winwidth(0)
   15              0.000031           let type_string = type('')
   15   0.669055   0.009586           let context.candidates = filter(source.gather_candidates(context), 'len((type(v:val) == type_string) ?      v:val : v:val.word) < winwidth')
   15              0.000026         catch
                                      call neocomplete#print_error(v:throwpoint)
                                      call neocomplete#print_error(v:exception)
                                      call neocomplete#print_error( 'Source name is ' . source.name)
                                      call neocomplete#print_error( 'Error occurred in source''s gather_candidates()!')
                            
                                      return
                                    finally
   15              0.000112           if winsaveview() != pos
                                        call winrestview(pos)
                                      endif
   15              0.000028         endtry
                            
   15              0.000062         let context.prev_line = context.input
   15              0.000861         let context.prev_candidates = copy(context.candidates)
   15              0.000032         let context.prev_complete_pos = context.complete_pos
   15              0.000015       endif
                            
   15              0.000040       if !empty(context.candidates)
    4   0.000092   0.000051         let matchers = empty(source.neocomplete__matchers) ?   neocomplete#get_current_neocomplete().default_matchers : source.neocomplete__matchers
    4   0.003651   0.000069         let context.candidates = neocomplete#helper#call_filters( matchers, source, {})
    4              0.000003       endif
                            
   15   0.000210   0.000128       call neocomplete#print_debug(source.name)
   15              0.000025     endfor
    3              0.000002   finally
    4              0.000030     let &ignorecase = ignorecase_save
    4              0.000004   endtry

FUNCTION  neocomplete#get_context_filetype()
Called 40 times
Total time:   0.001854
 Self time:   0.000868

count  total (s)   self (s)
   40              0.000244   let neocomplete = exists('b:neocomplete') ? b:neocomplete : neocomplete#get_current_neocomplete()
                            
   40              0.000180   if a:0 != 0 || mode() !=# 'i' || neocomplete.context_filetype == ''
   17   0.001130   0.000144     call neocomplete#context_filetype#set()
   17              0.000054   endif
                            
   40              0.000067   return neocomplete.context_filetype

FUNCTION  <SNR>108_vp_pipes_close()
Called 24 times
Total time:   0.006608
 Self time:   0.000787

count  total (s)   self (s)
   48              0.000141   for fd in self.fd
   24              0.000027     try
   24   0.005974   0.000153       call fd.close()
   24              0.000044     catch /vimproc: vp_pipe_close: /
                                  " Ignore error.
                                endtry
   24              0.000108   endfor

FUNCTION  <SNR>99_complete_delay()
Called 11 times
Total time:   0.743810
 Self time:   0.000447

count  total (s)   self (s)
   11              0.000135   let event = s:timer.event
   11              0.000058   unlet! s:timer
   11   0.743553   0.000190   return s:do_auto_complete(event)

FUNCTION  <SNR>99_close_preview_window()
Called 11 times
Total time:   0.000109
 Self time:   0.000109

count  total (s)   self (s)
   11              0.000068   if g:neocomplete#enable_auto_close_preview && bufname('%') !=# '[Command Line]' && winnr('$') != 1 && !&l:previewwindow && !neocomplete#is_cache_disabled()
                                " Close preview window.
                                pclose!
                              endif

FUNCTION  <SNR>43_collect()
Called 5 times
Total time:   0.002155
 Self time:   0.002155

count  total (s)   self (s)
    5              0.000018   try
    5              0.000515     return filereadable(a:temps.result) ? readfile(a:temps.result) : []
                              finally
   15              0.000128     for tf in values(a:temps)
   10              0.001356       silent! call delete(tf)
   10              0.000035     endfor
    5              0.000010   endtry

FUNCTION  ale#history#SetExitCode()
Called 38 times
Total time:   0.003907
 Self time:   0.001132

count  total (s)   self (s)
   38   0.003568   0.000793     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
                                " If we find a match, then set the code and status.
   38              0.000122     let l:obj.exit_code = a:exit_code
   38              0.000123     let l:obj.status = 'finished'

FUNCTION  <SNR>43_dopopd()
Called 9 times
Total time:   0.000205
 Self time:   0.000205

count  total (s)   self (s)
    9              0.000150   if !exists('w:fzf_dir') || s:fzf_getcwd() != w:fzf_dir[1]
    9              0.000026     return
                              endif
                              execute 'lcd' s:escape(w:fzf_dir[0])
                              unlet w:fzf_dir

FUNCTION  neocomplete#cache#load_from_cache()
Called 16 times
Total time:   0.013594
 Self time:   0.008527

count  total (s)   self (s)
   16              0.000065   let is_string = get(a:000, 0, 0)
                            
   16              0.000021   try
                                " Note: For neocomplete.
   16              0.000026     let list = []
                            
   16              0.000021     if is_string
   16              0.000018       lua << EOF
                            do
                              local ret = vim.eval('list')
                              local list = {}
                              for line in io.lines(vim.eval(
                                  'neocomplete#cache#encode_name(a:cache_dir, a:filename)')) do
                                list = (loadstring) and loadstring('return ' .. line)()
                                                    or  load('return ' .. line)()
                              end
                            
                              for i = 1, #list do
                                ret:add(list[i])
                              end
                            end
                            EOF
   13              0.000036     else
                                  let list = eval(get(neocomplete#cache#readfile( a:cache_dir, a:filename), 0, '[]'))
                                endif
                            
   13              0.000127     if !empty(list) && is_string && type(list[0]) != type('')
                                  " Type check.
                                  throw 'Type error'
                                endif
                            
   13              0.000018     return list
                              catch
                                " echomsg string(v:errmsg)
                                " echomsg string(v:exception)
                            
                                " Delete old cache file.
    3   0.000810   0.000035     let cache_name = neocomplete#cache#encode_name(a:cache_dir, a:filename)
    3              0.000075     if filereadable(cache_name)
    3              0.000233       call delete(cache_name)
    3              0.000006     endif
                            
    3              0.000010     return []
                              endtry

FUNCTION  vimproc#util#is_windows()
Called 42 times
Total time:   0.000106
 Self time:   0.000106

count  total (s)   self (s)
   42              0.000079   return s:is_windows

FUNCTION  fugitive#detect()
Called 4 times
Total time:   0.012331
 Self time:   0.001492

count  total (s)   self (s)
    4              0.000050   if exists('b:git_dir') && (b:git_dir ==# '' || b:git_dir =~# '/$')
                                unlet b:git_dir
                              endif
    4              0.000012   if !exists('b:git_dir')
    2   0.001936   0.000040     let dir = fugitive#extract_git_dir(a:path)
    2              0.000005     if dir !=# ''
    2              0.000004       let b:git_dir = dir
    2   0.002356   0.000061       if empty(fugitive#buffer().path())
                                    silent! exe haslocaldir() ? 'lcd .' : 'cd .'
                                  endif
    2              0.000001     endif
    2              0.000002   endif
    4              0.000010   if exists('b:git_dir')
    4              0.000032     if exists('#User#FugitiveBoot')
                                  try
                                    let [save_mls, &modelines] = [&mls, 0]
                                    doautocmd User FugitiveBoot
                                  finally
                                    let &mls = save_mls
                                  endtry
                                endif
    4              0.000012     if !exists('g:fugitive_no_maps')
    4              0.000083       cnoremap <buffer> <expr> <C-R><C-G> fnameescape(<SID>recall())
    4              0.000052       nnoremap <buffer> <silent> y<C-G> :call setreg(v:register, <SID>recall())<CR>
    4              0.000012     endif
    4   0.000337   0.000057     let buffer = fugitive#buffer()
    4              0.000179     if expand('%:p') =~# '://'
                                  call buffer.setvar('&path', s:sub(buffer.getvar('&path'), '^\.%(,|$)', ''))
                                endif
    4   0.000084   0.000057     if stridx(buffer.getvar('&tags'), escape(b:git_dir, ', ')) == -1
    4              0.000132       if filereadable(b:git_dir.'/tags')
                                    call buffer.setvar('&tags', escape(b:git_dir.'/tags', ', ').','.buffer.getvar('&tags'))
                                  endif
    4              0.000093       if &filetype !=# '' && filereadable(b:git_dir.'/'.&filetype.'.tags')
                                    call buffer.setvar('&tags', escape(b:git_dir.'/'.&filetype.'.tags', ', ').','.buffer.getvar('&tags'))
                                  endif
    4              0.000004     endif
    4              0.000004     try
    4              0.000085       let [save_mls, &modelines] = [&mls, 0]
    4   0.002654   0.000067       call s:define_commands()
    4   0.003925   0.000171       doautocmd User Fugitive
    4              0.000007     finally
    4              0.000048       let &mls = save_mls
    4              0.000005     endtry
    4              0.000002   endif

FUNCTION  <SNR>99_make_cache_current_line()
Called 1 time
Total time:   0.009320
 Self time:   0.000039

count  total (s)   self (s)
    1   0.000013   0.000006   let neocomplete = neocomplete#get_current_neocomplete()
    1   0.000064   0.000006   if neocomplete#helper#is_enabled_source('buffer', neocomplete.context_filetype)
                                " Caching current cache line.
    1   0.007665   0.000006     call neocomplete#sources#buffer#make_cache_current_line()
    1              0.000001   endif
    1   0.000057   0.000005   if neocomplete#helper#is_enabled_source('member', neocomplete.context_filetype)
                                " Caching current cache line.
    1   0.001518   0.000013     call neocomplete#sources#member#make_cache_current_line()
    1              0.000001   endif

FUNCTION  necoghc#get_keyword_pos()
Called 11 times
Total time:   0.014103
 Self time:   0.001437

count  total (s)   self (s)
   11   0.006851   0.000187   if s:synname() =~# 'Comment'
                                return -1
                              endif
                            
   11   0.000782   0.000220   let [nothing, just_pos] = s:multiline_import(a:cur_text, 'pos')
   11              0.000016   if !nothing
                                return just_pos
                              endif
   11              0.000069   if a:cur_text =~# '^import\>'
    1              0.000004     if a:cur_text =~# '(.*,'
                                  return matchend(a:cur_text, '^.*,\s*')
                                endif
    1              0.000006     let parp = matchend(a:cur_text, '(\s*')
    1              0.000009     return parp > 0 ? parp : matchend(a:cur_text, '^import\s\+\(qualified\s\+\)\?')
                              else
   10   0.005575   0.000135     if s:synname() =~# 'Pragma' && a:cur_text =~# 'OPTIONS_GHC'
                                  let l:pattern = '-[[:alnum:]-]*$'
                                else
   10              0.000067       let l:pattern = '\%([[:alpha:]_''][[:alnum:]_''.]*\m\)$'
   10              0.000012     endif
   10              0.000337     let l:pos = match(a:cur_text, l:pattern)
   10              0.000022     if l:pos == -1
                                  " When the completion method is Vim (or YouCompleteMe?), a:cur_text is
                                  " '{-# '.
    6              0.000023       let l:pos = strlen(a:cur_text)
    6              0.000006     endif
   10              0.000015     return l:pos
                              endif

FUNCTION  <SNR>134_ghc_mod_caching_async()
Called 2 times
Total time:   0.005483
 Self time:   0.005483

count  total (s)   self (s)
    2              0.000007   let l:dict = {}
   32              0.000116   for l:line in a:lines
   30              0.000940     let l:m = matchlist(l:line, '^\(class\|data\|type\|newtype\) \(\S\+\)\( .\+\)\?$')
   30              0.000135     if !empty(l:m)
                                  let l:dict[l:m[2]] = {'kind': l:m[1], 'args': l:m[3][1 :]}
                                else
   30              0.000546       let l:m = matchlist(l:line, '^\(\S\+\) :: \(.\+\)$')
   30              0.000108       if !empty(l:m)
                                    let l:dict[l:m[1]] = {'type': l:m[2]}
                                  elseif l:line =~# '^\S\+$'
                                    let l:dict[l:line] = {}
                                  elseif l:line != ""
                                    " Maybe some error occurred.
   30              0.000544         echohl ErrorMsg
   30              0.001751         echomsg printf('neco-ghc: %s', l:line)
   30              0.000144         echohl None
   30              0.000048       endif
   30              0.000047     endif
   30              0.000030   endfor
    2              0.000038   let s:browse_cache[a:mod] = l:dict

FUNCTION  ale#history#RememberOutput()
Called 38 times
Total time:   0.002431
 Self time:   0.000610

count  total (s)   self (s)
   38   0.002169   0.000348     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
   38              0.000135     let l:obj.output = a:output

FUNCTION  ale#engine#ManageDirectory()
Called 48 times
Total time:   0.011294
 Self time:   0.011294

count  total (s)   self (s)
   48              0.011243     call add(g:ale_buffer_info[a:buffer].temporary_directory_list, a:directory)

FUNCTION  ale#Var()
Called 1214 times
Total time:   0.050113
 Self time:   0.050113

count  total (s)   self (s)
 1214              0.007940     let l:nr = str2nr(a:buffer)
 1214              0.005214     let l:full_name = 'ale_' . a:variable_name
                            
 1214              0.004810     if bufexists(l:nr)
 1214              0.005525         let l:vars = getbufvar(l:nr, '')
 1214              0.003834     elseif has_key(g:, 'ale_fix_buffer_data')
                                    let l:vars = get(g:ale_fix_buffer_data, l:nr, {'vars': {}}).vars
                                else
                                    let l:vars = {}
                                endif
                            
 1214              0.007854     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  ale#ShouldDoNothing()
Called 368 times
Total time:   0.095026
 Self time:   0.046232

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
  368              0.002943     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
                                endif
                            
                                " Do nothing for blacklisted files
  368              0.005769     if index(g:ale_filetype_blacklist, getbufvar(a:buffer, '&filetype')) >= 0
                                    return 1
                                endif
                            
                                " Do nothing if running from command mode
  368              0.002605     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
                                endif
                            
  368              0.003831     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
  368              0.001057     if l:filename is# '.'
                                    return 1
                                endif
                            
                                " Do nothing if running in the sandbox
  368   0.011406   0.003139     if ale#util#InSandbox()
                                    return 1
                                endif
                            
                                " Do nothing if ALE is disabled.
  368   0.020537   0.003449     if !ale#Var(a:buffer, 'enabled')
                                    return 1
                                endif
                            
                                " Do nothing if the file is too large.
  368   0.026707   0.003268     if ale#FileTooLarge()
                                    return 1
                                endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
  368              0.005536     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
                                endif
                            
  368              0.000442     return 0

FUNCTION  neocomplete#cache#encode_name()
Called 40 times
Total time:   0.015466
 Self time:   0.001159

count  total (s)   self (s)
                              " Check cache directory.
   40   0.005753   0.000429   let cache_dir = neocomplete#get_data_directory() . '/' . a:cache_dir
   40   0.009625   0.000642   return s:Cache.getfilename(cache_dir, a:filename)

FUNCTION  <SNR>111_which()
Called 8 times
Total time:   0.000732
 Self time:   0.000732

count  total (s)   self (s)
    8              0.000147   let maxcount = (a:0 >= 2 && type(a:2) == type(0)) ? a:2 : 1
    8              0.000041   if maxcount == 1 && exists('*exepath')
    8              0.000435     let full = exepath(a:command)
    8              0.000036     if s:is_windows && (full =~? '\.lnk$') && (getftype(full) ==# 'file')
                                  return resolve(full)
                                endif
    8              0.000011     return full
                              endif
                              let pathlist = a:command =~# s:path_sep_pattern ? [''] :              !a:0                  ? split($PATH, s:path_separator) :              type(a:1) == type([]) ? copy(a:1) :                                      split(a:1, s:path_separator)
                              let pathlist = vimproc#util#uniq(pathlist)
                            
                              let pathext = s:path_extensions()
                              if index(pathext, '.' . tolower(fnamemodify(a:command, ':e'))) != -1
                                let pathext = ['']
                              endif
                            
                              let dirsep = s:separator()
                              let cmdlist = []
                              for dir in pathlist
                                let head = dir ==# '' ? '' : dir . dirsep
                                for ext in pathext
                                  let full = fnamemodify(head . a:command . ext, ':p')
                                  if s:is_windows && (full =~? '\.lnk$') && (getftype(full) ==# 'file')
                                    let full = resolve(full)
                                  endif
                            
                                  if executable(full)
                                    if s:is_case_tolerant()
                                      let full = glob(substitute(               vimproc#util#substitute_path_separator( toupper(full)), '\u:\@!', '[\0\L\0]', 'g'), 1)
                                    endif
                                    if full != ''
                                      let cmdlist += [full]
                                      if maxcount > 0 && len(cmdlist) >= maxcount
                                        return join(cmdlist, "\n")
                                      endif
                                    endif
                                  endif
                                endfor
                              endfor
                            
                              return join(cmdlist, "\n")

FUNCTION  neocomplete#is_eskk_enabled()
Called 11 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
   11              0.000056   return exists('*eskk#is_enabled') && eskk#is_enabled()

FUNCTION  <SNR>54_ALEQueueImpl()
Called 35 times
Total time:   0.180506
 Self time:   0.004067

count  total (s)   self (s)
   35              0.000152     if a:linting_flag isnot# '' && a:linting_flag isnot# 'lint_file'
                                    throw "linting_flag must be either '' or 'lint_file'"
                                endif
                            
   35              0.000135     if type(a:buffer) != type(0)
                                    throw 'buffer_number must be a Number'
                                endif
                            
   35   0.007080   0.000254     if ale#ShouldDoNothing(a:buffer)
                                    return
                                endif
                            
                                " Remember that we want to check files for this buffer.
                                " We will remember this until we finally run the linters, via any event.
   35              0.000083     if a:linting_flag is# 'lint_file'
   16              0.000090         let s:should_lint_file_for_buffer[a:buffer] = 1
   16              0.000016     endif
                            
   35              0.000065     if s:lint_timer != -1
   21              0.000078         call timer_stop(s:lint_timer)
   21              0.000056         let s:lint_timer = -1
   21              0.000014     endif
                            
   35   0.019208   0.000761     let l:linters = ale#linter#Get(getbufvar(a:buffer, '&filetype'))
                            
                                " Don't set up buffer data and so on if there are no linters to run.
   35              0.000102     if empty(l:linters)
                                    " If we have some previous buffer data, then stop any jobs currently
                                    " running and clear everything.
                                    if has_key(g:ale_buffer_info, a:buffer)
                                        call ale#engine#RunLinters(a:buffer, [], 1)
                                    endif
                            
                                    return
                                endif
                            
   35              0.000058     if a:delay > 0
   21              0.000111         let s:queued_buffer_number = a:buffer
   21              0.000152         let s:lint_timer = timer_start(a:delay, function('ale#Lint'))
   21              0.000021     else
   14   0.151546   0.000380         call ale#Lint(-1, a:buffer)
   14              0.000106     endif

FUNCTION  <SNR>108_encode_size()
Called 3739 times
Total time:   0.053771
 Self time:   0.053771

count  total (s)   self (s)
                              " Set each bit7 to 1 in order to avoid NUL byte.
 3739              0.048230   return printf("%c%c%c%c%c", ((a:n / 0x10000000) % 0x80) + 0x80, ((a:n / 0x200000) % 0x80) + 0x80, ((a:n / 0x4000) % 0x80) + 0x80, ((a:n / 0x80) % 0x80) + 0x80, ( a:n % 0x80) + 0x80)

FUNCTION  neocomplete#sources#member#make_cache_current_line()
Called 5 times
Total time:   0.007590
 Self time:   0.000113

count  total (s)   self (s)
    5   0.000071   0.000025   if !neocomplete#is_enabled()
                                call neocomplete#initialize()
                              endif
                            
                              " Make cache from current line.
    5   0.007496   0.000065   return s:make_cache_current_buffer(line('.')-1, line('.')+1)

FUNCTION  <SNR>21_buffer_type()
Called 4 times
Total time:   0.001962
 Self time:   0.000955

count  total (s)   self (s)
    4   0.000055   0.000037   if self.getvar('fugitive_type') != ''
                                let type = self.getvar('fugitive_type')
                              elseif fnamemodify(self.spec(),':p') =~# '.\git/refs/\|\.git/\w*HEAD$'
                                let type = 'head'
                              elseif self.getline(1) =~ '^tree \x\{40\}$' && self.getline(2) == ''
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \w\{4\} \x\{40\}\>\t'
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \x\{40\}\> \d\t'
                                let type = 'index'
                              elseif isdirectory(self.spec())
                                let type = 'directory'
                              elseif self.spec() == ''
                                let type = 'null'
                              else
    4              0.000008     let type = 'file'
    4              0.000006   endif
    4              0.000005   if a:0
    4              0.000070     return !empty(filter(copy(a:000),'v:val ==# type'))
                              else
                                return type
                              endif

FUNCTION  neocomplete#handler#_on_moved_i()
Called 10 times
Total time:   0.000505
 Self time:   0.000297

count  total (s)   self (s)
   10   0.000177   0.000069   let neocomplete = neocomplete#get_current_neocomplete()
   10              0.000037   if neocomplete.linenr != line('.')
                                call neocomplete#helper#clear_result()
                              endif
   10              0.000035   let neocomplete.linenr = line('.')
                            
   10   0.000197   0.000097   call s:close_preview_window()

FUNCTION  <SNR>108_vp_pgroup_close()
Called 24 times
Total time:   0.006477
 Self time:   0.000172

count  total (s)   self (s)
   24   0.006445   0.000140   call self.fd.close()

FUNCTION  neocomplete#handler#_on_text_changed()
Called 9 times
Total time:   0.000720
 Self time:   0.000239

count  total (s)   self (s)
    9   0.000495   0.000054   if neocomplete#is_cache_disabled()
                                return
                              endif
                            
    9              0.000030   if getline('.') == ''
                                call s:make_cache_current_line()
                              endif
                            
    9   0.000102   0.000062   if !neocomplete#util#is_text_changed()
                                call s:indent_current_line()
                              endif

FUNCTION  <SNR>136_wrap()
Called 5 times
Total time:   0.002602
 Self time:   0.000298

count  total (s)   self (s)
                              " fzf#wrap does not append --expect if sink or sink* is found
    5              0.000020   let opts = copy(a:opts)
    5              0.000021   let options = get(opts, 'options', '')
    5              0.000018   if type(options) == s:TYPE.list
                                let options = join(options)
                              endif
    5              0.000043   if options !~ '--expect' && has_key(opts, 'sink*')
                                let Sink = remove(opts, 'sink*')
                                let wrapped = fzf#wrap(a:name, opts, a:bang)
                                let wrapped['sink*'] = Sink
                              else
    5   0.002407   0.000103     let wrapped = fzf#wrap(a:name, opts, a:bang)
    5              0.000004   endif
    5              0.000008   return wrapped

FUNCTION  ale#sign#ParseSigns()
Called 46 times
Total time:   0.005738
 Self time:   0.005738

count  total (s)   self (s)
                                " Matches output like :
                                " line=4  id=1  name=ALEErrorSign
                                " =1  id=1000001  =ALEErrorSign
                                " =1  =1000001  =ALEWarningSign
                                " lnea=12 id=1000001 nombre=ALEWarningSign
                                " riga=1 id=1000001, nome=ALEWarningSign
   46              0.000143     let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=(ALE[a-zA-Z]+Sign)'
   46              0.000112     let l:result = []
   46              0.000148     let l:is_dummy_sign_set = 0
                            
   92              0.000212     for l:line in a:line_list
   46              0.002675         let l:match = matchlist(l:line, l:pattern)
                            
   46              0.000219         if len(l:match) > 0
                                        if l:match[3] is# 'ALEDummySign'
                                            let l:is_dummy_sign_set = 1
                                        else
                                            call add(l:result, [   str2nr(l:match[1]),   str2nr(l:match[2]),   l:match[3],])
                                        endif
                                    endif
   46              0.000147     endfor
                            
   46              0.000150     return [l:is_dummy_sign_set, l:result]

FUNCTION  ale#path#FindNearestFile()
Called 4 times
Total time:   0.001506
 Self time:   0.001506

count  total (s)   self (s)
    4              0.000170     let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
                            
    4              0.001245     let l:relative_path = findfile(a:filename, l:buffer_filename . ';')
                            
    4              0.000022     if !empty(l:relative_path)
                                    return fnamemodify(l:relative_path, ':p')
                                endif
                            
    4              0.000005     return ''

FUNCTION  ale#engine#RemoveManagedFiles()
Called 25 times
Total time:   0.019441
 Self time:   0.019093

count  total (s)   self (s)
   25              0.000175     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
                                " We can't delete anything in a sandbox, so wait until we escape from
                                " it to delete temporary files and directories.
   25   0.000520   0.000172     if ale#util#InSandbox()
                                    return
                                endif
                            
                                " Delete files with a call akin to a plan `rm` command.
   25              0.000098     if has_key(l:info, 'temporary_file_list')
   25              0.000085         for l:filename in l:info.temporary_file_list
                                        call delete(l:filename)
                                    endfor
                            
   25              0.000124         let l:info.temporary_file_list = []
   25              0.000023     endif
                            
                                " Delete directories like `rm -rf`.
                                " Directories are handled differently from files, so paths that are
                                " intended to be single files can be set up for automatic deletion without
                                " accidentally deleting entire directories.
   25              0.000161     if has_key(l:info, 'temporary_directory_list')
   73              0.000297         for l:directory in l:info.temporary_directory_list
   48              0.016736             call delete(l:directory, 'rf')
   48              0.000237         endfor
                            
   25              0.000257         let l:info.temporary_directory_list = []
   25              0.000033     endif

FUNCTION  <SNR>108_waitpid()
Called 2 times
Total time:   0.000529
 Self time:   0.000101

count  total (s)   self (s)
    2              0.000008   let nohang = a:0 ? a:1 : 0
    2              0.000002   try
    2              0.000002     while 1
    2   0.000438   0.000018       let [cond, status] = s:libcall('vp_waitpid', [a:pid])
                                  " echomsg string([a:pid, cond, status])
    2              0.000004       if cond !=# 'run' || nohang
    2              0.000002         break
                                  endif
                                endwhile
                            
    2              0.000002     if cond ==# 'run'
                                  " Add process list.
                                  let s:bg_processes[a:pid] = a:pid
                                  let [cond, status] = ['exit', '0']
                                elseif vimproc#util#is_windows()
                                  call s:libcall('vp_close_handle', [a:pid])
                                endif
                            
    2              0.000006     let s:last_status = str2nr(status)
    2              0.000002   catch /No child processes/
                                let [cond, status] = ['exit', '0']
                                let s:last_status = 0
                              catch
                                let [cond, status] = ['error', '0']
                                let s:last_status = -1
                              endtry
                            
    2              0.000006   return [cond, str2nr(status)]

FUNCTION  hindent#Hindent()
Called 1 time
Total time:   0.071453
 Self time:   0.003313

count  total (s)   self (s)
    1              0.000013     let l:winview = winsaveview()
                            
    1              0.000052     if !executable("hindent")
                                    echomsg "Hindent not found in $PATH, did you installed it? (stack install hindent)"
                                    return
                                endif
                            
                                " Write the buffer to hindent, rather than having it use the
                                " file on disk, because that file might not have been created yet!
    1   0.036161   0.001789     silent! w !hindent > /dev/null 2>&1
                            
    1              0.000072     if v:shell_error
                                    echohl WarningMsg
                                    echo "Hindent: Parsing error\n"
                                    echohl None
                                else
    1              0.000004         let l:indent_opt = ""
    1              0.000013         if exists("g:hindent_indent_size")
                                      let l:indent_opt = " --indent-size " . g:hindent_indent_size
                                    endif
                            
    1              0.000007         let l:line_length_opt = ""
    1              0.000008         if exists("g:hindent_line_length")
                                      let l:line_length_opt = " --line-length " . g:hindent_line_length
                                    endif
                            
    1              0.000009         silent! exe "undojoin"
    1   0.034993   0.001225         silent! exe "keepjumps %!hindent" . l:indent_opt . l:line_length_opt
    1              0.000008     endif
                            
    1              0.000040     call winrestview(l:winview)

FUNCTION  <SNR>108_decode_size()
Called 52 times
Total time:   0.001586
 Self time:   0.001586

count  total (s)   self (s)
   52              0.001441   return (char2nr(a:str[a:off + 0]) - 0x80) * 0x10000000 + (char2nr(a:str[a:off + 1]) - 0x80) * 0x200000 + (char2nr(a:str[a:off + 2]) - 0x80) * 0x4000 + (char2nr(a:str[a:off + 3]) - 0x80) * 0x80 + (char2nr(a:str[a:off + 4]) - 0x80)

FUNCTION  fzf#vim#files()
Called 5 times
Total time:  15.320768
 Self time:   0.000993

count  total (s)   self (s)
    5              0.000049   let args = {}
    5              0.000048   if !empty(a:dir)
                                if !isdirectory(expand(a:dir))
                                  return s:warn('Invalid directory')
                                endif
                                let slash = (s:is_win && !&shellslash) ? '\\' : '/'
                                let dir = substitute(a:dir, '[/\\]*$', slash, '')
                                let args.dir = dir
                              else
    5   0.000798   0.000119     let dir = s:shortpath()
    5              0.000007   endif
                            
    5              0.000082   let args.options = ['-m', '--prompt', strwidth(dir) < &columns / 2 - 20 ? dir : '> ']
    5   0.001283   0.000130   call s:merge_opts(args, get(g:, 'fzf_files_options', []))
    5  15.318280   0.000337   return s:fzf('files', args, a:000)

FUNCTION  <SNR>43_fzf_fnamemodify()
Called 5 times
Total time:   0.000429
 Self time:   0.000090

count  total (s)   self (s)
    5   0.000417   0.000078   return s:fzf_call('fnamemodify', a:fname, a:mods)

FUNCTION  nerdtree#checkForBrowse()
Called 12 times
Total time:   0.000268
 Self time:   0.000268

count  total (s)   self (s)
   12              0.000221     if !isdirectory(a:dir)
   12              0.000023         return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  ale#util#Writefile()
Called 48 times
Total time:   0.019444
 Self time:   0.019444

count  total (s)   self (s)
   48              0.001768     let l:corrected_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'   ? map(copy(a:lines), 'v:val . "\r"')   : a:lines
                            
   48              0.017521     call writefile(l:corrected_lines, a:filename) " no-custom-checks

FUNCTION  <SNR>123_InvokeChain()
Called 48 times
Total time:   0.283125
 Self time:   0.019902

count  total (s)   self (s)
   48   0.018746   0.001205     let l:options = ale#engine#ProcessChain(a:buffer, a:linter, a:chain_index, a:input)
                            
   48   0.263972   0.018290     return s:RunJob(l:options)

FUNCTION  <SNR>108_plineopen()
Called 8 times
Total time:   0.138812
 Self time:   0.018267

count  total (s)   self (s)
    8              0.000076   let pid_list = []
    8              0.000025   let stdin_list = []
    8              0.000016   let stdout_list = []
    8              0.000013   let stderr_list = []
    8              0.000014   let npipe = a:npipe
                            
                              " Open input.
    8              0.000079   let hstdin = (empty(a:commands) || a:commands[0].fd.stdin == '')? 0 : vimproc#fopen(a:commands[0].fd.stdin, 'r').fd
                            
    8   0.000110   0.000083   let is_pty = !vimproc#util#is_windows() && a:is_pty
                            
    8              0.000012   let cnt = 0
   16              0.000427   for command in a:commands
    8              0.000029     if is_pty && command.fd.stdout == '' && cnt == 0 && len(a:commands) != 1
                                  " pty_open() use pipe.
                                  let hstdout = 1
                                else
    8              0.000063       if command.fd.stdout =~ '^>'
                                    let mode = 'a'
                                    let command.fd.stdout = command.fd.stdout[1:]
                                  else
    8              0.000014         let mode = 'w'
    8              0.000021       endif
                            
    8   0.000409   0.000256       let hstdout = s:is_pseudo_device(command.fd.stdout) ? 0 : vimproc#fopen(command.fd.stdout, mode).fd
    8              0.000008     endif
                            
    8              0.000029     if is_pty && command.fd.stderr == '' && cnt == 0 && len(a:commands) != 1
                                  " pty_open() use pipe.
                                  let hstderr = 1
                                else
    8              0.000037       if command.fd.stderr =~ '^>'
                                    let mode = 'a'
                                    let command.fd.stderr = command.fd.stderr[1:]
                                  else
    8              0.000012         let mode = 'w'
    8              0.000007       endif
    8   0.000201   0.000084       let hstderr = s:is_pseudo_device(command.fd.stderr) ? 0 : vimproc#fopen(command.fd.stderr, mode).fd
    8              0.000005     endif
                            
    8              0.000015     if command.fd.stderr ==# '/dev/stdout'
                                  let npipe = 2
                                endif
                            
    8   0.009184   0.000170     let args = s:convert_args(command.args)
    8              0.000055     let command_name = fnamemodify(args[0], ':t:r')
    8              0.000129     let pty_npipe = cnt == 0 && hstdin == 0 && hstdout == 0 && hstderr == 0 && exists('g:vimproc#popen2_commands') && get(g:vimproc#popen2_commands, command_name, 0) != 0 ? 2 : npipe
                            
    8              0.000027     if is_pty && (cnt == 0 || cnt == len(a:commands)-1)
                                  " Use pty_open().
                                  let pipe = s:vp_pty_open(pty_npipe, s:get_winwidth(), winheight(0), hstdin, hstdout, hstderr, args)
                                else
    8   0.087610   0.002878       let pipe = s:vp_pipe_open(pty_npipe, hstdin, hstdout, hstderr, args)
    8              0.000042     endif
                            
    8              0.000044     if len(pipe) == 4
    8              0.000081       let [pid, fd_stdin, fd_stdout, fd_stderr] = pipe
    8   0.004440   0.000554       let stderr = s:fdopen(fd_stderr, 'vp_pipe_close', 'vp_pipe_read', 'vp_pipe_write')
    8              0.000012     else
                                  let [pid, fd_stdin, fd_stdout] = pipe
                                  let stderr = s:closed_fdopen( 'vp_pipe_close', 'vp_pipe_read', 'vp_pipe_write')
                                endif
                            
    8              0.000086     call add(pid_list, pid)
    8   0.002525   0.000093     let stdin = s:fdopen(fd_stdin, 'vp_pipe_close', 'vp_pipe_read', 'vp_pipe_write')
    8              0.000052     let stdin.is_pty = is_pty && (cnt == 0 || cnt == len(a:commands)-1) && hstdin == 0
    8              0.000165     call add(stdin_list, stdin)
    8   0.002211   0.000090     let stdout = s:fdopen(fd_stdout, 'vp_pipe_close', 'vp_pipe_read', 'vp_pipe_write')
    8              0.000048     let stdout.is_pty = is_pty && (cnt == 0 || cnt == len(a:commands)-1) && hstdout == 0
    8              0.003770     call add(stdout_list, stdout)
    8              0.000053     let stderr.is_pty = is_pty && (cnt == 0 || cnt == len(a:commands)-1) && hstderr == 0
    8              0.000053     call add(stderr_list, stderr)
                            
    8              0.000229     let hstdin = stdout_list[-1].fd
    8              0.000040     let cnt += 1
    8              0.000365   endfor
                            
    8              0.000060   let proc = {}
    8              0.000027   let proc.pid_list = pid_list
    8              0.000037   let proc.pid = pid_list[-1]
    8   0.013900   0.000319   let proc.stdin = s:fdopen_pipes(stdin_list, 'vp_pipes_close', 'read_pipes', 'write_pipes')
    8   0.001724   0.000093   let proc.stdout = s:fdopen_pipes(stdout_list, 'vp_pipes_close', 'read_pipes', 'write_pipes')
    8   0.001992   0.000080   let proc.stderr = s:fdopen_pipes(stderr_list, 'vp_pipes_close', 'read_pipes', 'write_pipes')
    8   0.000211   0.000062   let proc.get_winsize = s:funcref('vp_get_winsize')
    8   0.000261   0.000109   let proc.set_winsize = s:funcref('vp_set_winsize')
    8   0.000409   0.000049   let proc.kill = s:funcref('vp_kill')
    8   0.000187   0.000047   let proc.waitpid = s:funcref('vp_waitpid')
    8   0.000185   0.000047   let proc.checkpid = s:funcref('vp_checkpid')
    8              0.000017   let proc.is_valid = 1
    8              0.000025   let proc.is_pty = is_pty
    8              0.000012   if a:is_pty
                                let proc.ttyname = ''
                                let proc.width = winwidth(0) - &l:numberwidth - &l:foldcolumn
                                let proc.height = winheight(0)
                                let proc.get_winsize = s:funcref('vp_get_winsize')
                                let proc.set_winsize = s:funcref('vp_set_winsize')
                              endif
                            
    8              0.000242   return proc

FUNCTION  neocomplete#util#is_sudo()
Called 12 times
Total time:   0.000101
 Self time:   0.000101

count  total (s)   self (s)
   12              0.000095   return $SUDO_USER != '' && $USER !=# $SUDO_USER && $HOME !=# expand('~'.$USER) && $HOME ==# expand('~'.$SUDO_USER)

FUNCTION  <SNR>136_fzf()
Called 5 times
Total time:  15.317943
 Self time:   0.001239

count  total (s)   self (s)
    5              0.000027   let [extra, bang] = [{}, 0]
    5              0.000016   if len(a:extra) <= 1
    5              0.000018     let first = get(a:extra, 0, 0)
    5              0.000016     if type(first) == s:TYPE.dict
                                  let extra = first
                                else
    5              0.000010       let bang = first
    5              0.000004     endif
    5              0.000012   elseif len(a:extra) == 2
                                let [extra, bang] = a:extra
                              else
                                throw 'invalid number of arguments'
                              endif
                            
    5              0.000030   let eopts  = has_key(extra, 'options') ? remove(extra, 'options') : ''
    5              0.000032   let merged = extend(copy(a:opts), extra)
    5   0.000076   0.000047   call s:merge_opts(merged, eopts)
    5  15.317592   0.000917   return fzf#run(s:wrap(a:name, merged, bang))

FUNCTION  ale#job#ParseVim8ProcessID()
Called 144 times
Total time:   0.019741
 Self time:   0.019741

count  total (s)   self (s)
  144              0.019273     return matchstr(a:job_string, '\d\+') + 0

FUNCTION  ale#cursor#EchoCursorWarning()
Called 275 times
Total time:   0.161541
 Self time:   0.013477

count  total (s)   self (s)
  275   0.160304   0.012240     return ale#CallWithCooldown('dont_echo_until', function('s:EchoImpl'), [])

FUNCTION  vimproc#analyze_shebang()
Called 8 times
Total time:   0.000445
 Self time:   0.000445

count  total (s)   self (s)
    8              0.000390   if !filereadable(a:filename) || getfsize(a:filename) > 100000 || (vimproc#util#is_windows() && '.'.fnamemodify(a:filename, ':e') !~?   '^'.substitute($PATHEXT, ';', '$\\|^', 'g').'$')
                                  " Maybe a binary file.
    8              0.000026     return [a:filename]
                              endif
                            
                              let lines = readfile(a:filename, '', 1)
                              if empty(lines) || lines[0] !~ '^#!.\+'
                                " Shebang not found.
                                return [a:filename]
                              endif
                            
                              " Get shebang line.
                              let shebang = split(matchstr(lines[0], '^#!\zs.\+'))
                            
                              " Convert command name.
                              if vimproc#util#is_windows() && shebang[0] =~ '^/'
                                let shebang[0] = vimproc#get_command_name( fnamemodify(shebang[0], ':t'))
                              endif
                            
                              return shebang + [a:filename]

FUNCTION  neocomplete#print_debug()
Called 52 times
Total time:   0.000368
 Self time:   0.000368

count  total (s)   self (s)
   52              0.000132   if g:neocomplete#enable_debug
                                echomsg string(a:expr)
                              endif

FUNCTION  neocomplete#is_enabled()
Called 83 times
Total time:   0.001100
 Self time:   0.000805

count  total (s)   self (s)
   83   0.000982   0.000687   return neocomplete#init#is_enabled()

FUNCTION  ale#list#SetLists()
Called 46 times
Total time:   0.007873
 Self time:   0.001766

count  total (s)   self (s)
   46              0.000391     if get(g:, 'ale_set_lists_synchronously') == 1|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Update lists immediately if running a test synchronously, or if the
                                    " buffer was saved.
                                    "
                                    " The lists need to be updated immediately when saving a buffer so
                                    " that we can reliably close window automatically, if so configured.
   13   0.005117   0.000121         call s:SetListsImpl(-1, a:buffer, a:loclist)
   13              0.000012     else
   33   0.001842   0.000731         call ale#util#StartPartialTimer(   0,   function('s:SetListsImpl'),   [a:buffer, a:loclist],)
   33              0.000030     endif

FUNCTION  neocomplete#get_data_directory()
Called 53 times
Total time:   0.007580
 Self time:   0.004079

count  total (s)   self (s)
   53              0.001059   let g:neocomplete#data_directory = get(g:, 'neocomplete#data_directory',  ($XDG_CACHE_HOME != '' ?   $XDG_CACHE_HOME . '/neocomplete' : '~/.cache/neocomplete'))
   53   0.004476   0.000975   let directory = neocomplete#util#substitute_path_separator( neocomplete#util#expand(g:neocomplete#data_directory))
   53              0.000624   if !isdirectory(directory)
                                if neocomplete#util#is_sudo()
                                  call neocomplete#print_error(printf( 'Cannot create Directory "%s" in sudo session.', directory))
                                else
                                  call mkdir(directory, 'p')
                                endif
                              endif
                            
   53              0.000087   return directory

FUNCTION  ale#job#Stop()
Called 48 times
Total time:   0.013247
 Self time:   0.011590

count  total (s)   self (s)
   48              0.000348     if !has_key(s:job_map, a:job_id)
                                    return
                                endif
                            
   48              0.000329     if has('nvim')
                                    " FIXME: NeoVim kills jobs on a timer, but will not kill any processes
                                    " which are child processes on Unix. Some work needs to be done to
                                    " kill child processes to stop long-running processes like pylint.
                                    call jobstop(a:job_id)
                                else
   48              0.002003         let l:job = s:job_map[a:job_id].job
                            
                                    " We must close the channel for reading the buffer if it is open
                                    " when stopping a job. Otherwise, we will get errors in the status line.
   48              0.000328         if ch_status(job_getchannel(l:job)) is# 'open'
   10              0.000109             call ch_close_in(job_getchannel(l:job))
   10              0.000018         endif
                            
                                    " Ask nicely for the job to stop.
   48              0.006493         call job_stop(l:job)
                            
   48   0.002193   0.000536         if ale#job#IsRunning(l:job)
                                        " Set a 100ms delay for killing the job with SIGKILL.
                                        let s:job_kill_timers[timer_start(100, function('s:KillHandler'))] = l:job
                                    endif
   48              0.000040     endif

FUNCTION  vimproc#util#iconv()
Called 3657 times
Total time:   0.198322
 Self time:   0.146260

count  total (s)   self (s)
 3657   0.099539   0.047477   if !vimproc#util#has_iconv() || a:expr == '' || a:from == '' || a:to == '' || a:from ==# a:to
                                return a:expr
                              endif
                            
 3657              0.073949   let result = iconv(a:expr, a:from, a:to)
 3657              0.011384   return result != '' ? result : a:expr

FUNCTION  ale#engine#InitBufferInfo()
Called 32 times
Total time:   0.000689
 Self time:   0.000689

count  total (s)   self (s)
   32              0.000193     if !has_key(g:ale_buffer_info, a:buffer)
                                    " job_list will hold the list of job IDs
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
                                    " temporary_file_list holds temporary files to be cleaned up
                                    " temporary_directory_list holds temporary directories to be cleaned up
    4              0.000040         let g:ale_buffer_info[a:buffer] = {   'job_list': [],   'active_linter_list': [],   'loclist': [],   'temporary_file_list': [],   'temporary_directory_list': [],}
                            
    4              0.000007         return 1
                                endif
                            
   28              0.000035     return 0

FUNCTION  <SNR>43_fzf_expand()
Called 10 times
Total time:   0.000457
 Self time:   0.000161

count  total (s)   self (s)
   10   0.000433   0.000137   return s:fzf_call('expand', a:fmt, 1)

FUNCTION  ale_linters#haskell#hlint#Handle()
Called 21 times
Total time:   0.001772
 Self time:   0.001644

count  total (s)   self (s)
   21              0.000055     let l:output = []
                            
   21   0.000395   0.000267     for l:error in ale#util#FuzzyJSONDecode(a:lines, [])
                                    if l:error.severity is# 'Error'
                                        let l:type = 'E'
                                    elseif l:error.severity is# 'Suggestion'
                                        let l:type = 'I'
                                    else
                                        let l:type = 'W'
                                    endif
                            
                                    call add(l:output, {   'lnum': str2nr(l:error.startLine),   'col': str2nr(l:error.startColumn),   'end_lnum': str2nr(l:error.endLine),   'end_col': str2nr(l:error.endColumn),   'text': l:error.severity . ': ' . l:error.hint . '. Found: ' . l:error.from . ' Why not: ' . l:error.to,   'type': l:type,})
                                endfor
                            
   21              0.000041     return l:output

FUNCTION  <SNR>134_ghc_mod()
Called 2 times
Total time:   0.626657
 Self time:   0.001669

count  total (s)   self (s)
    2              0.000015   let l:cmd = s:ghc_mod_path + a:cmd
    2   0.626119   0.001131   let l:lines = split(s:system(l:cmd), '\r\n\|[\r\n]')
                            
    2              0.000119   let l:warnings = filter(copy(l:lines), "v:val =~# '^Warning:'")
    2              0.000094   let l:lines = filter(copy(l:lines), "v:val !~# '^Warning:'")
    2              0.000120   let l:errors = filter(copy(l:lines), "v:val =~# '^Dummy:0:0:Error:'")
                            
    2              0.000008   if empty(l:lines) && get(g:, 'necoghc_debug', 0)
                                echohl ErrorMsg
                                echomsg printf('neco-ghc: ghc-mod returned nothing: %s', join(l:cmd, ' '))
                                echohl None
                              endif
                            
    2              0.000004   if !empty(l:errors)
                                if get(g:, 'necoghc_debug', 0)
                                  echohl ErrorMsg
                                  echomsg printf('neco-ghc: ghc-mod returned error messages: %s', join(l:cmd, ' '))
                                  for l:line in l:errors
                                    echomsg l:line
                                  endfor
                                  echohl None
                                endif
                                return []
                              endif
                            
    2              0.000004   if !empty(l:warnings)
                                if get(g:, 'necoghc_debug', 0)
                                  echohl ErrorMsg
                                  echomsg printf('neco-ghc: ghc-mod returned warning messages: %s', join(l:cmd, ' '))
                                  for l:line in l:warnings
                                    echomsg l:line
                                  endfor
                                  echohl None
                                endif
                                return []
                              endif
                            
    2              0.000006   return l:lines

FUNCTION  neocomplete#init#_current_neocomplete()
Called 2 times
Total time:   0.000703
 Self time:   0.000245

count  total (s)   self (s)
    2   0.000700   0.000242   let b:neocomplete = { 'context' : {      'input' : '',      'complete_pos' : -1,      'complete_str' : '',      'candidates' : [], }, 'lock' : 0, 'skip_next_complete' : 0, 'filetype' : '', 'context_filetype' : '', 'context_filetypes' : [], 'completion_length' : -1, 'foldinfo' : [], 'skipped' : 0, 'event' : '', 'cur_text' : '', 'old_cur_text' : '', 'old_linenr' : line('.'), 'old_complete_pos' : -1, 'old_char' : '', 'complete_str' : '', 'complete_pos' : -1, 'candidates' : [], 'complete_sources' : [], 'manual_sources' : [], 'start_time' : reltime(), 'linenr' : 0, 'completeopt' : &completeopt, 'sources' : [], 'sources_filetype' : '', 'within_comment' : 0, 'is_auto_complete' : 0, 'indent_text' : '', 'detected_foldmethod' : 0, 'default_matchers' : neocomplete#init#_filters(  (g:neocomplete#enable_fuzzy_completion ?   ['matcher_fuzzy'] : ['matcher_head'])  + ['matcher_length']),}

FUNCTION  neocomplete#get_cur_text()
Called 17 times
Total time:   0.003512
 Self time:   0.000353

count  total (s)   self (s)
                              " Return cached text.
   17   0.000257   0.000110   let neocomplete = neocomplete#get_current_neocomplete()
   17   0.003220   0.000208   return (a:0 == 0 && mode() ==# 'i' &&  neocomplete.cur_text != '') ? neocomplete.cur_text : neocomplete#helper#get_cur_text()

FUNCTION  273()
Called 2 times
Total time:   0.002350
 Self time:   0.000720

count  total (s)   self (s)
    2   0.000555   0.000103   let next = matchstr(getline('.')[ len(neocomplete#helper#get_cur_text()) :], '^\S\+')
    2              0.000021   if next == ''
                                return a:context.candidates
                              endif
                            
    2              0.000017   let candidates = []
   11              0.000021   for candidate in a:context.candidates
    9   0.001172   0.000156     let overlapped_len = neocomplete#filters#converter_remove_overlap#length(candidate.word, next)
                            
    9              0.000013     if overlapped_len > 0
                                  if !has_key(candidate, 'abbr')
                                    let candidate.abbr = candidate.word
                                  endif
                            
                                  let candidate.word = candidate.word[: -overlapped_len-1]
                                  call add(candidates, candidate)
                                elseif !neocomplete#is_auto_complete()
    9              0.000041       call add(candidates, candidate)
    9              0.000010     endif
    9              0.000011   endfor
                            
    2              0.000004   if empty(candidates)
                                return a:context.candidates
                              endif
                            
    2              0.000023   let candidates = filter(candidates, 'v:val.word !=# a:context.complete_str')
                            
    2              0.000003   return candidates

FUNCTION  ale#FileTooLarge()
Called 368 times
Total time:   0.023439
 Self time:   0.008303

count  total (s)   self (s)
  368   0.020696   0.005560     let l:max = ale#Var(bufnr(''), 'maximum_file_size')
                            
  368              0.002077     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  necoghc#get_complete_words()
Called 4 times
Total time:   0.636667
 Self time:   0.001437

count  total (s)   self (s)
    4              0.000018   let l:col = col('.')-1
                              " HACK: When invoked from Vim, col('.') returns the position returned by the
                              " omnifunc in findstart phase.
    4              0.000008   if a:cur_keyword_pos == l:col
                                " Invoked from Vim.
                                let l:cur_keyword_str = a:cur_keyword_str
                                let l:need_prefix_filter = 0
                                let l:need_filter = 1
                              elseif empty(a:cur_keyword_str)
                                " Invoked from YouCompleteMe.
                                " It doesn't give correct a:base and doesn't filter out prefix.
                                let l:cur_keyword_str = getline('.')[a:cur_keyword_pos : l:col-1]
                                let l:need_prefix_filter = 1
                                let l:need_filter = 1
                              else
                                " Invoked from neocomplcache.vim or neocomplete.vim.
                                " They give correct a:base and doesn't need filter.
    4              0.000010     let l:cur_keyword_str = a:cur_keyword_str
    4              0.000006     let l:need_prefix_filter = 0
    4              0.000005     let l:need_filter = 0
    4              0.000003   endif
                            
    4              0.000008   let l:list = []
    4              0.000016   let l:line = getline('.')[: a:cur_keyword_pos]
                            
    4              0.000010   if (&filetype ==# 'lhaskell')
                                let l:line = substitute(l:line, '^>[ \t]*', '', 'g')
                              endif
                            
    4   0.000224   0.000033   let [nothing, just_list] = s:multiline_import(l:line, 'list')
    4              0.000004   if !nothing
                                return s:filter(just_list, l:cur_keyword_str, 0, l:need_filter)
                              endif
                            
    4              0.000044   if l:line =~# '^import\>.\{-}('
                                let l:mod = matchstr(l:line, '^import\s\+\%(qualified\s\+\)\?\zs[^ (]\+')
                                for [l:sym, l:dict] in items(necoghc#browse(l:mod))
                                  call add(l:list, { 'word': l:sym, 'menu': s:to_desc(l:mod . '.' . l:sym, l:dict)})
                                endfor
                                return s:filter(l:list, l:cur_keyword_str, 0, l:need_filter)
                              endif
                            
    4   0.002489   0.000044   let l:syn = s:synname()
    4              0.000039   if l:line =~# '^import\>'
    1              0.000004     if !exists('s:list_cache')
                                  let s:list_cache = s:ghc_mod(['list'])
                                endif
   15              0.000022     for l:mod in s:list_cache
   14              0.000049       call add(l:list, { 'word': l:mod, 'menu': l:mod })
   14              0.000018     endfor
    1              0.000002   elseif l:syn =~# 'Pragma'
                                if l:line[:a:cur_keyword_pos-1] =~# '{-#\s\+$'
                                  for l:p in s:pragmas
                                    call add(l:list, { 'word': l:p, 'menu': l:p })
                                  endfor
                                elseif l:line =~# 'LANGUAGE'
                                  if !exists('s:lang_cache')
                                    let s:lang_cache = s:ghc_mod(['lang'])
                                  endif
                                  for l:lang in s:lang_cache
                                    call add(l:list, { 'word': l:lang, 'menu': l:lang })
                                    call add(l:list, { 'word': 'No' . l:lang, 'menu': 'No' . l:lang })
                                  endfor
                                elseif l:line =~# 'OPTIONS_GHC'
                                  if !exists('s:flag_cache')
                                    let s:flag_cache = s:ghc_mod(['flag'])
                                  endif
                                  for l:flag in s:flag_cache
                                    call add(l:list, { 'word': l:flag, 'menu': l:flag })
                                  endfor
                                endif
                              elseif l:cur_keyword_str =~# '\.'
                                " qualified
                                let l:idx = matchend(l:cur_keyword_str, '^.*\.')
                                let l:qual = l:cur_keyword_str[0 : l:idx-2]
                                let l:name = l:cur_keyword_str[l:idx :]
                            
                                for [l:mod, l:opts] in items(necoghc#get_modules())
                                  if l:mod == l:qual || (has_key(l:opts, 'as') && l:opts.as == l:qual)
                                    for [l:sym, l:dict] in items(necoghc#browse(l:mod))
                                      call add(l:list, { 'word': l:qual . '.' . l:sym, 'menu': s:to_desc(l:mod . '.' . l:sym, l:dict) })
                                    endfor
                                  endif
                                endfor
                              else
   18   0.000183   0.000145     for [l:mod, l:opts] in items(necoghc#get_modules())
   15              0.000031       if !l:opts.qualified || l:opts.export
    9   0.632653   0.000114         for [l:sym, l:dict] in items(necoghc#browse(l:mod))
                                      call add(l:list, { 'word': l:sym, 'menu': s:to_desc(l:mod . '.' . l:sym, l:dict) })
                                    endfor
    9              0.000005       endif
   15              0.000026     endfor
    3              0.000002   endif
                            
    4   0.000070   0.000053   return s:filter(l:list, l:cur_keyword_str, l:need_prefix_filter,         l:need_filter)

FUNCTION  <SNR>21_buffer_repo()
Called 12 times
Total time:   0.000576
 Self time:   0.000150

count  total (s)   self (s)
   12   0.000575   0.000149   return s:repo(self.getvar('git_dir'))

FUNCTION  necoghc#browse()
Called 9 times
Total time:   0.632539
 Self time:   0.000212

count  total (s)   self (s)
    9              0.000034   if !has_key(s:browse_cache, a:mod)
    2   0.632394   0.000067     call s:ghc_mod_caching_browse(a:mod)
    2              0.000006   endif
    9              0.000050   return get(s:browse_cache, a:mod, {})

FUNCTION  ale#Has()
Called 48 times
Total time:   0.000952
 Self time:   0.000952

count  total (s)   self (s)
   48              0.000768     return get(g:ale_has_override, a:feature, has(a:feature))

FUNCTION  <SNR>73_EchoImpl()
Called 275 times
Total time:   0.117610
 Self time:   0.021531

count  total (s)   self (s)
                                " Only echo the warnings in normal mode, otherwise we will get problems.
  275              0.002213     if mode() isnot# 'n'
    8              0.000013         return
                                endif
                            
  267   0.079083   0.004129     if ale#ShouldDoNothing(bufnr(''))
                                    return
                                endif
                            
  267   0.025219   0.004094     let [l:info, l:loc] = s:FindItemAtCursor()
                            
  267              0.001100     if !empty(l:loc)
                                    let l:msg = s:GetMessage(l:loc.linter_name, l:loc.type, l:loc.text)
                                    call ale#cursor#TruncatedEcho(l:msg)
                                    let l:info.echoed = 1
                                elseif get(l:info, 'echoed')
                                    " We'll only clear the echoed message when moving off errors once,
                                    " so we don't continually clear the echo line.
                                    echo
                                    let l:info.echoed = 0
                                endif

FUNCTION  neocomplete#filters#fuzzy_escape()
Called 4 times
Total time:   0.000273
 Self time:   0.000182

count  total (s)   self (s)
                              " Escape string for lua regexp.
    4   0.000222   0.000131   let string = substitute(neocomplete#filters#escape(a:string), '\w', '\0.*', 'g')
    4              0.000010   if g:neocomplete#enable_camel_case && string =~ '\u'
                                let string = substitute(string, '\l', '[\0\u\0\E]', 'g')
                              endif
    4              0.000006   return string

FUNCTION  <SNR>134_synname()
Called 25 times
Total time:   0.014549
 Self time:   0.014549

count  total (s)   self (s)
   25              0.000037   if a:0 == 2
                                let l:line = a:000[0]
                                let l:col = a:000[1]
                              else
   25              0.000083     let l:line = line('.')
   25              0.000167     let l:col = col('.') - (mode() ==# 'i' ? 1 : 0)
   25              0.000017   endif
   25              0.014085   return synIDattr(synID(l:line, l:col, 0), 'name')

FUNCTION  <SNR>85_get_sources_list()
Called 6 times
Total time:   0.001237
 Self time:   0.001237

count  total (s)   self (s)
    6              0.000013   let filetypes_dict = {}
   18              0.000026   for filetype in a:context.filetypes
   12              0.000026     let filetypes_dict[filetype] = 1
   12              0.000008   endfor
                            
    6              0.001136   return values(filter(copy(s:buffer_sources), "has_key(filetypes_dict, v:val.filetype) || has_key(filetypes_dict, '_') || bufnr('%') == v:key || (bufname('%') ==# '[Command Line]' && bufwinnr('#') == v:key)"))

FUNCTION  neocomplete#util#has_vimproc()
Called 26 times
Total time:   0.000801
 Self time:   0.000801

count  total (s)   self (s)
                              " Initialize.
   26              0.000177   if !exists('g:neocomplete#use_vimproc')
                                " Check vimproc.
                                try
                                  call vimproc#version()
                                  let exists_vimproc = 1
                                catch
                                  let exists_vimproc = 0
                                endtry
                            
                                let g:neocomplete#use_vimproc = exists_vimproc
                              endif
                            
   26              0.000053   return g:neocomplete#use_vimproc

FUNCTION  ale#engine#IsCheckingBuffer()
Called 124 times
Total time:   0.002253
 Self time:   0.002253

count  total (s)   self (s)
  124              0.000867     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
  124              0.000708     return !empty(get(l:info, 'active_linter_list', []))

FUNCTION  neocomplete#get_keyword_pattern_end()
Called 44 times
Total time:   0.002454
 Self time:   0.000508

count  total (s)   self (s)
   44   0.002434   0.000488   return '\%('.call('neocomplete#get_keyword_pattern', a:000).'\m\)$'

FUNCTION  neocomplete#is_locked()
Called 35 times
Total time:   0.003577
 Self time:   0.000573

count  total (s)   self (s)
   35   0.003513   0.000509   return neocomplete#is_cache_disabled() || &paste || (&t_Co != '' && &t_Co < 8) || g:neocomplete#disable_auto_complete

FUNCTION  <SNR>43_present()
Called 5 times
Total time:   0.000125
 Self time:   0.000125

count  total (s)   self (s)
   10              0.000024   for key in a:000
    5              0.000031     if !empty(get(a:dict, key, ''))
                                  return 1
                                endif
    5              0.000007   endfor
    5              0.000007   return 0

FUNCTION  neocomplete#context_filetype#set()
Called 28 times
Total time:   0.001528
 Self time:   0.001269

count  total (s)   self (s)
   28   0.000470   0.000211   let neocomplete = neocomplete#get_current_neocomplete()
   28              0.000168   let context_filetype = s:exists_context_filetype ? context_filetype#get_filetype() : &filetype
   28              0.000057   if context_filetype == ''
                                let context_filetype = 'nothing'
                              endif
   28              0.000091   let neocomplete.context_filetype = context_filetype
   28              0.000536   let neocomplete.context_filetypes = s:exists_context_filetype ?  context_filetype#get_filetypes(context_filetype) :  [context_filetype] + split(context_filetype, '\.')
                            
   28              0.000059   return neocomplete.context_filetype

FUNCTION  ale_linters#yaml#yamllint#GetExecutable()
Called 4 times
Total time:   0.000204
 Self time:   0.000054

count  total (s)   self (s)
    4   0.000199   0.000049     return ale#Var(a:buffer, 'yaml_yamllint_executable')

FUNCTION  ale#command#FormatCommand()
Called 48 times
Total time:   0.021497
 Self time:   0.010695

count  total (s)   self (s)
   48              0.000173     let l:temporary_file = ''
   48              0.000752     let l:command = a:command
                            
                                " First replace all uses of %%, used for literal percent characters,
                                " with an ugly string.
   48              0.001602     let l:command = substitute(l:command, '%%', '<<PERCENTS>>', 'g')
                            
                                " Replace all %s occurrences in the string with the name of the current
                                " file.
   48              0.000264     if l:command =~# '%s'
   24              0.001667         let l:filename = fnamemodify(bufname(a:buffer), ':p')
   24   0.003681   0.000758         let l:command = substitute(l:command, '%s', '\=ale#Escape(l:filename)', 'g')
   24              0.000023     endif
                            
   48              0.000217     if l:command =~# '%t'
                                    " Create a temporary filename, <temp_dir>/<original_basename>
                                    " The file itself will not be created by this function.
   24   0.001836   0.000314         let l:temporary_file = s:TemporaryFilename(a:buffer)
   24   0.001037   0.000477         let l:command = substitute(l:command, '%t', '\=ale#Escape(l:temporary_file)', 'g')
   24              0.000025     endif
                            
                                " Finish formatting so %% becomes %.
   48              0.000738     let l:command = substitute(l:command, '<<PERCENTS>>', '%', 'g')
                            
   48              0.000264     if a:pipe_file_if_needed && empty(l:temporary_file)
                                    " If we are to send the Vim buffer to a command, we'll do it
                                    " in the shell. We'll write out the file to a temporary file,
                                    " and then read it back in, in the shell.
   24   0.005913   0.000805         let l:temporary_file = s:TemporaryFilename(a:buffer)
   24   0.001561   0.000872         let l:command = l:command . ' < ' . ale#Escape(l:temporary_file)
   24              0.000026     endif
                            
   48              0.000175     return [l:temporary_file, l:command]

FUNCTION  neocomplete#get_current_neocomplete()
Called 650 times
Total time:   0.007039
 Self time:   0.006336

count  total (s)   self (s)
  650              0.002370   if !exists('b:neocomplete')
    2   0.000811   0.000108     call neocomplete#init#_current_neocomplete()
    2              0.000002   endif
                            
  650              0.000887   return b:neocomplete

FUNCTION  <SNR>21_buffer_getvar()
Called 34 times
Total time:   0.000206
 Self time:   0.000206

count  total (s)   self (s)
   34              0.000183   return getbufvar(self['#'],a:var)

FUNCTION  neocomplete#within_comment()
Called 15 times
Total time:   0.000234
 Self time:   0.000111

count  total (s)   self (s)
   15   0.000224   0.000101   return neocomplete#get_current_neocomplete().within_comment

FUNCTION  <SNR>134_extract_modules()
Called 5 times
Total time:   0.023736
 Self time:   0.023736

count  total (s)   self (s)
    5              0.000034   let l:modules = {'Prelude': {'qualified': 0, 'export': 0}}
                            
    5              0.000010   let l:in_module = 0
    5              0.000007   let l:line = 1
    5              0.000028   let l:max = min([line('$'), 100])
  263              0.000368   while l:line <= l:max
  258              0.000688     let l:str = getline(l:line)
  258              0.001390     if l:str =~# '^import\s\+'
   79              0.000962       let l:idx = matchend(l:str, '^import\s\+')
                            
                                  " qualified
   79              0.000633       let l:end = matchend(l:str, '^qualified\s\+', l:idx)
   79              0.000105       if l:end != -1
   27              0.000035         let l:qualified = 1
   27              0.000034         let l:idx = l:end
   27              0.000019       else
   52              0.000069         let l:qualified = 0
   52              0.000039       endif
                            
   79              0.001739       let l:name = matchstr(l:str, '^[A-Za-z][A-Za-z0-9.]*', l:idx)
   79              0.000144       if l:name != ''
   79              0.000232         if !has_key(l:modules, l:name)
   78              0.000336           let l:modules[l:name] = { 'qualified': 0, 'export': 0 }
   78              0.000055         endif
   79              0.000327         let l:modules[l:name].qualified = l:modules[l:name].qualified || l:qualified
   79              0.002194         let l:idx = matchend(l:str, '^[A-Za-z][A-Za-z0-9.]*\s*', l:idx)
                            
                                    " as
   79              0.000532         let l:end = matchend(l:str, '^as\s\+', l:idx)
   79              0.000102         if l:end != -1
   27              0.000060           let l:pattern = "\\%([[:alpha:]_'][[:alnum:]_'.]*\\m\\)"
   27              0.000431           let l:as = matchstr(l:str, l:pattern, l:end)
   27              0.000081           let l:modules[l:name].as = l:as
   27              0.000057         elseif match(l:str, '^(', l:idx) != -1
                                      " exports
   28              0.000066           let l:modules[l:name].export = 1
   28              0.000019         endif
   79              0.000045       endif
   79              0.000108     elseif l:in_module || l:str =~# '^\s*$'
                                  " skip
  174              0.000175     elseif l:str =~# '^module\s'
    5              0.000010       let l:in_module = 1
    5              0.000004     else
                                  let l:end = matchend(l:str, '^\s*')
                                  let l:syn = s:synname(l:line, l:end+1)
                                  if l:syn !~# 'Pragma' && l:syn !~# 'Comment'
                                    break
                                  endif
                                endif
                            
  258              0.000953     if l:line =~# '\<where\>'
                                  let l:in_module = 0
                                endif
  258              0.000373     let l:line += 1
  258              0.000404   endwhile
                            
    5              0.000008   return l:modules

FUNCTION  ale#job#ValidateArguments()
Called 48 times
Total time:   0.000829
 Self time:   0.000829

count  total (s)   self (s)
   48              0.000223     if a:options.mode isnot# 'nl' && a:options.mode isnot# 'raw'
                                    throw 'Invalid mode: ' . a:options.mode
                                endif

FUNCTION  neocomplete#init#_filters()
Called 2 times
Total time:   0.000458
 Self time:   0.000415

count  total (s)   self (s)
    2              0.000012   let _ = []
    2   0.000125   0.000082   let filters = neocomplete#variables#get_filters()
                            
    6              0.000013   for name in a:names
    4              0.000015     if !has_key(filters, name)
                                  " Search autoload.
                                  for filter_name in map(split(globpath(&runtimepath, 'autoload/neocomplete/filters/'.   substitute(name,'^\%(matcher\|sorter\|converter\)_[^/_-]\+\zs[/_-].*$', '', '')  .'*.vim'), '\n'), "fnamemodify(v:val, ':t:r')")
                                    let filter = neocomplete#filters#{filter_name}#define()
                                    if empty(filter)
                                      " Ignore.
                                      continue
                                    endif
                            
                                    call neocomplete#define_filter(filter)
                                  endfor
                            
                                  if !has_key(filters, name)
                                    " Not found.
                                    call neocomplete#print_error( printf('filter name : %s is not found.', string(name)))
                                    continue
                                  endif
                                endif
                            
    4              0.000016     if has_key(filters, name)
    4              0.000020       call add(_, filters[name])
    4              0.000004     endif
    4              0.000004   endfor
                            
    2              0.000004   return _

FUNCTION  <SNR>72_ApplyPartialTimer()
Called 33 times
Total time:   0.014054
 Self time:   0.001186

count  total (s)   self (s)
   33              0.000591     let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
   33   0.013397   0.000529     call call(l:Callback, [a:timer_id] + l:args)

FUNCTION  <SNR>116_GetLinterNames()
Called 63 times
Total time:   0.001922
 Self time:   0.001922

count  total (s)   self (s)
  142              0.000697     for l:dict in [   get(b:, 'ale_linters', {}),   g:ale_linters,   s:default_ale_linters,]
  134              0.000445         if has_key(l:dict, a:original_filetype)
   55              0.000136             return l:dict[a:original_filetype]
                                    endif
   79              0.000135     endfor
                            
    8              0.000010     return 'all'

FUNCTION  <SNR>134_filter()
Called 4 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    4              0.000014   return a:needed ? filter(a:list,                  's:word_prefix(v:val, a:keyword, a:need_prefix)'                 ) : a:list

FUNCTION  <SNR>127_BuildSignMap()
Called 46 times
Total time:   0.006978
 Self time:   0.005355

count  total (s)   self (s)
   46   0.002114   0.000491     let l:max_signs = ale#Var(a:buffer, 'max_signs')
                            
   46              0.000098     if l:max_signs is 0
                                    let l:selected_grouped_items = []
                                elseif type(l:max_signs) is type(0) && l:max_signs > 0
                                    let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
                                else
   46              0.000133         let l:selected_grouped_items = a:grouped_items
   46              0.000052     endif
                            
   46              0.000108     let l:sign_map = {}
   46              0.000117     let l:sign_offset = g:ale_sign_offset
                            
   46              0.000137     for [l:line, l:sign_id, l:name] in a:current_sign_list
                                    let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    " Increment the sign offset for new signs, by the maximum sign ID.
                                    if l:sign_id > l:sign_offset
                                        let l:sign_offset = l:sign_id
                                    endif
                            
                                    " Remember the sign names and IDs in separate Lists, so they are easy
                                    " to work with.
                                    call add(l:sign_info.current_id_list, l:sign_id)
                                    call add(l:sign_info.current_name_list, l:name)
                            
                                    let l:sign_map[l:line] = l:sign_info
                                endfor
                            
   46              0.000116     for l:group in l:selected_grouped_items
                                    let l:line = l:group[0].lnum
                                    let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    let l:sign_info.new_name = ale#sign#GetSignName(l:group)
                                    let l:sign_info.items = l:group
                            
                                    let l:index = index(   l:sign_info.current_name_list,   l:sign_info.new_name)
                            
                                    if l:index >= 0
                                        " We have a sign with this name already, so use the same ID.
                                        let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
                                    else
                                        " This sign name replaces the previous name, so use a new ID.
                                        let l:sign_info.new_id = l:sign_offset + 1
                                        let l:sign_offset += 1
                                    endif
                            
                                    let l:sign_map[l:line] = l:sign_info
                                endfor
                            
   46              0.000555     return l:sign_map

FUNCTION  <SNR>132__encode_name()
Called 53 times
Total time:   0.010616
 Self time:   0.003401

count  total (s)   self (s)
                              " Check cache directory.
   53              0.000525   if !isdirectory(a:cache_dir)
                                call mkdir(a:cache_dir, 'p')
                              endif
   53              0.000117   let cache_dir = a:cache_dir
   53              0.001486   if cache_dir !~# '/$'
   53              0.000199     let cache_dir .= '/'
   53              0.000052   endif
                            
   53   0.007826   0.000611   return cache_dir . s:_create_hash(cache_dir, a:filename)

FUNCTION  neocomplete#util#is_text_changed()
Called 9 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
                              " Note: Vim 7.4.143 fixed TextChangedI bug.
    9              0.000028   return v:version > 704 || v:version == 704 && has('patch143')

FUNCTION  neocomplete#complete#_set_previous_position()
Called 15 times
Total time:   0.000374
 Self time:   0.000247

count  total (s)   self (s)
   15   0.000217   0.000090   let neocomplete = neocomplete#get_current_neocomplete()
   15              0.000037   let neocomplete.old_complete_pos = a:complete_pos
   15              0.000049   let neocomplete.old_linenr = line('.')
   15              0.000057   let neocomplete.old_cur_text = a:cur_text

FUNCTION  ale#CallWithCooldown()
Called 338 times
Total time:   0.709674
 Self time:   0.032590

count  total (s)   self (s)
  338   0.012280   0.005776     let l:now = ale#util#ClockMilliseconds()
                            
  338              0.003851     if l:now < get(s:timestamp_map, a:timestamp_key, -1)
                                    return 0
                                endif
                            
  338              0.003608     let s:timestamp_map[a:timestamp_key] = l:now + s:error_delay_ms
                            
  338   0.525479   0.034983     let l:return_value = call(a:func, a:arglist)
                            
  338              0.003194     let s:timestamp_map[a:timestamp_key] = -1
                            
  338              0.001593     return l:return_value

FUNCTION  <SNR>101_use_previous_result()
Called 92 times
Total time:   0.004740
 Self time:   0.004054

count  total (s)   self (s)
   92   0.001133   0.000447   let neocomplete = neocomplete#get_current_neocomplete()
   92              0.003509   return !a:source.is_volatile && substitute(a:context.input, '\k\+$', '', '')    ==# substitute(a:context.prev_line, '\k\+$', '', '') && stridx(a:context.input, a:context.prev_line) == 0 && !empty(a:context.prev_candidates) && line('.') == neocomplete.old_linenr

FUNCTION  ale_linters#yaml#swaglint#GetExecutable()
Called 4 times
Total time:   0.002285
 Self time:   0.000086

count  total (s)   self (s)
    4   0.002277   0.000078     return ale#node#FindExecutable(a:buffer, 'yaml_swaglint', [   'node_modules/.bin/swaglint',])

FUNCTION  neocomplete#mappings#close_popup()
Called 2 times
Total time:   0.000363
 Self time:   0.000043

count  total (s)   self (s)
    2   0.000027   0.000011   let neocomplete = neocomplete#get_current_neocomplete()
    2              0.000007   let neocomplete.complete_str = ''
    2   0.000318   0.000014   let neocomplete.old_cur_text = neocomplete#get_cur_text(1)
    2              0.000004   let neocomplete.skip_next_complete = 1
                            
    2              0.000004   return pumvisible() ? "\<C-y>" : ''

FUNCTION  <SNR>108_libcall_raw_read()
Called 8 times
Total time:   0.605619
 Self time:   0.000422

count  total (s)   self (s)
    8   0.605591   0.000394   let [err, hd] = s:libcall(a:func, a:args)
    8              0.000021   return [hd, err]

FUNCTION  <SNR>101_set_default_menu()
Called 2 times
Total time:   0.000189
 Self time:   0.000189

count  total (s)   self (s)
    2              0.000008   lua << EOF
                              do
                                local candidates = vim.eval('a:words')
                                local mark = vim.eval('a:source.mark') .. ' '
                                for i = 0, #candidates-1 do
                                  candidates[i].menu = mark .. (candidates[i].menu ~= nil and
                                                       candidates[i].menu or '')
                                end
                              end
                            EOF

FUNCTION  <SNR>43_upgrade()
Called 5 times
Total time:   0.000127
 Self time:   0.000127

count  total (s)   self (s)
    5              0.000035   let copy = copy(a:dict)
    5              0.000014   if has_key(copy, 'tmux')
                                let copy.down = remove(copy, 'tmux')
                              endif
    5              0.000012   if has_key(copy, 'tmux_height')
                                let copy.down = remove(copy, 'tmux_height')
                              endif
    5              0.000011   if has_key(copy, 'tmux_width')
                                let copy.right = remove(copy, 'tmux_width')
                              endif
    5              0.000006   return copy

FUNCTION  fzf#shellescape()
Called 25 times
Total time:   0.001015
 Self time:   0.000833

count  total (s)   self (s)
   25              0.000167   let shell = get(a:000, 0, &shell)
   25              0.000215   if shell =~# 'cmd.exe$'
                                return s:shellesc_cmd(a:arg)
                              endif
   25   0.000446   0.000264   return s:fzf_call('shellescape', a:arg)

FUNCTION  <SNR>21_repo_bare()
Called 2 times
Total time:   0.000069
 Self time:   0.000056

count  total (s)   self (s)
    2   0.000063   0.000050   if self.dir() =~# '/\.git$'
    2              0.000004     return 0
                              else
                                return s:configured_tree(self.git_dir) ==# ''
                              endif

FUNCTION  <SNR>21_shellslash()
Called 28 times
Total time:   0.000734
 Self time:   0.000421

count  total (s)   self (s)
   28   0.000482   0.000169   if s:winshell()
                                return s:gsub(a:path,'\\','/')
                              else
   28              0.000048     return a:path
                              endif

FUNCTION  <SNR>21_define_commands()
Called 4 times
Total time:   0.002587
 Self time:   0.002587

count  total (s)   self (s)
  112              0.000240   for command in s:commands
  108              0.002127     exe 'command! -buffer '.command
  108              0.000164   endfor

FUNCTION  <SNR>136_shortpath()
Called 5 times
Total time:   0.000679
 Self time:   0.000679

count  total (s)   self (s)
    5              0.000363   let short = fnamemodify(getcwd(), ':~:.')
    5              0.000048   if !has('win32unix')
    5              0.000031     let short = pathshorten(short)
    5              0.000009   endif
    5              0.000024   let slash = (s:is_win && !&shellslash) ? '\' : '/'
    5              0.000152   return empty(short) ? '~'.slash : short . (short =~ escape(slash, '\').'$' ? '' : slash)

FUNCTION  <SNR>108_fdopen_pgroup()
Called 24 times
Total time:   0.004592
 Self time:   0.001282

count  total (s)   self (s)
   24   0.004536   0.001226   return { 'eof' : 0, '__eof' : 0, 'is_valid' : 1, 'buffer' : [], 'proc' : a:proc, 'fd' : a:fd, 'f_close' : s:funcref(a:f_close), 'close' : s:funcref('close'), 'read' : s:funcref(a:f_read), 'write' : s:funcref(a:f_write), 'read_line' : s:funcref('read_line'), 'read_lines' : s:funcref('read_lines'),}

FUNCTION  <SNR>128_BufWinId()
Called 46 times
Total time:   0.000557
 Self time:   0.000557

count  total (s)   self (s)
   46              0.000478     return exists('*bufwinid') ? bufwinid(str2nr(a:buffer)) : 0

FUNCTION  ale#Queue()
Called 35 times
Total time:   0.186160
 Self time:   0.002654

count  total (s)   self (s)
   35              0.000191     if a:0 > 2
                                    throw 'too many arguments!'
                                endif
                            
                                " Default linting_flag to ''
   35              0.000200     let l:linting_flag = get(a:000, 0, '')
   35              0.000165     let l:buffer = get(a:000, 1, bufnr(''))
                            
   35   0.185055   0.001549     return ale#CallWithCooldown(   'dont_queue_until',   function('s:ALEQueueImpl'),   [a:delay, l:linting_flag, l:buffer],)

FUNCTION  fugitive#extract_git_dir()
Called 2 times
Total time:   0.001896
 Self time:   0.000936

count  total (s)   self (s)
    2   0.000094   0.000034   if s:shellslash(a:path) =~# '^fugitive://.*//'
                                return matchstr(s:shellslash(a:path), '\C^fugitive://\zs.\{-\}\ze//')
                              endif
    2              0.000019   if isdirectory(a:path)
                                let path = fnamemodify(a:path, ':p:s?[\/]$??')
                              else
    2              0.000095     let path = fnamemodify(a:path, ':p:h:s?[\/]$??')
    2              0.000003   endif
    2   0.000123   0.000073   let root = s:shellslash(resolve(path))
    2              0.000005   let previous = ""
    6              0.000016   while root !=# previous
    6              0.000052     if root =~# '\v^//%([^/]+/?)?$'
                                  " This is for accessing network shares from Cygwin Vim. There won't be
                                  " any git directory called //.git or //serverName/.git so let's avoid
                                  " checking for them since such checks are extremely slow.
                                  break
                                endif
    6              0.000061     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
                                  break
                                endif
    6              0.000028     if root ==# $GIT_WORK_TREE && fugitive#is_git_dir($GIT_DIR)
                                  return simplify(fnamemodify(expand($GIT_DIR), ':p:s?[\/]$??'))
                                endif
    6   0.000329   0.000090     if fugitive#is_git_dir($GIT_DIR)
                                  " Ensure that we've cached the worktree
                                  call s:configured_tree(simplify(fnamemodify(expand($GIT_DIR), ':p:s?[\/]$??')))
                                  if has_key(s:dir_for_worktree, root)
                                    return s:dir_for_worktree[root]
                                  endif
                                endif
    6   0.000269   0.000047     let dir = s:sub(root, '[\/]$', '') . '/.git'
    6              0.000065     let type = getftype(dir)
    6   0.000176   0.000029     if type ==# 'dir' && fugitive#is_git_dir(dir)
    2              0.000004       return dir
                                elseif type ==# 'link' && fugitive#is_git_dir(dir)
                                  return resolve(dir)
                                elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  if line =~# '^gitdir: \.' && fugitive#is_git_dir(root.'/'.line[8:-1])
                                    return simplify(root.'/'.line[8:-1])
                                  elseif line =~# '^gitdir: ' && fugitive#is_git_dir(line[8:-1])
                                    return line[8:-1]
                                  endif
                                elseif fugitive#is_git_dir(root)
                                  return root
                                endif
    4              0.000007     let previous = root
    4              0.000015     let root = fnamemodify(root, ':h')
    4              0.000005   endwhile
                              return ''

FUNCTION  <SNR>132_getfilename()
Called 40 times
Total time:   0.008983
 Self time:   0.000499

count  total (s)   self (s)
   40   0.008913   0.000429   return s:_encode_name(a:cache_dir, a:filename)

FUNCTION  vimproc#get_command_name()
Called 8 times
Total time:   0.001605
 Self time:   0.000686

count  total (s)   self (s)
    8              0.000199   let path = get(a:000, 0, $PATH)
                            
    8              0.000022   let cnt = a:0 < 2 ? 1 : a:2
                            
    8   0.001202   0.000283   let files = split(substitute(vimproc#util#substitute_path_separator( vimproc#filepath#which(a:command, path, cnt)), '//', '/', 'g'), '\n')
                            
    8              0.000013   if cnt < 0
                                return files
                              endif
                            
    8              0.000041   let file = get(files, cnt-1, '')
                            
    8              0.000013   if file == ''
                                throw printf( 'vimproc#get_command_name: File "%s" is not found.', a:command)
                              endif
                            
    8              0.000010   return file

FUNCTION  <SNR>134_ghc_mod_caching_browse()
Called 2 times
Total time:   0.632327
 Self time:   0.000187

count  total (s)   self (s)
    2              0.000007   let l:cmd = ['browse', '-o']
    2              0.000006   if get(g:, 'necoghc_enable_detailed_browse')
    2              0.000005     let l:cmd += ['-d']
    2              0.000002   endif
                              " a callback to supply extra parameters to the `browse` command
                              " depending on the module name
    2              0.000007   if exists('*g:NecoghcExtraBrowseOptions')
                                let l:cmd += g:NecoghcExtraBrowseOptions(a:mod)
                              endif
    2              0.000005   let l:cmd += [a:mod]
                            
    2              0.000003   if !s:is_async
    2   0.632269   0.000129     call s:ghc_mod_caching_async(s:ghc_mod(l:cmd), a:mod)
    2              0.000004     return
                              endif
                            
                              if len(s:job_info) > s:max_processes || !empty(filter(copy(s:job_info), 'v:val.mod ==# a:mod'))
                                return
                              endif
                            
                              if has('nvim')
                                let l:id = jobstart(s:ghc_mod_path + l:cmd, { 'on_stdout': function('s:job_handler'), 'on_stderr': function('s:job_handler'), 'on_exit': function('s:job_handler'), })
                                let s:job_info[l:id] = { 'candidates': [], 'eof': 0, 'status': -1, 'mod': a:mod, }
                              elseif s:is_async
                                try
                                  " Note: In Windows, job_start() does not work in shellslash.
                                  let shellslash = 0
                                  if exists('+shellslash')
                                    let shellslash = &shellslash
                                    set noshellslash
                                  endif
                                  let l:job = job_start(s:ghc_mod_path + l:cmd, {   'callback': function('s:job_handler_vim'),   'close_cb': function('s:job_close_callback_vim'), })
                                  let l:id = s:channel2id(job_getchannel(l:job))
                                  let s:job_info[l:id] = { 'candidates': [], 'eof': 0, 'status': -1, 'mod': a:mod, 'job': l:job, }
                                finally
                                  if exists('+shellslash')
                                    let &shellslash = shellslash
                                  endif
                                endtry
                              endif

FUNCTION  neocomplete#has_vimproc()
Called 26 times
Total time:   0.001367
 Self time:   0.000566

count  total (s)   self (s)
   26   0.001252   0.000451   return neocomplete#util#has_vimproc()

FUNCTION  <SNR>85_should_create_cache()
Called 12 times
Total time:   0.001125
 Self time:   0.001125

count  total (s)   self (s)
   12              0.000743   let filepath = fnamemodify(bufname(a:bufnr), ':p')
   12              0.000342   return getfsize(filepath) < g:neocomplete#sources#buffer#cache_limit_size && getbufvar(a:bufnr, '&modifiable') && !getwinvar(bufwinnr(a:bufnr), '&previewwindow') && (g:neocomplete#sources#buffer#disabled_pattern == ''  || filepath !~# g:neocomplete#sources#buffer#disabled_pattern)

FUNCTION  <SNR>21_buffer_getline()
Called 12 times
Total time:   0.000089
 Self time:   0.000089

count  total (s)   self (s)
   12              0.000081   return get(getbufline(self['#'], a:lnum), 0, '')

FUNCTION  ale#engine#IsExecutable()
Called 56 times
Total time:   0.002738
 Self time:   0.001876

count  total (s)   self (s)
   56              0.000435     if has_key(s:executable_cache_map, a:executable)
   48              0.000095         return 1
                                endif
                            
    8              0.000017     let l:result = 0
                            
    8              0.000823     if executable(a:executable)
                                    let s:executable_cache_map[a:executable] = 1
                            
                                    let l:result = 1
                                endif
                            
    8              0.000017     if g:ale_history_enabled
    8   0.000992   0.000130         call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
    8              0.000014     endif
                            
    8              0.000020     return l:result

FUNCTION  ale#Escape()
Called 96 times
Total time:   0.004172
 Self time:   0.004172

count  total (s)   self (s)
   96              0.000674     if fnamemodify(&shell, ':t') is? 'cmd.exe'
                                    " If the string contains spaces, it will be surrounded by quotes.
                                    " Otherwise, special characters will be escaped with carets (^).
                                    return substitute(   a:str =~# ' '       ?  '"' .  substitute(a:str, '"', '""', 'g') . '"'       : substitute(a:str, '\v([&|<>^])', '^\1', 'g'),   '%',   '%%',   'g',)
                                endif
                            
   96              0.000544     return shellescape (a:str)

FUNCTION  <SNR>85_exists_current_source()
Called 5 times
Total time:   0.000206
 Self time:   0.000085

count  total (s)   self (s)
    5   0.000199   0.000078   return has_key(s:buffer_sources, bufnr('%')) && !s:check_changed_buffer(bufnr('%'))

FUNCTION  neocomplete#helper#call_filters()
Called 8 times
Total time:   0.008398
 Self time:   0.002257

count  total (s)   self (s)
    8              0.000038   let context = extend(a:source.neocomplete__context, a:context)
   22              0.000785   for filter in a:filters
   14              0.000015     try
   14   0.007051   0.000910       let context.candidates = call(filter.filter, [context], filter)
   14              0.000044     catch
                                  call neocomplete#print_error(v:throwpoint)
                                  call neocomplete#print_error(v:exception)
                                  call neocomplete#print_error( 'Error occurred in calling filter '   . filter.name . '!')
                                  call neocomplete#print_error( 'Source name is ' . a:source.name)
                                endtry
   14              0.000022   endfor
                            
    8              0.000027   return context.candidates

FUNCTION  <SNR>132_check_old_cache()
Called 7 times
Total time:   0.002504
 Self time:   0.001298

count  total (s)   self (s)
                              " Check old cache file.
    7   0.001312   0.000106   let cache_name = s:_encode_name(a:cache_dir, a:filename)
    7              0.000210   let ret = getftime(cache_name) == -1 || getftime(cache_name) <= getftime(a:filename)
    7              0.000126   if ret && filereadable(cache_name)
                                " Delete old cache.
    5              0.000780     call delete(cache_name)
    5              0.000010   endif
                            
    7              0.000016   return ret

FUNCTION  ale#events#FileTypeEvent()
Called 4 times
Total time:   0.001972
 Self time:   0.000162

count  total (s)   self (s)
    4              0.000040     let l:filetype = getbufvar(a:buffer, 'ale_original_filetype', '')
                            
                                " If we're setting the filetype for the first time after it was blank,
                                " and the option for linting on enter is off, then we should set this
                                " filetype as the original filetype. Otherwise ALE will still appear to
                                " lint files because of the BufEnter event, etc.
    4   0.000109   0.000039     if empty(l:filetype) && !ale#Var(a:buffer, 'lint_on_enter')
                                    call setbufvar(a:buffer, 'ale_original_filetype', a:new_filetype)
                                elseif a:new_filetype isnot# l:filetype
    2   0.001758   0.000018         call ale#Queue(300, 'lint_file', a:buffer)
    2              0.000001     endif

FUNCTION  ale#util#BinarySearch()
Called 267 times
Total time:   0.005040
 Self time:   0.005040

count  total (s)   self (s)
  267              0.000798     let l:min = 0
  267              0.001471     let l:max = len(a:loclist) - 1
                            
  267              0.000610     while 1
  267              0.000646         if l:max < l:min
  267              0.000533             return -1
                                    endif
                            
                                    let l:mid = (l:min + l:max) / 2
                                    let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
                                    if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
                                    elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
                                    elseif l:item.lnum < a:line
                                        let l:min = l:mid + 1
                                    elseif l:item.lnum > a:line
                                        let l:max = l:mid - 1
                                    else
                                        " This part is a small sequential search.
                                        let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
                                        while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
                                        endwhile
                            
                                        " Find the last problem on or before this column.
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
                                        endwhile
                            
                                        return l:index
                                    endif
                                endwhile

FUNCTION  neocomplete#variables#get_source()
Called 48 times
Total time:   0.000553
 Self time:   0.000553

count  total (s)   self (s)
   48              0.000164   if !exists('s:sources')
                                let s:sources = {}
                              endif
   48              0.000229   return get(s:sources, a:name, {})

FUNCTION  285()
Called 11 times
Total time:   0.004117
 Self time:   0.000428

count  total (s)   self (s)
   11   0.003949   0.000316   let a:context.source__complete_results = s:set_complete_results_pos(   s:get_omni_funcs(a:context.filetype), a:context.input)
                            
   11   0.000152   0.000096   return s:get_complete_pos(a:context.source__complete_results)

FUNCTION  <SNR>108_close_all()
Called 10 times
Total time:   0.007018
 Self time:   0.000385

count  total (s)   self (s)
   10              0.000051   if has_key(a:self, 'stdin')
   10   0.002700   0.000083     call a:self.stdin.close()
   10              0.000009   endif
   10              0.000032   if has_key(a:self, 'stdout')
   10   0.002163   0.000056     call a:self.stdout.close()
   10              0.000007   endif
   10              0.000031   if has_key(a:self, 'stderr')
   10   0.001973   0.000064     call a:self.stderr.close()
   10              0.000006   endif

FUNCTION  <SNR>43_validate_layout()
Called 5 times
Total time:   0.000178
 Self time:   0.000178

count  total (s)   self (s)
   10              0.000047   for key in keys(a:layout)
    5              0.000033     if index(s:layout_keys, key) < 0
                                  throw printf('Invalid entry in g:fzf_layout: %s (allowed: %s)%s', key, join(s:layout_keys, ', '), key == 'options' ? '. Use $FZF_DEFAULT_OPTS.' : '')
                                endif
    5              0.000005   endfor
    5              0.000007   return a:layout

FUNCTION  <SNR>21_buffer_path()
Called 2 times
Total time:   0.002194
 Self time:   0.000372

count  total (s)   self (s)
    2   0.000208   0.000039   let rev = matchstr(self.spec(),'^fugitive://.\{-\}//\zs.*')
    2              0.000005   if rev != ''
                                let rev = s:sub(rev,'\w*','')
                              elseif s:cpath(self.spec()[0 : len(self.repo().dir())]) ==# s:cpath(self.repo().dir() . '/')
                                let rev = '/.git'.self.spec()[strlen(self.repo().dir()) : -1]
                              elseif !self.repo().bare() && s:cpath(self.spec()[0 : len(self.repo().tree())]) ==# s:cpath(self.repo().tree() . '/')
    2   0.000417   0.000034     let rev = self.spec()[strlen(self.repo().tree()) : -1]
    2              0.000002   endif
    2   0.000093   0.000018   return s:sub(s:sub(rev,'.\zs/$',''),'^/',a:0 ? a:1 : '')

FUNCTION  <SNR>108_decode_list()
Called 3561 times
Total time:   0.070854
 Self time:   0.069268

count  total (s)   self (s)
 3561              0.006640   let err = 0
                              " End Of Value
 3561              0.011695   let EOV = "\xFF"
 3561              0.014065   if a:str[0] != EOV
 3543              0.004615     let err = 1
 3543              0.022474     return [[a:str], err]
                              endif
   18              0.000165   let arr = []
   18              0.000150   let slen = strlen(a:str)
   18              0.000039   let off = 1
   70              0.000283   while slen - off >= 5
   52   0.002676   0.001090     let size = s:decode_size(a:str, off)
   52              0.000556     let arr += [a:str[off + 5 : off + 5 + size - 1]]
   52              0.000186     let off += 5 + size + 1
   52              0.000184   endwhile
   18              0.000042   return [arr, err]

FUNCTION  <SNR>108_read_pipes()
Called 8 times
Total time:   0.607327
 Self time:   0.000640

count  total (s)   self (s)
    8              0.000059   if type(self.fd[-1]) != type({})
                                let self.eof = 1
                                return ''
                              endif
                            
    8              0.000024   let number = get(a:000, 0, -1)
    8              0.000024   let timeout = get(a:000, 1, s:read_timeout)
                            
    8   0.607121   0.000434   let output = self.fd[-1].read(number, timeout)
    8              0.000033   let self.eof = self.fd[-1].eof
                            
    8              0.000012   return output

FUNCTION  <SNR>96_uniq_by()
Called 16 times
Total time:   0.007336
 Self time:   0.007336

count  total (s)   self (s)
   16              0.000837   let list = map(copy(a:list), printf('[v:val, %s]', a:f))
   16              0.000025   let i = 0
   16              0.000028   let seen = {}
  489              0.000706   while i < len(list)
  473              0.001332     let key = string(list[i][1])
  473              0.000878     if has_key(seen, key)
  221              0.000478       call remove(list, i)
  221              0.000127     else
  252              0.000417       let seen[key] = 1
  252              0.000200       let i += 1
  252              0.000135     endif
  473              0.000367   endwhile
   16              0.000340   return map(list, 'v:val[0]')

FUNCTION  <SNR>85_make_cache_file()
Called 7 times
Total time:   0.182416
 Self time:   0.001443

count  total (s)   self (s)
                              " Initialize source.
    7              0.000054   if !has_key(s:buffer_sources, a:srcname)
    2   0.002740   0.000068     call s:initialize_source(a:srcname)
    2              0.000004   endif
                            
    7              0.000031   let source = s:buffer_sources[a:srcname]
                            
    7              0.000418   if !filereadable(source.path) || getbufvar(a:srcname, '&modified') || getbufvar(a:srcname, '&buftype') =~ 'nofile\|acwrite'
                                call s:make_cache_buffer(a:srcname)
                                return
                              endif
                            
    7   0.000198   0.000113   call neocomplete#print_debug('make_cache_buffer: ' . source.path)
                            
    7   0.178557   0.000341   let source.cache_name = neocomplete#cache#async_load_from_file(     'buffer_cache', source.path,     source.keyword_pattern, 'B')
    7              0.000049   let source.cached_time = localtime()
    7              0.000066   let source.filetype = getbufvar(a:srcname, '&filetype')
    7              0.000126   let s:async_dictionary_list[source.path] = [{ 'filename' : source.path, 'cachename' : source.cache_name, }]

FUNCTION  <SNR>123_HandleExit()
Called 57 times
Total time:   0.142708
 Self time:   0.019584

count  total (s)   self (s)
   57              0.000335     if !has_key(s:job_info_map, a:job_id)
   19              0.000027         return
                                endif
                            
   38              0.000197     let l:job_info = s:job_info_map[a:job_id]
   38              0.000114     let l:linter = l:job_info.linter
   38              0.000102     let l:output = l:job_info.output
   38              0.000099     let l:buffer = l:job_info.buffer
   38              0.000104     let l:next_chain_index = l:job_info.next_chain_index
                            
   38              0.000079     if g:ale_history_enabled
   38   0.004444   0.000537         call ale#history#SetExitCode(l:buffer, a:job_id, a:exit_code)
   38              0.000040     endif
                            
                                " Remove this job from the list.
   38   0.004410   0.000259     call ale#job#Stop(a:job_id)
   38              0.000257     call remove(s:job_info_map, a:job_id)
   38              0.002651     call filter(g:ale_buffer_info[l:buffer].job_list, 'v:val isnot# a:job_id')
   38              0.000479     call filter(g:ale_buffer_info[l:buffer].active_linter_list, 'v:val isnot# l:linter.name')
                            
                                " Stop here if we land in the handle for a job completing if we're in
                                " a sandbox.
   38   0.010305   0.000275     if ale#util#InSandbox()
                                    return
                                endif
                            
   38              0.008965     if has('nvim') && !empty(l:output) && empty(l:output[-1])
                                    call remove(l:output, -1)
                                endif
                            
   38              0.000236     if l:next_chain_index < len(get(l:linter, 'command_chain', []))
                                    call s:InvokeChain(l:buffer, l:linter, l:next_chain_index, l:output)
                                    return
                                endif
                            
                                " Log the output of the command for ALEInfo if we should.
   38              0.000113     if g:ale_history_enabled && g:ale_history_log_output
   38   0.002775   0.000344         call ale#history#RememberOutput(l:buffer, a:job_id, l:output[:])
   38              0.000055     endif
                            
   38   0.005179   0.000766     let l:loclist = ale#util#GetFunction(l:linter.callback)(l:buffer, l:output)
                            
   38   0.098762   0.000570     call s:HandleLoclist(l:linter.name, l:buffer, l:loclist)

FUNCTION  <SNR>96_uniq()
Called 16 times
Total time:   0.007528
 Self time:   0.000192

count  total (s)   self (s)
   16   0.007501   0.000165   return s:uniq_by(a:list, 'v:val')

FUNCTION  <SNR>99_is_skip_auto_complete()
Called 11 times
Total time:   0.000496
 Self time:   0.000401

count  total (s)   self (s)
   11   0.000172   0.000077   let neocomplete = neocomplete#get_current_neocomplete()
                            
   11              0.000169   if (g:neocomplete#lock_iminsert && &l:iminsert) || (&l:formatoptions =~# '[tca]' && &l:textwidth > 0     && strdisplaywidth(a:cur_text) >= &l:textwidth)
                                let neocomplete.skip_next_complete = 0
                                return 1
                              endif
                            
   11              0.000039   let skip = neocomplete.skip_next_complete
                            
   11              0.000034   if !skip || s:is_delimiter()
   11              0.000014     return 0
                              endif
                            
                              let neocomplete.skip_next_complete = 0
                              return skip

FUNCTION  <SNR>95_set_complete_results_pos()
Called 11 times
Total time:   0.000602
 Self time:   0.000602

count  total (s)   self (s)
                              " Try omnifunc completion. "{{{
   11              0.000028   let complete_results = {}
   11              0.000025   for [omnifunc, pattern] in a:funcs
                                if neocomplete#is_auto_complete() && (pattern == ''     || a:cur_text !~# '\%(' . pattern . '\m\)$')
                                  continue
                                endif
                            
                                " Save pos.
                                let pos = getpos('.')
                            
                                try
                                  let complete_pos = call(omnifunc, [1, ''])
                                catch
                                  call neocomplete#print_error( 'Error occurred calling omnifunction: ' . omnifunc)
                                  call neocomplete#print_error(v:throwpoint)
                                  call neocomplete#print_error(v:exception)
                                  let complete_pos = -1
                                finally
                                  if getpos('.') != pos
                                    call setpos('.', pos)
                                  endif
                                endtry
                            
                                if complete_pos < 0
                                  continue
                                endif
                            
                                let complete_str = a:cur_text[complete_pos :]
                            
                                let complete_results[omnifunc] = { 'candidates' : [], 'complete_pos' : complete_pos, 'complete_str' : complete_str, 'omnifunc' : omnifunc,}
                              endfor
                              "}}}
                            
   11              0.000017   return complete_results

FUNCTION  ale#linter#GetCommand()
Called 48 times
Total time:   0.000736
 Self time:   0.000736

count  total (s)   self (s)
   48              0.000680     return has_key(a:linter, 'command_callback')   ? ale#util#GetFunction(a:linter.command_callback)(a:buffer)   : a:linter.command

FUNCTION  <SNR>94_make_cache_current_buffer()
Called 15 times
Total time:   0.045711
 Self time:   0.000755

count  total (s)   self (s)
   15   0.001472   0.000152   let filetype = neocomplete#get_context_filetype(1)
                            
   15              0.000117   if !has_key(s:member_sources, bufnr('%'))
    2   0.000506   0.000060     call s:initialize_source(bufnr('%'), filetype)
    2              0.000002   endif
                            
   15   0.043517   0.000327   call s:make_cache_lines(bufnr('%'), filetype, getline(a:start, a:end))

FUNCTION  vimproc#util#is_mac()
Called 2 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    2              0.000005   return s:is_mac

FUNCTION  <SNR>99_complete_key()
Called 2 times
Total time:   0.000310
 Self time:   0.000056

count  total (s)   self (s)
    2   0.000293   0.000039   call neocomplete#helper#complete_configure()
                            
    2              0.000013   call feedkeys(a:key)

FUNCTION  <SNR>73_StopCursorTimer()
Called 277 times
Total time:   0.004294
 Self time:   0.004294

count  total (s)   self (s)
  277              0.000990     if s:cursor_timer != -1
  262              0.001245         call timer_stop(s:cursor_timer)
  262              0.000866         let s:cursor_timer = -1
  262              0.000254     endif

FUNCTION  <SNR>21_repo_dir()
Called 18 times
Total time:   0.000119
 Self time:   0.000119

count  total (s)   self (s)
   18              0.000113   return join([self.git_dir]+a:000,'/')

FUNCTION  <SNR>13_LoadIndent()
Called 4 times
Total time:   0.007288
 Self time:   0.003164

count  total (s)   self (s)
    4              0.000019     if exists("b:undo_indent")
    1              0.000031       exe b:undo_indent
    1              0.000008       unlet! b:undo_indent b:did_indent
    1              0.000001     endif
    4              0.000021     let s = expand("<amatch>")
    4              0.000010     if s != ""
    4              0.000011       if exists("b:did_indent")
    1              0.000003 	unlet b:did_indent
    1              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    8              0.000050       for name in split(s, '\.')
    4   0.007028   0.002904 	exe 'runtime! indent/' . name . '.vim'
    4              0.000018       endfor
    4              0.000005     endif

FUNCTION  neocomplete#complete#_get_complete_pos()
Called 6 times
Total time:   0.000130
 Self time:   0.000130

count  total (s)   self (s)
    6              0.000014   if empty(a:sources)
                                return -1
                              endif
                            
    6              0.000100   return min([col('.')] + map(copy(a:sources), 'v:val.neocomplete__context.complete_pos'))

FUNCTION  <SNR>43_use_sh()
Called 5 times
Total time:   0.000126
 Self time:   0.000126

count  total (s)   self (s)
    5              0.000028   let [shell, shellslash] = [&shell, &shellslash]
    5              0.000008   if s:is_win
                                set shell=cmd.exe
                                set noshellslash
                              else
    5              0.000043     set shell=sh
    5              0.000004   endif
    5              0.000012   return [shell, shellslash]

FUNCTION  neocomplete#cache#writefile()
Called 6 times
Total time:   0.004055
 Self time:   0.000258

count  total (s)   self (s)
    6   0.000078   0.000032   if neocomplete#util#is_sudo()
                                return
                              endif
                            
    6   0.000585   0.000049   let cache_dir = neocomplete#get_data_directory() . '/' . a:cache_dir
    6   0.003349   0.000134   return s:Cache.writefile(cache_dir, a:filename, a:list)

FUNCTION  neocomplete#init#is_enabled()
Called 83 times
Total time:   0.000295
 Self time:   0.000295

count  total (s)   self (s)
   83              0.000203   return s:is_enabled

FUNCTION  <SNR>21_can_diffoff()
Called 9 times
Total time:   0.000194
 Self time:   0.000194

count  total (s)   self (s)
    9              0.000166   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  <SNR>43_open()
Called 5 times
Total time:   0.298070
 Self time:   0.011699

count  total (s)   self (s)
    5   0.000811   0.000143   if stridx('edit', a:cmd) == 0 && s:fzf_fnamemodify(a:target, ':p') ==# s:fzf_expand('%:p')
                                return
                              endif
    5   0.297229   0.011526   execute a:cmd s:escape(a:target)

FUNCTION  <SNR>127_GroupLoclistItems()
Called 46 times
Total time:   0.001347
 Self time:   0.001347

count  total (s)   self (s)
   46              0.000128     let l:grouped_items = []
   46              0.000083     let l:last_lnum = -1
                            
   46              0.000093     for l:obj in a:loclist
                                    if l:obj.bufnr != a:buffer
                                        continue
                                    endif
                            
                                    " Create a new sub-List when we hit a new line.
                                    if l:obj.lnum != l:last_lnum
                                        call add(l:grouped_items, [])
                                    endif
                            
                                    call add(l:grouped_items[-1], l:obj)
                                    let l:last_lnum = l:obj.lnum
                                endfor
                            
   46              0.000106     return l:grouped_items

FUNCTION  <SNR>21_cpath()
Called 12 times
Total time:   0.000116
 Self time:   0.000116

count  total (s)   self (s)
   12              0.000054   if exists('+fileignorecase') && &fileignorecase
   12              0.000050     return tolower(a:path)
                              else
                                return a:path
                              endif

FUNCTION  <SNR>108_fdopen_pipes()
Called 24 times
Total time:   0.017124
 Self time:   0.003551

count  total (s)   self (s)
   24   0.017069   0.003496   return { 'eof' : 0, '__eof' : 0, 'is_valid' : 1, 'buffer' : [], 'fd' : a:fd, 'f_close' : s:funcref(a:f_close), 'close' : s:funcref('close'), 'read' : s:funcref(a:f_read), 'write' : s:funcref(a:f_write), 'read_line' : s:funcref('read_line'), 'read_lines' : s:funcref('read_lines'),}

FUNCTION  ale#events#SaveEvent()
Called 5 times
Total time:   0.059026
 Self time:   0.001522

count  total (s)   self (s)
    5   0.000394   0.000106     let l:should_lint = ale#Var(a:buffer, 'enabled') && g:ale_lint_on_save
                            
    5              0.000007     if l:should_lint
    5              0.000037         call setbufvar(a:buffer, 'ale_save_event_fired', 1)
    5              0.000005     endif
                            
    5   0.000177   0.000028     if ale#Var(a:buffer, 'fix_on_save')
                                    let l:will_fix = ale#fix#Fix('save_file')
                                    let l:should_lint = l:should_lint && !l:will_fix
                                endif
                            
    5   0.000107   0.000046     if l:should_lint && !ale#events#QuitRecently(a:buffer)
    5   0.057869   0.000863         call ale#Queue(0, 'lint_file', a:buffer)
    5              0.000092     endif

FUNCTION  <SNR>43_execute()
Called 5 times
Total time:  15.007442
 Self time:   1.368829

count  total (s)   self (s)
    5   0.000341   0.000067   call s:pushd(a:dict)
    5              0.000033   if has('unix') && !a:use_height
    5   0.598580   0.523148     silent! !clear 2> /dev/null
    5              0.000013   endif
    5              0.000309   let escaped = (a:use_height || s:is_win) ? a:command : escape(substitute(a:command, '\n', '\\n', 'g'), '%#!')
    5              0.000029   if has('gui_running')
                                let Launcher = get(a:dict, 'launcher', get(g:, 'Fzf_launcher', get(g:, 'fzf_launcher', s:launcher)))
                                let fmt = type(Launcher) == 2 ? call(Launcher, []) : Launcher
                                if has('unix')
                                  let escaped = "'".substitute(escaped, "'", "'\"'\"'", 'g')."'"
                                endif
                                let command = printf(fmt, escaped)
                              else
    5              0.000010     let command = escaped
    5              0.000003   endif
    5              0.000007   if s:is_win
                                let batchfile = s:fzf_tempname().'.bat'
                                call writefile(s:wrap_cmds(command), batchfile)
                                let command = batchfile
                                let a:temps.batchfile = batchfile
                                if has('nvim')
                                  let fzf = {}
                                  let fzf.dict = a:dict
                                  let fzf.temps = a:temps
                                  function! fzf.on_exit(job_id, exit_status, event) dict
                                    if s:present(self.dict, 'dir')
                                      execute 'lcd' s:escape(self.dict.dir)
                                    endif
                                    let lines = s:collect(self.temps)
                                    call s:callback(self.dict, lines)
                                  endfunction
                                  let cmd = 'start /wait cmd /c '.command
                                  call jobstart(cmd, fzf)
                                  return []
                                endif
                              elseif has('win32unix') && $TERM !=# 'cygwin'
                                let shellscript = s:fzf_tempname()
                                call writefile([command], shellscript)
                                let command = 'cmd.exe /C '.fzf#shellescape('set "TERM=" & start /WAIT sh -c '.shellscript)
                                let a:temps.shellscript = shellscript
                              endif
    5              0.000008   if a:use_height
                                let stdin = has_key(a:dict, 'source') ? '' : '< /dev/tty'
                                call system(printf('tput cup %d > /dev/tty; tput cnorm > /dev/tty; %s %s 2> /dev/tty', &lines, command, stdin))
                              else
    5  14.074723   0.514167     execute 'silent !'.command
    5              0.000010   endif
    5              0.000016   let exit_status = v:shell_error
    5              0.330023   redraw!
    5   0.002697   0.000346   return s:exit_handler(exit_status, command) ? s:collect(a:temps) : []

FUNCTION  <SNR>124_FindHistoryItem()
Called 76 times
Total time:   0.004596
 Self time:   0.002648

count  total (s)   self (s)
                                " Search backwards to find a matching job ID. IDs might be recycled,
                                " so finding the last one should be good enough.
  110   0.003379   0.001431     for l:obj in reverse(ale#history#Get(a:buffer))
  110              0.000288         if l:obj.job_id == a:job_id
   76              0.000205             return l:obj
                                    endif
   34              0.000059     endfor
                            
                                return {}

FUNCTION  neocomplete#is_multibyte_input()
Called 11 times
Total time:   0.000489
 Self time:   0.000489

count  total (s)   self (s)
   11              0.000476   return (exists('b:skk_on') && b:skk_on)   || (!g:neocomplete#enable_multibyte_completion         && char2nr(split(a:cur_text, '\zs')[-1]) > 0x80)

FUNCTION  neocomplete#filters#escape()
Called 5 times
Total time:   0.000130
 Self time:   0.000130

count  total (s)   self (s)
                              " Escape string for lua regexp.
    5              0.000121   return substitute(a:string, '[%\[\]().*+?^$-]', '%\0', 'g')

FUNCTION  neocomplete#complete_check()
Called 20 times
Total time:   0.001883
 Self time:   0.000220

count  total (s)   self (s)
   20   0.001867   0.000204   return neocomplete#helper#complete_check()

FUNCTION  ale#engine#RunLinters()
Called 32 times
Total time:   0.351899
 Self time:   0.023837

count  total (s)   self (s)
                                " Initialise the buffer information if needed.
   32   0.001076   0.000387     let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
   32   0.012927   0.000539     call s:StopCurrentJobs(a:buffer, a:should_lint_file)
   32   0.001836   0.000443     call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
   32   0.000987   0.000347     let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
   88              0.001314     for l:linter in a:linters
                                    " Only run lint_file linters if we should.
   56              0.000201         if !l:linter.lint_file || a:should_lint_file
   56   0.306415   0.006059             if s:RunLinter(a:buffer, l:linter)
                                            " If a single linter ran, we shouldn't clear everything.
   48              0.001088                 let l:can_clear_results = 0
   48              0.000331             endif
   56              0.000094         else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
                                        let l:can_clear_results = 0
                                    endif
   56              0.001109     endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
   32              0.000095     if l:can_clear_results
    8   0.011915   0.000148         call ale#engine#SetResults(a:buffer, [])
    8              0.000016     elseif l:new_buffer
    3   0.001002   0.000173         call s:AddProblemsFromOtherBuffers(a:buffer, a:linters)
    3              0.000003     endif

FUNCTION  neocomplete#cache#check_old_cache()
Called 7 times
Total time:   0.004493
 Self time:   0.000269

count  total (s)   self (s)
    7   0.001832   0.000112   let cache_dir = neocomplete#get_data_directory() . '/' . a:cache_dir
    7   0.002625   0.000121   return  s:Cache.check_old_cache(cache_dir, a:filename)

FUNCTION  <SNR>123_CreateTemporaryFileForJob()
Called 48 times
Total time:   0.049375
 Self time:   0.018637

count  total (s)   self (s)
   48              0.000190     if empty(a:temporary_file)
                                    " There is no file, so we didn't create anything.
                                    return 0
                                endif
                            
   48              0.000680     let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
   48              0.008406     call mkdir(l:temporary_directory, '', 0750)
                                " Automatically delete the directory later.
   48   0.011984   0.000690     call ale#engine#ManageDirectory(a:buffer, l:temporary_directory)
                                " Write the buffer out to a file.
   48              0.004848     let l:lines = getbufline(a:buffer, 1, '$')
   48   0.020980   0.001536     call ale#util#Writefile(a:buffer, l:lines, a:temporary_file)
                            
   48              0.000211     return 1

FUNCTION  <SNR>131_async_load()
Called 6 times
Total time:   0.163072
 Self time:   0.001074

count  total (s)   self (s)
    6   0.000349   0.000296   let vim_path = s:search_vim_path()
                            
    6              0.000270   if vim_path == '' || !executable(vim_path)
                                call neocomplete#async_cache#main(a:argv)
                              else
    6              0.000118     let args = [vim_path, '-u', 'NONE', '-i', 'NONE', '-n',       '-N', '-S', s:sdir.'/async_cache.vim'] + a:argv
    6   0.159156   0.000206     call vimproc#system_bg(args)
                                " call vimproc#system(args)
                                " call system(join(args))
    6              0.000006   endif
                            
    6   0.003091   0.000096   return neocomplete#cache#encode_name(a:cache_dir, a:filename)

FUNCTION  <SNR>108_convert_args()
Called 8 times
Total time:   0.009014
 Self time:   0.002902

count  total (s)   self (s)
    8              0.000026   if empty(a:args)
                                return []
                              endif
                            
    8   0.005709   0.001999   let args = map(copy(a:args), 'vimproc#util#iconv( v:val, &encoding, vimproc#util#systemencoding())')
                            
    8   0.000064   0.000048   if vimproc#util#is_windows() && !executable(a:args[0])
                                " Search from internal commands.
                                let internal_commands = [ 'copy', 'date', 'del', 'dir', 'echo', 'erase', 'for', 'ftype', 'if', 'md', 'mkdir', 'move', 'path', 'rd', 'ren', 'rename', 'rmdir', 'start', 'time', 'type', 'ver', 'vol']
                                let index = index(internal_commands, a:args[0], 0, 1)
                                if index >= 0
                                  " Use cmd.exe
                                  return ['cmd', '/c', args[0]] + args[1:]
                                endif
                              endif
                            
    8   0.001734   0.000129   let command_name = vimproc#get_command_name(a:args[0])
                            
    8   0.001318   0.000537   return map(vimproc#analyze_shebang(command_name), 'vimproc#util#iconv( v:val, &encoding, vimproc#util#systemencoding())') + args[1:]

FUNCTION  ale#events#EnterEvent()
Called 12 times
Total time:   0.001717
 Self time:   0.000901

count  total (s)   self (s)
                                " When entering a buffer, we are no longer quitting it.
   12              0.000566     call setbufvar(a:buffer, 'ale_quitting', 0)
   12              0.000101     let l:filetype = getbufvar(a:buffer, '&filetype')
   12              0.000081     call setbufvar(a:buffer, 'ale_original_filetype', l:filetype)
                            
   12   0.000926   0.000110     call s:LintOnEnter(a:buffer)

FUNCTION  <SNR>131_search_vim_path()
Called 6 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    6              0.000036   if exists('s:vim_path')
    6              0.000012     return s:vim_path
                              endif
                            
                              if !neocomplete#has_vimproc()
                                return ''
                              endif
                            
                              let paths = vimproc#get_command_name(v:progname, $PATH, -1)
                              if empty(paths)
                                if has('gui_macvim')
                                  " MacVim check.
                                  if !executable('/Applications/MacVim.app/Contents/MacOS/Vim')
                                    call neocomplete#print_error( 'You installed MacVim in not default directory!'. ' You must add MacVim installed path in $PATH.')
                                    let g:neocomplete#use_vimproc = 0
                                    return ''
                                  endif
                            
                                  let s:vim_path = '/Applications/MacVim.app/Contents/MacOS/Vim'
                                else
                                  call neocomplete#print_error( printf('Vim path : "%s" is not found.'.        ' You must add "%s" installed path in $PATH.',        v:progname, v:progname))
                                  let g:neocomplete#use_vimproc = 0
                                  return ''
                                endif
                              else
                                let base_path = neocomplete#util#substitute_path_separator( fnamemodify(paths[0], ':p:h'))
                            
                                let s:vim_path = base_path . '/vim'
                            
                                if !executable(s:vim_path) && neocomplete#util#is_mac()
                                  " Note: Search "Vim" instead of vim.
                                  let s:vim_path = base_path. '/Vim'
                                endif
                              endif
                            
                              return s:vim_path

FUNCTION  <SNR>94_initialize_source()
Called 2 times
Total time:   0.000446
 Self time:   0.000308

count  total (s)   self (s)
    2              0.000177   let path = (a:srcname=~ '^\d\+$') ? fnamemodify(bufname(a:srcname), ':p') : a:srcname
    2              0.000012   let filename = fnamemodify(path, ':t')
    2              0.000005   if filename == ''
                                let filename = '[No Name]'
                                let path .= '/[No Name]'
                              endif
                            
    2              0.000004   let ft = a:filetype
    2              0.000004   if ft == ''
                                let ft = 'nothing'
                              endif
                            
    2   0.000224   0.000086   let s:member_sources[a:srcname] = { 'member_cache' : {}, 'filetype' : ft, 'time' : getftime(path), 'keyword_pattern' : neocomplete#get_keyword_pattern(ft, s:source.name),}

FUNCTION  <SNR>108_read_pgroup()
Called 8 times
Total time:   0.609948
 Self time:   0.001072

count  total (s)   self (s)
    8              0.000074   let number = get(a:000, 0, -1)
    8              0.000031   let timeout = get(a:000, 1, s:read_timeout)
                            
    8              0.000015   let output = ''
                            
    8              0.000013   if !self.fd.eof
    8   0.607418   0.000091     let output = self.fd.read(number, timeout)
    8              0.000006   endif
                            
    8              0.000029   if self.proc.current_proc.stdout.eof && self.proc.current_proc.stderr.eof
                                " Get status.
    2   0.001747   0.000198     let [cond, status] = self.proc.current_proc.waitpid()
                            
    2              0.000008     if empty(self.proc.statements) || (self.proc.condition ==# 'true' && status) || (self.proc.condition ==# 'false' && !status)
    2              0.000003       let self.proc.statements = []
                            
                                  " Caching status.
    2              0.000004       let self.proc.cond = cond
    2              0.000004       let self.proc.status = status
    2              0.000006       if has_key(self.proc.current_proc, 'pipe_status')
    2              0.000012         let self.proc.pipe_status = self.proc.current_proc.pipe_status
    2              0.000001       endif
    2              0.000000     else
                                  " Initialize next statement.
                            
                                  let cwd = getcwd()
                                  try
                                    call vimproc#util#cd(self.proc.statements[0].cwd)
                            
                                    let proc = vimproc#plineopen3( self.proc.statements[0].statement)
                                  finally
                                    call vimproc#util#cd(cwd)
                                  endtry
                                  let self.proc.current_proc = proc
                            
                                  let self.pid = proc.pid
                                  let self.pid_list = proc.pid_list
                                  let self.proc.pid = proc.pid
                                  let self.proc.pid_list = proc.pid_list
                                  let self.proc.condition = self.proc.statements[0].condition
                                  let self.proc.statements = self.proc.statements[1:]
                            
                                  let self.proc.stdin = s:fdopen_pgroup( self.proc, proc.stdin, 'vp_pgroup_close', 'read_pgroup', 'write_pgroup')
                                  let self.proc.stdout = s:fdopen_pgroup( self.proc, proc.stdout, 'vp_pgroup_close', 'read_pgroup', 'write_pgroup')
                                  let self.proc.stderr = s:fdopen_pgroup( self.proc, proc.stderr, 'vp_pgroup_close', 'read_pgroup', 'write_pgroup')
                                endif
    2              0.000002   endif
                            
    8              0.000016   if self.proc.current_proc.stdout.eof
    4              0.000005     let self.proc.stdout.eof = 1
    4              0.000006     let self.proc.stdout.__eof = 1
    4              0.000002   endif
                            
    8              0.000013   if self.proc.current_proc.stderr.eof
    2              0.000002     let self.proc.stderr.eof = 1
    2              0.000002     let self.proc.stderr.__eof = 1
    2              0.000001   endif
                            
    8              0.000014   return output

FUNCTION  <SNR>134_multiline_import()
Called 15 times
Total time:   0.000753
 Self time:   0.000753

count  total (s)   self (s)
   15              0.000183   if a:cur_text =~# '^\s\+[[:alpha:],(]'
                                let mod = s:dangling_import(getpos('.')[1])
                                if mod != ''
                                  if a:type == 'pos'
                                    let l:idx = matchend(a:cur_text, '^\s\+\%(\ze\%([[:alpha:]]\|([!#$%&*+./<=>?@\\^|~-]\)\|[,(]\s*\)')
                                    if l:idx != -1
                                      return [0, max([matchend(a:cur_text, '^.*,\s*', l:idx), l:idx])]
                                    else
                                      return [0, -1]
                                    endif
                                  else " 'list'
                                    let l:list = []
                                    for [l:sym, l:dict] in items(necoghc#browse(l:mod))
                                      call add(l:list, { 'word': l:sym, 'menu': s:to_desc(l:mod . '.' . l:sym, l:dict) })
                                    endfor
                                    return [0, l:list]
                                  endif
                                endif
                              endif
   15              0.000029   return [1, 0]

FUNCTION  <SNR>108_close()
Called 80 times
Total time:   0.019735
 Self time:   0.000486

count  total (s)   self (s)
   80              0.000131   if self.is_valid
   72   0.006287   0.000849     call self.f_close()
   72              0.000069   endif
                            
   80              0.000134   let self.is_valid = 0
   80              0.000103   let self.eof = 1
   80              0.000102   let self.__eof = 1

FUNCTION  <SNR>43_pushd()
Called 5 times
Total time:   0.000274
 Self time:   0.000149

count  total (s)   self (s)
    5   0.000184   0.000059   if s:present(a:dict, 'dir')
                                let cwd = s:fzf_getcwd()
                                if get(a:dict, 'prev_dir', '') ==# cwd
                                  return 1
                                endif
                                let a:dict.prev_dir = cwd
                                execute 'lcd' s:escape(a:dict.dir)
                                let a:dict.dir = s:fzf_getcwd()
                                return 1
                              endif
    5              0.000006   return 0

FUNCTION  <SNR>94_make_cache_lines()
Called 15 times
Total time:   0.043190
 Self time:   0.043051

count  total (s)   self (s)
   15              0.000050   let filetype = a:filetype
   15              0.000054   if !has_key(s:member_sources, a:srcname)
                                call s:initialize_source(a:srcname, filetype)
                              endif
                            
   15              0.000130   let prefix = get(g:neocomplete#sources#member#prefix_patterns, filetype, get(g:neocomplete#sources#member#prefix_patterns, '_', ''))
   15              0.000024   if prefix == ''
                                return
                              endif
   15              0.000049   let source = s:member_sources[a:srcname]
   15   0.000268   0.000129   let member_pattern = s:get_member_pattern(filetype)
   15              0.000069   let prefix_pattern = member_pattern . '\m\%(' . prefix . '\m\)'
   15              0.000129   let keyword_pattern = prefix_pattern . member_pattern
                            
                              " Cache member pattern.
  152              0.000267   for line in a:lines
  137              0.006346     let match = match(line, keyword_pattern)
                            
  301              0.000434     while match >= 0 "{{{
  164              0.004296       let match_str = matchstr(line, '^'.keyword_pattern, match)
                            
                                  " Next match.
  164              0.004665       let match = matchend(line, prefix_pattern, match)
                            
  164              0.015210       let member_name = matchstr(match_str, member_pattern . '$')
  164              0.000338       if member_name == ''
   60              0.000148         continue
                                  endif
  104              0.000950       let var_name = match_str[ : -len(member_name)-1]
                            
  104              0.000342       if !has_key(source.member_cache, var_name)
   17              0.000044         let source.member_cache[var_name] = {}
   17              0.000008       endif
  104              0.000388       if !has_key(source.member_cache[var_name], member_name)
   19              0.000050         let source.member_cache[var_name][member_name] = 1
   19              0.000010       endif
                            
  104              0.002753       let match_str = matchstr(var_name, '^'.keyword_pattern)
  104              0.000144     endwhile"}}}
  137              0.000200   endfor

FUNCTION  <SNR>108_vp_pipe_close()
Called 24 times
Total time:   0.005438
 Self time:   0.000531

count  total (s)   self (s)
                              " echomsg 'close:'.self.fd
   24              0.000056   if self.fd != 0
   24   0.005223   0.000316     call s:libcall('vp_pipe_close', [self.fd])
   24              0.000055     let self.fd = 0
   24              0.000023   endif

FUNCTION  <SNR>108_garbage_collect()
Called 15 times
Total time:   1.505919
 Self time:   0.540965

count  total (s)   self (s)
 3558              0.012042   for pid in values(s:bg_processes)
                                " Check processes.
 3543              0.003380     try
 3543   0.997595   0.032641       let [cond, _] = s:libcall('vp_waitpid', [pid])
                                  " echomsg string([pid, cond, _])
                                  if cond !=# 'run' || a:is_force
                                    if cond !=# 'exit'
                                      " Kill process.
                                      call vimproc#kill(pid, g:vimproc#SIGTERM)
                                    endif
                            
                                    if vimproc#util#is_windows()
                                      call s:libcall('vp_close_handle', [pid])
                                    endif
                                    call remove(s:bg_processes, pid)
                                  endif
                                catch
                                  " Ignore error.
 3543              0.008536     endtry
 3543              0.005931   endfor

FUNCTION  neocomplete#helper#complete_configure()
Called 2 times
Total time:   0.000254
 Self time:   0.000226

count  total (s)   self (s)
    2              0.000031   set completeopt-=menu
    2              0.000010   set completeopt-=longest
    2              0.000006   set completeopt+=menuone
                            
                              " Set options.
    2   0.000039   0.000021   let neocomplete = neocomplete#get_current_neocomplete()
    2              0.000005   let neocomplete.completeopt = &completeopt
                            
    2   0.000132   0.000122   if neocomplete#util#is_complete_select() && &completeopt !~# 'noinsert\|noselect'
                                if g:neocomplete#enable_auto_select
                                  set completeopt-=noselect
                                  set completeopt+=noinsert
                                else
                                  set completeopt-=noinsert
                                  set completeopt+=noselect
                                endif
                              endif

FUNCTION  <SNR>108_system()
Called 2 times
Total time:   0.624385
 Self time:   0.001189

count  total (s)   self (s)
    2              0.000007   let s:last_status = 0
    2              0.000003   let s:last_errmsg = ''
                            
    2              0.000005   if empty(a:cmdline)
                                return ''
                              endif
                            
                              " Open pipe.
    2              0.000002   try
    2   0.012157   0.000078     let subproc = (type(a:cmdline[0]) == type('')) ? vimproc#popen3(a:cmdline) : a:is_pty ? vimproc#ptyopen(a:cmdline): vimproc#pgroup_open(a:cmdline)
    2              0.000004   catch
                                call s:print_error(v:exception)
                                let s:last_status = 1
                                let s:last_errmsg = v:exception
                                return ''
                              endtry
                            
    2              0.000004   let outbuf = []
    2              0.000002   let errbuf = []
                            
    2              0.000002   try
    2              0.000003     if a:input != ''
                                  " Write input.
                                  call subproc.stdin.write(a:input)
                                endif
                            
    2              0.000005     if a:timeout > 0 && has('reltime') && v:version >= 702
                                  let start = reltime()
                                  let deadline = a:timeout
                                  let timeout = a:timeout / 2
                                else
    2              0.000002       let start = 0
    2              0.000002       let deadline = 0
    2              0.000004       let timeout = s:read_timeout
    2              0.000001     endif
                            
    2              0.000002     if !a:is_passwd
    2   0.000996   0.000020       call subproc.stdin.close()
    2              0.000002     endif
                            
    6              0.000016     while !subproc.stdout.eof || !subproc.stderr.eof
    4              0.000006       if deadline "{{{
                                    " Check timeout.
                                    let tick = reltimestr(reltime(start))
                                    let elapse = str2nr(tick[:-8] . tick[-6:-4], 10)
                                    if deadline <= elapse && !subproc.stdout.eof
                                      " Kill process.
                                      throw 'vimproc: vimproc#system(): Timeout.'
                                    endif
                                    let timeout = (deadline - elapse) / 2
                                  endif"}}}
                            
    4              0.000007       if !subproc.stdout.eof "{{{
    4   0.398789   0.000120         let out = subproc.stdout.read(-1, timeout)
                            
    4              0.000011         if a:is_passwd && out =~# g:vimproc_password_pattern
                                      redraw
                                      echo out
                            
                                      " Password input.
                                      set imsearch=0
                                      let in = vimproc#util#iconv(inputsecret('Input Secret : ')."\<NL>", &encoding, vimproc#util#termencoding())
                            
                                      call subproc.stdin.write(in)
                                    else
    4              0.000014           let outbuf += [out]
    4              0.000003         endif
    4              0.000004       endif"}}}
                            
    4              0.000007       if !subproc.stderr.eof "{{{
    4   0.211494   0.000215         let out = subproc.stderr.read(-1, timeout)
                            
    4              0.000009         if a:is_passwd && out =~# g:vimproc_password_pattern
                                      redraw
                                      echo out
                            
                                      " Password input.
                                      set imsearch=0
                                      let in = vimproc#util#iconv(inputsecret('Input Secret : ') . "\<NL>", &encoding, vimproc#util#termencoding())
                            
                                      call subproc.stdin.write(in)
                                    else
    4              0.000011           let outbuf += [out]
    4              0.000013           let errbuf += [out]
    4              0.000005         endif
    4              0.000006       endif"}}}
    4              0.000004     endwhile
    2              0.000002   catch
                                call subproc.kill(g:vimproc#SIGTERM)
                            
                                if v:exception !~ '^Vim:Interrupt'
                                  call s:print_error(v:throwpoint)
                                  call s:print_error(v:exception)
                                endif
                              finally
    2              0.000008     let output = join(outbuf, '')
    2              0.000018     let s:last_errmsg = join(errbuf, '')
                            
    2   0.000217   0.000030     call subproc.waitpid()
    2              0.000001   endtry
                            
                              " Newline convert.
    2   0.000032   0.000026   if vimproc#util#is_mac()
    2              0.000090     let output = substitute(output, '\r\n\@!', '\n', 'g')
    2              0.000006   elseif has('win32') || has('win64')
                                let output = substitute(output, '\r\n', '\n', 'g')
                              endif
                            
    2              0.000006   return output

FUNCTION  <SNR>95_get_complete_pos()
Called 11 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
   11              0.000033   if empty(a:complete_results)
   11              0.000013     return -1
                              endif
                            
                              let complete_pos = col('.')
                              for result in values(a:complete_results)
                                if complete_pos > result.complete_pos
                                  let complete_pos = result.complete_pos
                                endif
                              endfor
                            
                              return complete_pos

FUNCTION  <SNR>123_RunLinter()
Called 56 times
Total time:   0.300356
 Self time:   0.010283

count  total (s)   self (s)
   56              0.000276     if !empty(a:linter.lsp)
                                    return s:CheckWithLSP(a:buffer, a:linter)
                                else
   56   0.005988   0.001778         let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
   56   0.003872   0.001134         if ale#engine#IsExecutable(a:buffer, l:executable)
   48   0.289673   0.006548             return s:InvokeChain(a:buffer, a:linter, 0, [])
                                    endif
    8              0.000007     endif
                            
    8              0.000010     return 0

FUNCTION  neocomplete#sources#buffer#make_cache_current_line()
Called 5 times
Total time:   0.028330
 Self time:   0.000269

count  total (s)   self (s)
    5   0.000443   0.000030   if neocomplete#is_locked()
                                return
                              endif
                            
                              " let start = reltime()
    5   0.027819   0.000171   call s:make_cache_current_buffer( max([1, line('.') - winline()]), min([line('$'), line('.') + winheight(0) - winline()]))
                              " echomsg reltimestr(reltime(start))

FUNCTION  ale#engine#Cleanup()
Called 4 times
Total time:   0.007952
 Self time:   0.000245

count  total (s)   self (s)
                                " Don't bother with cleanup code when newer NeoVim versions are exiting.
    4              0.000026     if get(v:, 'exiting', v:null) isnot v:null
                                    return
                                endif
                            
    4              0.000032     if !has_key(g:ale_buffer_info, a:buffer)
                                    return
                                endif
                            
    4   0.007779   0.000072     call ale#engine#RunLinters(a:buffer, [], 1)
                            
    4              0.000086     call remove(g:ale_buffer_info, a:buffer)

FUNCTION  <SNR>123_StopCurrentJobs()
Called 32 times
Total time:   0.012388
 Self time:   0.003292

count  total (s)   self (s)
   32              0.000300     let l:info = get(g:ale_buffer_info, a:buffer, {})
   32              0.000086     let l:new_job_list = []
   32              0.000083     let l:new_active_linter_list = []
                            
   42              0.000277     for l:job_id in get(l:info, 'job_list', [])
   10              0.000162         let l:job_info = get(s:job_info_map, l:job_id, {})
                            
   10              0.000040         if !empty(l:job_info)
   10              0.000037             if a:include_lint_file_jobs || !l:job_info.linter.lint_file
   10   0.009273   0.000177                 call ale#job#Stop(l:job_id)
   10              0.000090                 call remove(s:job_info_map, l:job_id)
   10              0.000012             else
                                            call add(l:new_job_list, l:job_id)
                                            " Linters with jobs still running are still active.
                                            call add(l:new_active_linter_list, l:job_info.linter.name)
                                        endif
   10              0.000010         endif
   10              0.000036     endfor
                            
                                " Remove duplicates from the active linter list.
   32              0.000175     call uniq(sort(l:new_active_linter_list))
                            
                                " Update the List, so it includes only the jobs we still need.
   32              0.000208     let l:info.job_list = l:new_job_list
                                " Update the active linter list, clearing out anything not running.
   32              0.000311     let l:info.active_linter_list = l:new_active_linter_list

FUNCTION  neocomplete#init#_sources()
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000007   if !exists('s:loaded_source_files')
                                " Initialize.
                                let s:loaded_source_files = {}
                                let s:loaded_all_sources = 0
                                let s:runtimepath_save = ''
                              endif
                            
                              " Initialize sources table.
    1              0.000009   if s:loaded_all_sources && &runtimepath ==# s:runtimepath_save
    1              0.000002     return
                              endif
                            
                              let runtimepath_save = neocomplete#util#split_rtp(s:runtimepath_save)
                              let runtimepath = neocomplete#util#join_rtp( filter(neocomplete#util#split_rtp(), 'index(runtimepath_save, v:val) < 0'))
                              let sources = neocomplete#variables#get_sources()
                            
                              for name in filter(copy(a:names), '!has_key(sources, v:val)')
                                " Search autoload.
                                for source_name in map(filter(split(globpath(runtimepath, 'autoload/neocomplete/sources/*.vim'), '\n'), "index(g:neocomplete#ignore_source_files,        fnamemodify(v:val, ':t')) < 0"), "fnamemodify(v:val, ':t:r')")
                                  if has_key(s:loaded_source_files, source_name)
                                    continue
                                  endif
                            
                                  let s:loaded_source_files[source_name] = 1
                            
                                  let source = neocomplete#sources#{source_name}#define()
                                  if empty(source)
                                    " Ignore.
                                    continue
                                  endif
                            
                                  call neocomplete#define_source(source)
                                endfor
                            
                                if name == '_'
                                  let s:loaded_all_sources = 1
                                  let s:runtimepath_save = &runtimepath
                                endif
                              endfor

FUNCTION  ale#util#StartPartialTimer()
Called 33 times
Total time:   0.001111
 Self time:   0.001111

count  total (s)   self (s)
   33              0.000418     let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
   33              0.000554     let s:partial_timers[l:timer_id] = [a:callback, a:args]
                            
   33              0.000065     return l:timer_id

FUNCTION  <SNR>136_merge_opts()
Called 10 times
Total time:   0.001182
 Self time:   0.000607

count  total (s)   self (s)
   10              0.000040   if empty(a:eopts)
    5              0.000008     return
                              endif
    5              0.000022   if has_key(a:dict, 'options')
    5              0.000043     if type(a:dict.options) == s:TYPE.list && type(a:eopts) == s:TYPE.list
                                  call extend(a:dict.options, a:eopts)
                                else
    5   0.000978   0.000403       let a:dict.options = join(map([a:dict.options, a:eopts], 'type(v:val) == s:TYPE.list ? join(map(copy(v:val), "fzf#shellescape(v:val)")) : v:val'))
    5              0.000007     endif
    5              0.000005   else
                                let a:dict.options = a:eopts
                              endif

FUNCTION  <SNR>43_exit_handler()
Called 5 times
Total time:   0.000196
 Self time:   0.000196

count  total (s)   self (s)
    5              0.000035   if a:code == 130
                                return 0
                              elseif a:code > 1
                                call s:error('Error running ' . a:command)
                                if !empty(a:000)
                                  sleep
                                endif
                                return 0
                              endif
    5              0.000008   return 1

FUNCTION  <SNR>108_funcref()
Called 536 times
Total time:   0.024274
 Self time:   0.008169

count  total (s)   self (s)
  536   0.023616   0.007511   return function(s:SID_PREFIX().a:funcname)

FUNCTION  <SNR>108_vp_pipe_open()
Called 8 times
Total time:   0.084732
 Self time:   0.010254

count  total (s)   self (s)
    8              0.000019   try
    8   0.000058   0.000040     if vimproc#util#is_windows()
                                  let cmdline = s:quote_arg(substitute(a:argv[0], '/', '\', 'g'))
                                  for arg in a:argv[1:]
                                    let cmdline .= ' ' . s:quote_arg(arg)
                                  endfor
                                  let [pid; fdlist] = s:libcall('vp_pipe_open', [a:npipe, a:hstdin, a:hstdout, a:hstderr, cmdline])
                                else
    8   0.083397   0.008937       let [pid; fdlist] = s:libcall('vp_pipe_open', [a:npipe, a:hstdin, a:hstdout, a:hstderr, len(a:argv)] + a:argv)
    8              0.000200     endif
    8              0.000018   catch
                                call s:print_error(v:throwpoint)
                                call s:print_error(v:exception)
                                call s:print_error( 'Error occurred in calling s:vp_pipe_open()')
                                call s:print_error(printf( 'a:argv = %s', string(a:argv)))
                                call s:print_error(printf( 'original a:argv = %s', vimproc#util#iconv(   string(a:argv), vimproc#util#systemencoding(), &encoding)))
                              endtry
                            
    8              0.000047   if a:npipe != len(fdlist)
                                call s:print_error(printf( 'a:npipe = %d, a:argv = %s', a:npipe, string(a:argv)))
                                call s:print_error(printf( 'pid = %d, fdlist = %s', pid, string(fdlist)))
                                echoerr 'Bug behavior is detected!: ' . pid
                              endif
                            
    8              0.000136   return [pid] + fdlist

FUNCTION  neocomplete#helper#get_cur_text()
Called 19 times
Total time:   0.003464
 Self time:   0.003307

count  total (s)   self (s)
   19   0.000265   0.000108   let neocomplete = neocomplete#get_current_neocomplete()
   19              0.000072   let is_skip_char = get(a:000, 0, 0)
   19              0.000060   let mode = mode()
   19              0.000062   if neocomplete.event ==# 'InsertEnter'
    3              0.000005     let mode = 'i'
    3              0.000002   endif
                            
   19              0.001068   let cur_text = (mode ==# 'i' ?   (col('.')-1) : col('.')) >= len(getline('.')) ?      getline('.') :      matchstr(getline('.'),         '^.*\%' . (mode ==# 'i' && !is_skip_char ?                    col('.') : col('.') - 1)         . 'c' . (mode ==# 'i' ? '' : '.'))
                            
   19              0.000612   if cur_text =~ '^.\{-}\ze\S\+$'
   15              0.000366     let complete_str = matchstr(cur_text, '\S\+$')
   15              0.000489     let cur_text = matchstr(cur_text, '^.\{-}\ze\S\+$')
   15              0.000018   else
    4              0.000008     let complete_str = ''
    4              0.000003   endif
                            
   19              0.000044   if neocomplete.event ==# 'InsertCharPre'
                                let complete_str .= v:char
                              endif
                            
   19              0.000066   let neocomplete.cur_text = cur_text . complete_str
                            
                              " Save cur_text.
   19              0.000035   return neocomplete.cur_text

FUNCTION  vimproc#util#cd()
Called 16 times
Total time:   0.006310
 Self time:   0.006310

count  total (s)   self (s)
   16              0.006295   execute (haslocaldir() ? 'lcd' : 'cd') fnameescape(a:path)

FUNCTION  neocomplete#complete#_set_results_pos()
Called 11 times
Total time:   0.046217
 Self time:   0.009653

count  total (s)   self (s)
                              " Initialize sources.
   11   0.000189   0.000073   let neocomplete = neocomplete#get_current_neocomplete()
                            
   11   0.000273   0.000055   let filetype = neocomplete#get_context_filetype()
   11   0.000600   0.000097   let sources = (a:0 > 0) ? a:1 : (filetype ==# neocomplete.sources_filetype) ? neocomplete.sources : neocomplete#helper#get_sources_list()
                            
   11              0.000054   let pos = winsaveview()
                            
                              " Try source completion. "{{{
   11              0.000021   let complete_sources = []
   88   0.004935   0.000730   for source in filter(values(sources), 'neocomplete#helper#is_enabled_source(v:val, filetype)')
   77              0.000125     if !source.loaded
                                  call neocomplete#helper#call_hook(source, 'on_init', {})
                                  let source.loaded = 1
                                endif
                            
   77              0.000201     let context = source.neocomplete__context
   77              0.000286     let context.input = a:cur_text
   77              0.000182     let context.filetype = filetype
   77   0.002096   0.000712     let context.filetypes = neocomplete#context_filetype#filetypes()
                            
   77              0.000086     try
   77   0.031735   0.002035       let complete_pos = s:use_previous_result(source, context) ? context.prev_complete_pos : has_key(source, 'get_complete_position') ? source.get_complete_position(context) : neocomplete#helper#match_word(context.input,    neocomplete#get_keyword_pattern_end(filetype, source.name))[0]
   77              0.000103     catch
                                  call neocomplete#print_error(v:throwpoint)
                                  call neocomplete#print_error(v:exception)
                                  call neocomplete#print_error( 'Error occurred in source''s get_complete_position()!')
                                  call neocomplete#print_error( 'Source name is ' . source.name)
                                  return complete_sources
                                finally
   77              0.000527       if winsaveview() != pos
                                    call winrestview(pos)
                                  endif
   77              0.000090     endtry
                            
   77              0.000104     if complete_pos < 0
   51              0.000104       let context.complete_pos = -1
   51              0.000106       let context.complete_str = ''
   51              0.000125       continue
                                endif
                            
   26              0.000114     let complete_str = context.input[complete_pos :]
   26   0.001111   0.000673     if neocomplete#is_auto_complete() && (source.input_pattern == '' ||  context.input !~# '\%(' . source.input_pattern.'\m\)$') && len(complete_str) < source.min_pattern_length
                                  " Skip.
   10              0.000028       let context.complete_pos = -1
   10              0.000028       let context.complete_str = ''
   10              0.000013       continue
                                endif
                            
   16              0.000032     let context.complete_pos = complete_pos
   16              0.000032     let context.complete_str = complete_str
   16              0.000053     call add(complete_sources, source)
   16              0.000021   endfor
                              "}}}
                            
   11              0.000022   return complete_sources

FUNCTION  <SNR>43_fzf_tempname()
Called 10 times
Total time:   0.000357
 Self time:   0.000091

count  total (s)   self (s)
   10   0.000348   0.000082   return s:fzf_call('tempname')

FUNCTION  neocomplete#helper#get_sources_list()
Called 1 time
Total time:   0.000503
 Self time:   0.000262

count  total (s)   self (s)
    1   0.000034   0.000009   let filetype = neocomplete#get_context_filetype()
                            
    1              0.000024   let source_names = exists('b:neocomplete_sources') ? b:neocomplete_sources : get(a:000, 0,   get(g:neocomplete#sources, filetype,     get(g:neocomplete#sources, '_', ['_'])))
    1   0.000067   0.000038   call neocomplete#init#_sources(source_names)
                            
    1   0.000113   0.000041   let all_sources = neocomplete#available_sources()
    1              0.000003   let sources = {}
    1              0.000005   for source_name in source_names
    1              0.000003     if source_name ==# '_'
                                  " All sources.
    1              0.000002       let sources = all_sources
    1              0.000002       break
                                endif
                            
                                if !has_key(all_sources, source_name)
                                  call neocomplete#print_warning(printf( 'Invalid source name "%s" is given.', source_name))
                                  continue
                                endif
                            
                                let sources[source_name] = all_sources[source_name]
                              endfor
                            
    1   0.000022   0.000008   let neocomplete = neocomplete#get_current_neocomplete()
    1   0.000192   0.000091   let neocomplete.sources = filter(sources, "   empty(v:val.filetypes) ||   neocomplete#helper#check_filetype(v:val.filetypes)")
    1              0.000005   let neocomplete.sources_filetype = neocomplete.context_filetype
                            
    1              0.000003   return neocomplete.sources

FUNCTION  ale#sign#FindCurrentSigns()
Called 46 times
Total time:   0.008803
 Self time:   0.001090

count  total (s)   self (s)
   46   0.002514   0.000539     let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
   46   0.006208   0.000470     return ale#sign#ParseSigns(l:line_list)

FUNCTION  neocomplete#sources#member#remake_cache()
Called 4 times
Total time:   0.000244
 Self time:   0.000142

count  total (s)   self (s)
    4   0.000163   0.000061   if !neocomplete#is_enabled()
                                call neocomplete#initialize()
                              endif
                            
    4              0.000038   if get(g:neocomplete#sources#member#prefix_patterns, a:filetype, '') == ''
    4              0.000006     return
                              endif
                            
                              for dictionary in filter(map(neocomplete#sources#dictionary#get_dictionaries(a:filetype),  "neocomplete#util#substitute_path_separator(      fnamemodify(v:val, ':p'))"), "filereadable(v:val) && (!has_key(s:member_sources, v:val)    || getftime(v:val) > s:member_sources[v:val].time)")
                                call s:make_cache_lines(dictionary, a:filetype, readfile(dictionary))
                              endfor

FUNCTION  fzf#wrap()
Called 5 times
Total time:   0.002304
 Self time:   0.001528

count  total (s)   self (s)
    5              0.000023   let args = ['', {}, 0]
    5              0.000059   let expects = map(copy(args), 'type(v:val)')
    5              0.000008   let tidx = 0
   20              0.000051   for arg in copy(a:000)
   15              0.000074     let tidx = index(expects, type(arg), tidx)
   15              0.000023     if tidx < 0
                                  throw 'Invalid arguments (expected: [name string] [opts dict] [fullscreen boolean])'
                                endif
   15              0.000048     let args[tidx] = arg
   15              0.000027     let tidx += 1
   15              0.000023     unlet arg
   15              0.000029   endfor
    5              0.000021   let [name, opts, bang] = args
                            
    5              0.000016   if len(name)
    5              0.000016     let opts.name = name
    5              0.000005   end
                            
                              " Layout: g:fzf_layout (and deprecated g:fzf_height)
    5              0.000006   if bang
                                for key in s:layout_keys
                                  if has_key(opts, key)
                                    call remove(opts, key)
                                  endif
                                endfor
                              elseif !s:has_any(opts, s:layout_keys)
    5              0.000036     if !exists('g:fzf_layout') && exists('g:fzf_height')
                                  let opts.down = g:fzf_height
                                else
    5   0.000267   0.000089       let opts = extend(opts, s:validate_layout(get(g:, 'fzf_layout', s:default_layout)))
    5              0.000005     endif
    5              0.000002   endif
                            
                              " Colors: g:fzf_colors
    5   0.000307   0.000125   let opts.options = s:defaults() .' '. s:evaluate_opts(get(opts, 'options', ''))
                            
                              " History: g:fzf_history_dir
    5              0.000041   if len(name) && len(get(g:, 'fzf_history_dir', ''))
                                let dir = s:fzf_expand(g:fzf_history_dir)
                                if !isdirectory(dir)
                                  call mkdir(dir, 'p')
                                endif
                                let history = fzf#shellescape(dir.'/'.name)
                                let opts.options = join(['--history', history, opts.options])
                              endif
                            
                              " Action: g:fzf_action
    5   0.000194   0.000041   if !s:has_any(opts, ['sink', 'sink*'])
    5              0.000029     let opts._action = get(g:, 'fzf_action', s:default_action)
    5              0.000090     let opts.options .= ' --expect='.join(keys(opts._action), ',')
    5              0.000017     function! opts.sink(lines) abort
                                  return s:common_sink(self._action, a:lines)
                                endfunction
    5              0.000032     let opts['sink*'] = remove(opts, 'sink')
    5              0.000013   endif
                            
    5              0.000018   return opts

FUNCTION  <SNR>108_vp_pipe_read()
Called 8 times
Total time:   0.605821
 Self time:   0.000202

count  total (s)   self (s)
    8              0.000023   if self.fd == 0
                                return ['', 1]
                              endif
                            
    8   0.605746   0.000127   let [hd, eof] = s:libcall_raw_read('vp_pipe_read', [self.fd, a:number, a:timeout])
    8              0.000019   return [hd, eof]

FUNCTION  neocomplete#cache#async_load_from_file()
Called 7 times
Total time:   0.178216
 Self time:   0.001283

count  total (s)   self (s)
    7   0.004870   0.000322   if !neocomplete#cache#check_old_cache(a:cache_dir, a:filename) || neocomplete#util#is_sudo()
    1   0.000270   0.000010     return neocomplete#cache#encode_name(a:cache_dir, a:filename)
                              endif
                            
    6   0.003459   0.000083   let pattern_file_name = neocomplete#cache#encode_name('keyword_patterns', a:filename)
    6   0.001683   0.000061   let cache_name = neocomplete#cache#encode_name(a:cache_dir, a:filename)
                            
                              " Create pattern file.
    6   0.004149   0.000094   call neocomplete#cache#writefile( 'keyword_patterns', a:filename, [a:pattern])
                            
                              " args: funcname, outputname, filename pattern mark
                              "       minlen maxlen encoding
    6              0.000199   let fileencoding = &fileencoding == '' ? &encoding : &fileencoding
    6              0.000063   let argv = [  'load_from_file', cache_name, a:filename, pattern_file_name, a:mark,  g:neocomplete#min_keyword_length, fileencoding ]
    6   0.163403   0.000331   return s:async_load(argv, a:cache_dir, a:filename)

FUNCTION  <SNR>128_SetListsImpl()
Called 46 times
Total time:   0.017864
 Self time:   0.010228

count  total (s)   self (s)
   46              0.003388     let l:title = expand('#' . a:buffer . ':p')
                            
   46              0.000120     if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
                                elseif g:ale_set_loclist
                                    " If windows support is off, bufwinid() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but is better than nothing.
   46   0.001240   0.000683         let l:win_id = s:BufWinId(a:buffer)
                            
   46              0.000261         if has('nvim')
                                        call setloclist(l:win_id, s:FixList(a:loclist), ' ', l:title)
                                    else
   46   0.001997   0.000636             call setloclist(l:win_id, s:FixList(a:loclist))
   46              0.000359             call setloclist(l:win_id, [], 'r', {'title': l:title})
   46              0.000043         endif
   46              0.000042     endif
                            
                                " Open a window to show the problems if we need to.
                                "
                                " We'll check if the current buffer's List is not empty here, so the
                                " window will only be opened if the current buffer has problems.
   46   0.003050   0.000389     if s:ShouldOpen(a:buffer) && !empty(a:loclist)
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                                    let l:reset_visual_selection = l:mode is? 'v' || l:mode is# "\<c-v>"
                                    let l:reset_character_selection = l:mode is? 's' || l:mode is# "\<c-s>"
                            
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    if l:reset_visual_selection || l:reset_character_selection
                                        " If we were in a selection mode before, select the last selection.
                                        normal! gv
                            
                                        if l:reset_character_selection
                                            " Switch back to Select mode, if we were in that.
                                            normal! "\<c-g>"
                                        endif
                                    endif
                                endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
   46   0.001190   0.000294     if !ale#engine#IsCheckingBuffer(a:buffer)
   25   0.002349   0.000188         call s:CloseWindowIfNeeded(a:buffer)
   25              0.000018     endif

FUNCTION  ale#Lint()
Called 28 times
Total time:   0.381589
 Self time:   0.003485

count  total (s)   self (s)
   28              0.000283     if a:0 > 1
                                    " Use the buffer number given as the optional second argument.
   14              0.000033         let l:buffer = a:2
   14              0.000028     elseif a:0 > 0 && a:1 == s:lint_timer
                                    " Use the buffer number for the buffer linting was queued for.
   14              0.000079         let l:buffer = s:queued_buffer_number
   14              0.000025     else
                                    " Use the current buffer number.
                                    let l:buffer = bufnr('')
                                endif
                            
   28   0.380598   0.002494     return ale#CallWithCooldown(   'dont_lint_until',   function('s:ALELintImpl'),   [l:buffer],)

FUNCTION  ale#linter#GetAll()
Called 63 times
Total time:   0.003854
 Self time:   0.003854

count  total (s)   self (s)
   63              0.000204     let l:combined_linters = []
                            
  126              0.000255     for l:filetype in a:filetypes
                                    " Load linter defintions from files if we haven't loaded them yet.
   63              0.000239         if !has_key(s:linters, l:filetype)
                                        execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
                                        " Always set an empty List for the loaded linters if we don't find
                                        " any. This will prevent us from executing the runtime command
                                        " many times, redundantly.
                                        if !has_key(s:linters, l:filetype)
                                            let s:linters[l:filetype] = []
                                        endif
                                    endif
                            
   63              0.000725         call extend(l:combined_linters, get(s:linters, l:filetype, []))
   63              0.000110     endfor
                            
   63              0.000116     return l:combined_linters

FUNCTION  <SNR>125_TemporaryFilename()
Called 48 times
Total time:   0.006630
 Self time:   0.006630

count  total (s)   self (s)
   48              0.001050     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
   48              0.000222     if empty(l:filename)
                                    " If the buffer's filename is empty, create a dummy filename.
                                    let l:ft = getbufvar(a:buffer, '&filetype')
                                    let l:filename = 'file' . ale#filetypes#GuessExtension(l:ft)
                                endif
                            
                                " Create a temporary filename, <temp_dir>/<original_basename>
                                " The file itself will not be created by this function.
   48              0.003794     return tempname() . (has('win32') ? '\' : '/') . l:filename

FUNCTION  ale#linter#ResolveFiletype()
Called 63 times
Total time:   0.004942
 Self time:   0.001400

count  total (s)   self (s)
   63   0.004346   0.000804     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
   63              0.000297     if type(l:filetype) != type([])
   63              0.000153         return [l:filetype]
                                endif
                            
                                return l:filetype

FUNCTION  <SNR>43_evaluate_opts()
Called 10 times
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
   10              0.000085   return type(a:options) == type([]) ? join(map(copy(a:options), 'fzf#shellescape(v:val)')) : a:options

FUNCTION  <SNR>134_on_haskell()
Called 3 times
Total time:   0.014402
 Self time:   0.000144

count  total (s)   self (s)
    3   0.014312   0.000054   call necoghc#caching_modules()
                            
    3              0.000014   augroup necoghc
    3              0.000027     autocmd InsertLeave <buffer> call necoghc#caching_modules()
    3              0.000005   augroup END
                            
    3              0.000037   command! -buffer -bar -nargs=0 NecoGhcCaching call necoghc#caching_modules()

FUNCTION  neocomplete#helper#check_filetype()
Called 91 times
Total time:   0.002687
 Self time:   0.001286

count  total (s)   self (s)
   91   0.002630   0.001229   return !empty(filter(neocomplete#context_filetype#filetypes(), 'get(a:dictionary, v:val, 0)'))

FUNCTION  neocomplete#handler#_on_insert_leave()
Called 1 time
Total time:   0.009424
 Self time:   0.000054

count  total (s)   self (s)
    1   0.000040   0.000006   call neocomplete#helper#clear_result()
                            
    1   0.000020   0.000011   call s:close_preview_window()
    1   0.009349   0.000029   call s:make_cache_current_line()
                            
    1   0.000013   0.000006   let neocomplete = neocomplete#get_current_neocomplete()
    1              0.000002   let neocomplete.cur_text = ''

FUNCTION  <SNR>108_vp_waitpid()
Called 2 times
Total time:   0.001549
 Self time:   0.000245

count  total (s)   self (s)
    2              0.000097   let nohang = a:0 ? a:1 : 0
    2   0.000796   0.000021   call s:close_all(self)
                            
    2              0.000002   let self.is_valid = 0
                            
    2              0.000007   if has_key(self, 'cond') && has_key(self, 'status')
                                " Use cache.
                                let [cond, status] = [self.cond, self.status]
                              else
    2   0.000576   0.000047     let [cond, status] = s:waitpid(self.pid, nohang)
    2              0.000001   endif
                            
    2              0.000003   if cond ==# 'exit'
    2              0.000003     let self.pid = 0
    2              0.000002   endif
                            
    2              0.000006   if has_key(self, 'pid_list')
    2              0.000004     if !has_key(self, 'pipe_status')
    2              0.000013       let self.pipe_status = repeat([['run', 0]], len(self.pid_list))
    2              0.000000     endif
    2              0.000016     let self.pipe_status[:] = map(self.pipe_status[:-2], 'v:val[0] !=# "run" ? v:val : s:waitpid(self.pid_list[v:key], nohang)') + [[cond, status]]
    2              0.000001   endif
                            
    2              0.000002   return [cond, status]

FUNCTION  <SNR>123_HandleLoclist()
Called 38 times
Total time:   0.098192
 Self time:   0.003384

count  total (s)   self (s)
   38              0.000334     let l:buffer_info = get(g:ale_buffer_info, a:buffer, {})
                            
   38              0.000140     if empty(l:buffer_info)
                                    return
                                endif
                            
                                " Remove this linter from the list of active linters.
                                " This may have already been done when the job exits.
   38              0.000285     call filter(l:buffer_info.active_linter_list, 'v:val isnot# a:linter_name')
                            
                                " Make some adjustments to the loclists to fix common problems, and also
                                " to set default values for loclist items.
   38   0.011568   0.000508     let l:linter_loclist = ale#engine#FixLocList(a:buffer, a:linter_name, a:loclist)
                            
                                " Remove previous items for this linter.
   38              0.000326     call filter(g:ale_buffer_info[a:buffer].loclist, 'v:val.linter_name isnot# a:linter_name')
                                " Add the new items.
   38              0.000220     call extend(g:ale_buffer_info[a:buffer].loclist, l:linter_loclist)
                            
                                " Sort the loclist again.
                                " We need a sorted list so we can run a binary search against it
                                " for efficient lookup of the messages in the cursor handler.
   38              0.000181     call sort(g:ale_buffer_info[a:buffer].loclist, 'ale#util#LocItemCompare')
                            
   38   0.007544   0.000295     if ale#ShouldDoNothing(a:buffer)
                                    return
                                endif
                            
   38   0.076957   0.000458     call ale#engine#SetResults(a:buffer, g:ale_buffer_info[a:buffer].loclist)

FUNCTION  ale#util#InSandbox()
Called 431 times
Total time:   0.018645
 Self time:   0.018645

count  total (s)   self (s)
  431              0.002808     try
  431              0.009339         function! s:SandboxCheck() abort
                                    endfunction
  431              0.001438     catch /^Vim\%((\a\+)\)\=:E48/
                                    " E48 is the sandbox error.
                                    return 1
                                endtry
                            
  431              0.000643     return 0

FUNCTION  neocomplete#sources#tag#make_cache()
Called 6 times
Total time:   0.003411
 Self time:   0.003316

count  total (s)   self (s)
    6   0.000144   0.000049   if !neocomplete#is_enabled()
                                call neocomplete#initialize()
                              endif
                            
    6              0.000032   let bufnumber = bufnr('%')
                            
    6              0.000108   let s:async_tags_list[bufnumber] = []
    6              0.002839   let tagfiles = tagfiles()
    6              0.000042   if get(g:, 'loaded_neoinclude', 0)
                                let tagfiles += neoinclude#include#get_tag_files()
                              endif
    6              0.000064   for tags in map(filter(tagfiles, 'getfsize(v:val) > 0'), "neocomplete#util#substitute_path_separator(    fnamemodify(v:val, ':p'))")
                                if tags !~? '/doc/tags\%(-\w\+\)\?$' && (a:force || getfsize(tags)         < g:neocomplete#sources#tags#cache_limit_size)
                                  call add(s:async_tags_list[bufnumber], s:initialize_tags(tags))
                                endif
                              endfor

FUNCTION  ale#util#ClockMilliseconds()
Called 338 times
Total time:   0.006504
 Self time:   0.006504

count  total (s)   self (s)
  338              0.005720     return float2nr(reltimefloat(reltime()) * 1000)

FUNCTION  neocomplete#complete#_get_words()
Called 2 times
Total time:   0.007649
 Self time:   0.001928

count  total (s)   self (s)
    2   0.000152   0.000047   let frequencies = neocomplete#variables#get_frequencies()
    2              0.000008   if exists('*neocomplete#sources#buffer#get_frequencies')
    2   0.000149   0.000125     let frequencies = extend(copy( neocomplete#sources#buffer#get_frequencies()), frequencies)
    2              0.000002   endif
                            
                              " Append prefix.
    2              0.000002   let candidates = []
    2              0.000003   let len_words = 0
    4              0.000524   for source in sort(filter(deepcopy(a:sources), '!empty(v:val.neocomplete__context.candidates)'),  's:compare_source_rank')
    2              0.000007     let context = source.neocomplete__context
    2              0.000039     let words = type(context.candidates[0]) == type('') ? map(copy(context.candidates), "{'word': v:val}") : deepcopy(context.candidates)
    2              0.000026     let context.candidates = words
                            
    2   0.000277   0.000088     call neocomplete#helper#call_hook( source, 'on_post_filter', {})
                            
    2              0.000004     if context.complete_pos > a:complete_pos
                                  let prefix = a:complete_str[: context.complete_pos                            - a:complete_pos - 1]
                            
                                  " Fix complete position.
                                  let context.complete_pos = a:complete_pos
                                  let context.complete_str = prefix
                            
                                  for candidate in words
                                    let candidate.word = prefix . candidate.word
                                  endfor
                                endif
                            
    2              0.000003     lua << EOF
                                do
                                  local frequencies = vim.eval('frequencies')
                                  local candidates = vim.eval('words')
                                  for i = 0, #candidates-1 do
                                    if frequencies[candidates[i].word] ~= nil then
                                      candidates[i].rank = frequencies[candidates[i].word]
                                    end
                                  end
                                end
                            EOF
                            
    2   0.000476   0.000028     let words = neocomplete#helper#call_filters( source.neocomplete__sorters, source, {})
    2              0.000007     if empty(words)
                                  continue
                                endif
                            
    2   0.004412   0.000044     let words = neocomplete#helper#call_filters( source.neocomplete__converters, source, {})
                            
    2              0.000012     if empty(words)
                                  continue
                                endif
                            
    2              0.000009     if source.max_candidates > 0
                                  let words = words[: source.max_candidates -1]
                                endif
                            
                                " Set default menu.
    2              0.000073     if get(words[0], 'menu', '') !~ '^\[.*\]'
    2   0.000338   0.000149       call s:set_default_menu(words, source)
    2              0.000003     endif
                            
    2              0.000010     let candidates += words
    2              0.000014     let len_words += len(words)
                            
    2              0.000012     if g:neocomplete#max_list > 0 && len_words > g:neocomplete#max_list
                                  break
                                endif
                            
    2   0.000236   0.000024     if neocomplete#complete_check()
                                  return []
                                endif
    2              0.000002   endfor
                            
    2              0.000039   call filter(candidates, 'v:val.word !=# a:complete_str')
                            
    2              0.000005   if g:neocomplete#max_list > 0
    2              0.000025     let candidates = candidates[: g:neocomplete#max_list]
    2              0.000002   endif
                            
                              " Check dup and set icase.
    2              0.000011   let icase = g:neocomplete#enable_ignore_case && !((g:neocomplete#enable_smart_case    || g:neocomplete#enable_camel_case) && a:complete_str =~ '\u')
    2              0.000003   if icase
                                for candidate in candidates
                                  let candidate.icase = 1
                                endfor
                              endif
                            
    2   0.000204   0.000018   if neocomplete#complete_check()
                                return []
                              endif
                            
    2              0.000003   return candidates

FUNCTION  <SNR>123_AddProblemsFromOtherBuffers()
Called 3 times
Total time:   0.000829
 Self time:   0.000829

count  total (s)   self (s)
    3              0.000253     let l:filename = expand('#' . a:buffer . ':p')
    3              0.000013     let l:loclist = []
    3              0.000023     let l:name_map = {}
                            
                                " Build a map of the active linters.
    9              0.000054     for l:linter in a:linters
    6              0.000029         let l:name_map[l:linter.name] = 1
    6              0.000026     endfor
                            
                                " Find the items from other buffers, for the linters that are enabled.
    9              0.000075     for l:info in values(g:ale_buffer_info)
    6              0.000043         for l:item in l:info.loclist
                                        if has_key(l:item, 'filename')&& l:item.filename is# l:filename&& has_key(l:name_map, l:item.linter_name)
                                            " Copy the items and set the buffer numbers to this one.
                                            let l:new_item = copy(l:item)
                                            let l:new_item.bufnr = a:buffer
                                            call add(l:loclist, l:new_item)
                                        endif
                                    endfor
    6              0.000007     endfor
                            
    3              0.000013     if !empty(l:loclist)
                                    call sort(l:loclist, function('ale#util#LocItemCompareWithText'))
                                    call uniq(l:loclist, function('ale#util#LocItemCompareWithText'))
                            
                                    " Set the loclist variable, used by some parts of ALE.
                                    let g:ale_buffer_info[a:buffer].loclist = l:loclist
                                    call ale#engine#SetResults(a:buffer, l:loclist)
                                endif

FUNCTION  fugitive#is_git_dir()
Called 12 times
Total time:   0.000628
 Self time:   0.000354

count  total (s)   self (s)
   12   0.000386   0.000112   let path = s:sub(a:path, '[\/]$', '') . '/'
   12              0.000227   return getfsize(path.'HEAD') > 10 && ( isdirectory(path.'objects') && isdirectory(path.'refs') || getftype(path.'commondir') ==# 'file')

FUNCTION  ale#node#FindExecutable()
Called 4 times
Total time:   0.002199
 Self time:   0.000343

count  total (s)   self (s)
    4   0.000246   0.000066     if ale#Var(a:buffer, a:base_var_name . '_use_global')
                                    return ale#Var(a:buffer, a:base_var_name . '_executable')
                                endif
                            
    8              0.000018     for l:path in a:path_list
    4   0.001574   0.000068         let l:executable = ale#path#FindNearestFile(a:buffer, l:path)
                            
    4              0.000013         if !empty(l:executable)
                                        return l:executable
                                    endif
    4              0.000038     endfor
                            
    4   0.000228   0.000058     return ale#Var(a:buffer, a:base_var_name . '_executable')

FUNCTION  <SNR>99_check_force_omni()
Called 11 times
Total time:   0.001112
 Self time:   0.000274

count  total (s)   self (s)
   11              0.000029   let cur_text = a:cur_text
   11   0.000968   0.000130   let complete_pos = neocomplete#helper#get_force_omni_complete_pos(cur_text)
                            
   11              0.000045   if complete_pos >= 0 && !neocomplete#complete#_check_previous_position(       cur_text, complete_pos)
                                call s:complete_key("\<Plug>(neocomplete_start_omni_complete)")
                              endif
                            
   11              0.000012   return complete_pos

FUNCTION  ale#util#GetLineCount()
Called 38 times
Total time:   0.001663
 Self time:   0.001663

count  total (s)   self (s)
   38              0.001611     return len(getbufline(a:buffer, 1, '$'))

FUNCTION  necoghc#get_modules()
Called 3 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    3              0.000017   if !exists('b:necoghc_modules_cache')
                                call necoghc#caching_modules()
                              endif
    3              0.000004   return b:necoghc_modules_cache

FUNCTION  ale#engine#FixLocList()
Called 38 times
Total time:   0.011060
 Self time:   0.007862

count  total (s)   self (s)
   38              0.000147     let l:bufnr_map = {}
   38              0.000119     let l:new_loclist = []
                            
                                " Some errors have line numbers beyond the end of the file,
                                " so we need to adjust them so they set the error at the last line
                                " of the file instead.
   38   0.002537   0.000874     let l:last_line_number = ale#util#GetLineCount(a:buffer)
                            
   38              0.000105     for l:old_item in a:loclist
                                    " Copy the loclist item with some default values and corrections.
                                    "
                                    " line and column numbers will be converted to numbers.
                                    " The buffer will default to the buffer being checked.
                                    " The vcol setting will default to 0, a byte index.
                                    " The error type will default to 'E' for errors.
                                    " The error number will default to -1.
                                    "
                                    " The line number and text are the only required keys.
                                    "
                                    " The linter_name will be set on the errors so it can be used in
                                    " output, filtering, etc..
                                    let l:item = {   'bufnr': a:buffer,   'text': l:old_item.text,   'lnum': str2nr(l:old_item.lnum),   'col': str2nr(get(l:old_item, 'col', 0)),   'vcol': get(l:old_item, 'vcol', 0),   'type': get(l:old_item, 'type', 'E'),   'nr': get(l:old_item, 'nr', -1),   'linter_name': a:linter_name,}
                            
                                    if has_key(l:old_item, 'filename')&& !ale#path#IsTempName(l:old_item.filename)
                                        " Use the filename given.
                                        " Temporary files are assumed to be for this buffer,
                                        " and the filename is not included then, because it looks bad
                                        " in the loclist window.
                                        let l:filename = l:old_item.filename
                                        let l:item.filename = l:filename
                            
                                        if has_key(l:old_item, 'bufnr')
                                            " If a buffer number is also given, include that too.
                                            " If Vim detects that he buffer number is valid, it will
                                            " be used instead of the filename.
                                            let l:item.bufnr = l:old_item.bufnr
                                        elseif has_key(l:bufnr_map, l:filename)
                                            " Get the buffer number from the map, which can be faster.
                                            let l:item.bufnr = l:bufnr_map[l:filename]
                                        else
                                            " Look up the buffer number.
                                            let l:item.bufnr = bufnr(l:filename)
                                            let l:bufnr_map[l:filename] = l:item.bufnr
                                        endif
                                    elseif has_key(l:old_item, 'bufnr')
                                        let l:item.bufnr = l:old_item.bufnr
                                    endif
                            
                                    if has_key(l:old_item, 'detail')
                                        let l:item.detail = l:old_item.detail
                                    endif
                            
                                    " Pass on a end_col key if set, used for highlights.
                                    if has_key(l:old_item, 'end_col')
                                        let l:item.end_col = str2nr(l:old_item.end_col)
                                    endif
                            
                                    if has_key(l:old_item, 'end_lnum')
                                        let l:item.end_lnum = str2nr(l:old_item.end_lnum)
                                    endif
                            
                                    if has_key(l:old_item, 'sub_type')
                                        let l:item.sub_type = l:old_item.sub_type
                                    endif
                            
                                    if l:item.lnum < 1
                                        " When errors appear before line 1, put them at line 1.
                                        let l:item.lnum = 1
                                    elseif l:item.bufnr == a:buffer && l:item.lnum > l:last_line_number
                                        " When errors go beyond the end of the file, put them at the end.
                                        " This is only done for the current buffer.
                                        let l:item.lnum = l:last_line_number
                                    endif
                            
                                    call add(l:new_loclist, l:item)
                                endfor
                            
   38   0.002240   0.000705     let l:type_map = get(ale#Var(a:buffer, 'type_map'), a:linter_name, {})
                            
   38              0.000110     if !empty(l:type_map)
                                    call s:RemapItemTypes(l:type_map, l:new_loclist)
                                endif
                            
   38              0.000073     return l:new_loclist

FUNCTION  ale#highlight#SetHighlights()
Called 46 times
Total time:   0.005288
 Self time:   0.001700

count  total (s)   self (s)
   46              0.000593     let l:new_list = getbufvar(a:buffer, 'ale_enabled', 1) && g:ale_enabled   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')   : []
                            
                                " Set the list in the buffer variable.
   46              0.000567     call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
                            
                                " Update highlights for the current buffer, which may or may not
                                " be the buffer we just set highlights for.
   46   0.003945   0.000357     call ale#highlight#UpdateHighlights()

FUNCTION  ale#engine#SetResults()
Called 46 times
Total time:   0.088266
 Self time:   0.006741

count  total (s)   self (s)
   46   0.001168   0.000451     let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
   46              0.000084     if g:ale_set_signs
   46   0.029499   0.000643         call ale#sign#SetSigns(a:buffer, a:loclist)
   46              0.000044     endif
                            
   46              0.000108     if g:ale_set_quickfix || g:ale_set_loclist
   46   0.008249   0.000376         call ale#list#SetLists(a:buffer, a:loclist)
   46              0.000035     endif
                            
   46              0.000364     if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
                                    call ale#statusline#Update(a:buffer, a:loclist)
                                endif
                            
   46              0.000077     if g:ale_set_highlights
   46   0.006004   0.000716         call ale#highlight#SetHighlights(a:buffer, a:loclist)
   46              0.000059     endif
                            
   46              0.000086     if g:ale_echo_cursor
                                    " Try and echo the warning now.
                                    " This will only do something meaningful if we're in normal mode.
   46   0.018803   0.000455         call ale#cursor#EchoCursorWarning()
   46              0.000044     endif
                            
   46              0.000073     if l:linting_is_done
                                    " Reset the save event marker, used for opening windows, etc.
   25              0.000202         call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
   25   0.019877   0.000436         call ale#engine#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
   25   0.002359   0.001357         silent doautocmd User ALELint
   25              0.000042     endif

FUNCTION  vimproc#util#has_iconv()
Called 3657 times
Total time:   0.052062
 Self time:   0.052062

count  total (s)   self (s)
                              " On Windows, some encodings can be converted by iconv() even if
                              " libiconv.dll is not available.
 3657              0.019329   return (has('iconv') || (s:is_windows && exists('*iconv')))

FUNCTION  <SNR>81_substitute_path_separator()
Called 53 times
Total time:   0.000340
 Self time:   0.000340

count  total (s)   self (s)
   53              0.000282   return s:is_windows ? substitute(a:path, '\\', '/', 'g') : a:path

FUNCTION  <SNR>127_UpdateLineNumbers()
Called 46 times
Total time:   0.001840
 Self time:   0.001840

count  total (s)   self (s)
   46              0.000156     let l:line_map = {}
   46              0.000140     let l:line_numbers_changed = 0
                            
   46              0.000143     for [l:line, l:sign_id, l:name] in a:current_sign_list
                                    let l:line_map[l:sign_id] = l:line
                                endfor
                            
   46              0.000098     for l:item in a:loclist
                                    if l:item.bufnr == a:buffer
                                        let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                            
                                        if l:lnum && l:item.lnum != l:lnum
                                            let l:item.lnum = l:lnum
                                            let l:line_numbers_changed = 1
                                        endif
                                    endif
                                endfor
                            
                                " When the line numbers change, sort the list again
   46              0.000079     if l:line_numbers_changed
                                    call sort(a:loclist, 'ale#util#LocItemCompare')
                                endif

FUNCTION  neocomplete#mappings#auto_complete()
Called 2 times
Total time:   0.009768
 Self time:   0.001719

count  total (s)   self (s)
    2   0.000047   0.000026   let neocomplete = neocomplete#get_current_neocomplete()
    2   0.000361   0.000021   let cur_text = neocomplete#get_cur_text(1)
    2   0.000055   0.000016   let complete_pos = neocomplete#complete#_get_complete_pos( neocomplete.complete_sources)
    2              0.000008   let base = cur_text[complete_pos :]
                            
    2   0.008400   0.000751   let neocomplete.candidates = neocomplete#complete#_get_words( neocomplete.complete_sources, complete_pos, base)
    2              0.000026   let neocomplete.complete_str = base
    2              0.000016   let neocomplete.refresh = 0
    2              0.000024   if empty(neocomplete.candidates)
                                return ''
                              endif
                            
                              " Start auto complete.
    2              0.000785   call complete(complete_pos+1, neocomplete.candidates)
    2              0.000013   return ''

FUNCTION  <SNR>99_do_auto_complete()
Called 11 times
Total time:   0.743363
 Self time:   0.002423

count  total (s)   self (s)
   11   0.000284   0.000117   let neocomplete = neocomplete#get_current_neocomplete()
                            
   11   0.001676   0.000101   if s:check_in_do_auto_complete(a:event)
                                return
                              endif
                            
   11              0.000039   let neocomplete.skipped = 0
   11              0.000060   let neocomplete.event = a:event
   11   0.000476   0.000078   call neocomplete#helper#clear_result()
                            
                              " Set context filetype.
   11   0.000632   0.000090   call neocomplete#context_filetype#set()
                            
   11   0.002477   0.000115   let cur_text = neocomplete#get_cur_text(1)
   11              0.000019   let complete_pos = -1
                            
   11   0.000211   0.000126   call neocomplete#print_debug('cur_text = ' . cur_text)
                            
   11              0.000011   try
                                " Prevent infinity loop.
   11   0.000617   0.000121     if s:is_skip_auto_complete(cur_text)
                                  call neocomplete#print_debug('Skipped.')
                                  return
                                endif
                            
   11   0.001235   0.000123     let complete_pos = s:check_force_omni(cur_text)
   11              0.000012     if complete_pos >= 0
                                  return
                                endif
                            
                                " Check multibyte input or eskk or spaces.
   11   0.000883   0.000327     if cur_text =~ '^\s*$' || (!neocomplete#is_eskk_enabled()     && neocomplete#is_multibyte_input(cur_text))
                                  call neocomplete#print_debug('Skipped.')
                                  return
                                endif
                            
   11              0.000010     try
   11              0.000025       let neocomplete.is_auto_complete = 1
                            
                                  " Do prefetch.
   11   0.732796   0.000316       let neocomplete.complete_sources = neocomplete#complete#_get_results(cur_text)
   11              0.000013     finally
   11              0.000023       let neocomplete.is_auto_complete = 0
   11              0.000009     endtry
                            
   11              0.000029     if empty(neocomplete.complete_sources)
    9   0.000658   0.000093       call s:check_fallback(cur_text)
    9              0.000008       return
                                endif
                            
                                " Start auto complete.
    2   0.000355   0.000045     call s:complete_key( "\<Plug>(neocomplete_start_auto_complete)")
    2              0.000003   finally
   11   0.000436   0.000144     call neocomplete#complete#_set_previous_position(cur_text, complete_pos)
   11              0.000013   endtry

FUNCTION  <SNR>21_sub()
Called 22 times
Total time:   0.000571
 Self time:   0.000571

count  total (s)   self (s)
   22              0.000556   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  <SNR>73_FindItemAtCursor()
Called 267 times
Total time:   0.021125
 Self time:   0.016085

count  total (s)   self (s)
  267              0.001242     let l:buf = bufnr('')
  267              0.002165     let l:info = get(g:ale_buffer_info, l:buf, {})
  267              0.001612     let l:loclist = get(l:info, 'loclist', [])
  267              0.001329     let l:pos = getcurpos()
  267   0.009754   0.004714     let l:index = ale#util#BinarySearch(l:loclist, l:buf, l:pos[1], l:pos[2])
  267              0.001284     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
  267              0.001050     return [l:info, l:loc]

FUNCTION  neocomplete#helper#is_enabled_source()
Called 79 times
Total time:   0.004315
 Self time:   0.001717

count  total (s)   self (s)
   79   0.000550   0.000538   let source = type(a:source) == type('') ? get(neocomplete#variables#get_sources(), a:source, {}) : a:source
                            
   79   0.003679   0.001093   return !empty(source) && (empty(source.filetypes) ||     neocomplete#helper#check_filetype(source.filetypes))  && (!get(source.disabled_filetypes, '_', 0) &&      !neocomplete#helper#check_filetype(source.disabled_filetypes))

FUNCTION  <SNR>126_VimExitCallback()
Called 48 times
Total time:   0.006904
 Self time:   0.004130

count  total (s)   self (s)
   48   0.003286   0.000839     let l:job_id = ale#job#ParseVim8ProcessID(string(a:job))
   48              0.000433     let l:info = get(s:job_map, l:job_id, {})
                            
   48              0.000152     if empty(l:info)
                                    return
                                endif
                            
   48              0.000179     let l:info.exit_code = a:exit_code
                            
                                " The program can exit before the data has finished being read.
   48              0.000329     if ch_status(job_getchannel(a:job)) is# 'closed'
    9              0.000013         try
    9              0.000051             if !empty(l:info) && has_key(l:info, 'exit_cb')
    9   0.000516   0.000189                 call ale#util#GetFunction(l:info.exit_cb)(l:job_id, a:exit_code)
    9              0.000010             endif
    9              0.000015         finally
                                        " Automatically forget about the job after it's done.
    9              0.000048             if has_key(s:job_map, l:job_id)
    9              0.000234                 call remove(s:job_map, l:job_id)
    9              0.000011             endif
    9              0.000012         endtry
    9              0.000009     endif

FUNCTION  neocomplete#handler#_on_insert_char_pre()
Called 21 times
Total time:   0.002423
 Self time:   0.000880

count  total (s)   self (s)
   21   0.000686   0.000268   let neocomplete = neocomplete#get_current_neocomplete()
   21              0.000085   let neocomplete.skip_next_complete = 0
                            
   21              0.000087   if pumvisible() && g:neocomplete#enable_refresh_always
                                " Auto refresh
                                call feedkeys("\<Plug>(neocomplete_auto_refresh)")
                              endif
                            
   21   0.001261   0.000136   if neocomplete#is_cache_disabled()
                                return
                              endif
                            
   21              0.000080   let neocomplete.old_char = v:char

FUNCTION  <SNR>94_get_member_pattern()
Called 26 times
Total time:   0.000233
 Self time:   0.000233

count  total (s)   self (s)
   26              0.000204   return get(g:neocomplete#sources#member#input_patterns, a:filetype, get(g:neocomplete#sources#member#input_patterns, '_', ''))

FUNCTION  <SNR>134_system()
Called 2 times
Total time:   0.624988
 Self time:   0.000334

count  total (s)   self (s)
    2              0.000007   if !exists('s:exists_vimproc')
                                try
                                  call vimproc#version()
                                  let s:exists_vimproc = 1
                                catch
                                  let s:exists_vimproc = 0
                                endtry
                              endif
    2   0.624964   0.000310   return s:exists_vimproc && !has('nvim') ? vimproc#system(a:list) : system(join(a:list, ' '))

FUNCTION  fugitive#reload_status()
Called 10 times
Total time:   0.004081
 Self time:   0.004081

count  total (s)   self (s)
   10              0.000215   if exists('s:reloading_status')
                                return
                              endif
   10              0.000028   try
   10              0.000073     let s:reloading_status = 1
   10              0.000069     let mytab = tabpagenr()
   30              0.000432     for tab in [mytab] + range(1,tabpagenr('$'))
   60              0.000310       for winnr in range(1,tabpagewinnr(tab,'$'))
   40              0.000568         if getbufvar(tabpagebuflist(tab)[winnr-1],'fugitive_type') ==# 'index'
                                      execute 'tabnext '.tab
                                      if winnr != winnr()
                                        execute winnr.'wincmd w'
                                        let restorewinnr = 1
                                      endif
                                      try
                                        if !&modified
                                          call s:BufReadIndex()
                                        endif
                                      finally
                                        if exists('restorewinnr')
                                          wincmd p
                                        endif
                                        execute 'tabnext '.mytab
                                      endtry
                                    endif
   40              0.000064       endfor
   20              0.000052     endfor
   10              0.000013   finally
   10              0.000030     unlet! s:reloading_status
   10              0.000012   endtry

FUNCTION  ale#history#Get()
Called 76 times
Total time:   0.001948
 Self time:   0.001948

count  total (s)   self (s)
   76              0.001842     return copy(getbufvar(a:buffer, 'ale_history', []))

FUNCTION  265()
Called 4 times
Total time:   0.003105
 Self time:   0.002793

count  total (s)   self (s)
    4              0.000016   if len(a:context.complete_str) > 10
                                " Mix fuzzy mode.
    1              0.000002     let len = len(a:context.complete_str)
    1              0.000004     let fuzzy_len = len - len/(1 + len/10)
    1   0.000096   0.000014     let pattern = neocomplete#filters#escape(     a:context.complete_str[: fuzzy_len-1])  . neocomplete#filters#fuzzy_escape(     a:context.complete_str[fuzzy_len :])
    1              0.000001   else
    3   0.000283   0.000053     let pattern = neocomplete#filters#fuzzy_escape( a:context.complete_str)
    3              0.000002   endif
                            
                              " The first letter must be matched.
    4              0.000010   let pattern = '^' . pattern
                            
    4              0.000004   lua << EOF
                            do
                              local pattern = vim.eval('pattern')
                              local input = vim.eval('a:context.complete_str')
                              local candidates = vim.eval('a:context.candidates')
                              if vim.eval('&ignorecase') ~= 0 then
                                pattern = string.lower(pattern)
                                input = string.lower(input)
                                for i = #candidates-1, 0, -1 do
                                  local word = vim.type(candidates[i]) == 'dict' and
                                    string.lower(candidates[i].word) or string.lower(candidates[i])
                                  if string.find(word, pattern, 1) == nil then
                                    candidates[i] = nil
                                  end
                                end
                              else
                                for i = #candidates-1, 0, -1 do
                                  local word = vim.type(candidates[i]) == 'dict' and
                                    candidates[i].word or candidates[i]
                                  if string.find(word, pattern, 1) == nil then
                                    candidates[i] = nil
                                  end
                                end
                              end
                            end
                            EOF
                            
    4              0.000018   return a:context.candidates

FUNCTION  266()
Called 4 times
Total time:   0.000121
 Self time:   0.000121

count  total (s)   self (s)
    4              0.000014   if empty(a:context.candidates)
    2              0.000002     return []
                              endif
                            
    2              0.000002   lua << EOF
                            do
                              local candidates = vim.eval('a:context.candidates')
                              local len = string.len(vim.eval('a:context.complete_str'))
                              for i = #candidates-1, 0, -1 do
                                local word = vim.type(candidates[i]) == 'dict' and
                                candidates[i].word or candidates[i]
                                if string.len(word) <= len then
                                  candidates[i] = nil
                                end
                              end
                            end
                            EOF
                            
    2              0.000003   return a:context.candidates

FUNCTION  269()
Called 2 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
                              " Filters too long word.
    2              0.000030   call filter(a:context.candidates, 'len(v:val.word) < g:neocomplete#sources#buffer#max_keyword_width')

FUNCTION  neocomplete#handler#_on_insert_enter()
Called 3 times
Total time:   0.000596
 Self time:   0.000279

count  total (s)   self (s)
    3   0.000151   0.000067   if !neocomplete#is_enabled()
                                return
                              endif
                            
    3   0.000106   0.000046   let neocomplete = neocomplete#get_current_neocomplete()
    3              0.000021   if neocomplete.linenr != line('.')
    3   0.000242   0.000069     call neocomplete#helper#clear_result()
    3              0.000003   endif
    3              0.000013   let neocomplete.linenr = line('.')
                            
    3              0.000018   if &l:foldmethod ==# 'expr' && foldlevel('.') != 0
                                foldopen
                              endif

FUNCTION  neocomplete#helper#call_hook()
Called 2 times
Total time:   0.000189
 Self time:   0.000135

count  total (s)   self (s)
    4   0.000052   0.000030   for source in neocomplete#util#convert2list(a:sources)
    2              0.000003     try
    2              0.000008       if has_key(source.hooks, a:hook_name)
    2   0.000054   0.000022         call call(source.hooks[a:hook_name], [extend(source.neocomplete__context, a:context)], source.hooks)
    2              0.000002       endif
    2              0.000003     catch
                                  call neocomplete#print_error(v:throwpoint)
                                  call neocomplete#print_error(v:exception)
                                  call neocomplete#print_error( 'Error occurred in calling hook "' . a:hook_name . '"!')
                                  call neocomplete#print_error( 'Source name is ' . source.name)
                                endtry
    2              0.000002   endfor

FUNCTION  neocomplete#handler#_on_complete_done()
Called 2 times
Total time:   0.001111
 Self time:   0.000132

count  total (s)   self (s)
    2   0.000055   0.000021   let neocomplete = neocomplete#get_current_neocomplete()
                            
    2   0.000630   0.000048   if neocomplete.event !=# 'mapping' && !s:is_delimiter() && !get(neocomplete, 'refresh', 0)
    2   0.000405   0.000042     call neocomplete#mappings#close_popup()
    2              0.000001   endif
                            
                              " Use v:completed_item feature.
    2              0.000010   if !exists('v:completed_item') || empty(v:completed_item)
    2              0.000002     return
                              endif
                            
                              let complete_str = v:completed_item.word
                              if complete_str == ''
                                return
                              endif
                            
                              let frequencies = neocomplete#variables#get_frequencies()
                              if !has_key(frequencies, complete_str)
                                let frequencies[complete_str] = 20
                              else
                                let frequencies[complete_str] += 20
                              endif

FUNCTION  ale#handlers#haskell#HandleGHCFormat()
Called 17 times
Total time:   0.002284
 Self time:   0.002284

count  total (s)   self (s)
                                " Look for lines like the following.
                                "
                                "Appoint/Lib.hs:8:1: warning:
                                "Appoint/Lib.hs:8:1:
   17              0.000183     let l:basename = expand('#' . a:buffer . ':t')
                                " Build a complete regular expression for replacing temporary filenames
                                " in Haskell error messages with the basename for this file.
   17              0.000116     let l:temp_filename_regex = s:temp_regex_prefix . l:basename
                            
   17              0.000044     let l:pattern = '\v^([a-zA-Z]?:?[^:]+):(\d+):(\d+):(.*)?$'
   17              0.000031     let l:output = []
                            
   17              0.000033     let l:corrected_lines = []
                            
   17              0.000044     for l:line in a:lines
                                    if len(matchlist(l:line, l:pattern)) > 0
                                        call add(l:corrected_lines, l:line)
                                    elseif l:line is# ''
                                        call add(l:corrected_lines, l:line)
                                    else
                                        if len(l:corrected_lines) > 0
                                            let l:line = substitute(l:line, '\v^\s+', ' ', '')
                                            let l:corrected_lines[-1] .= l:line
                                        endif
                                    endif
                                endfor
                            
   17              0.000049     for l:line in l:corrected_lines
                                    let l:match = matchlist(l:line, l:pattern)
                            
                                    if len(l:match) == 0
                                        continue
                                    endif
                            
                                    if !ale#path#IsBufferPath(a:buffer, l:match[1])
                                        continue
                                    endif
                            
                                    let l:errors = matchlist(l:match[4], '\v([wW]arning|[eE]rror): ?(.*)')
                            
                                    if len(l:errors) > 0
                                      let l:ghc_type = l:errors[1]
                                      let l:text = l:errors[2]
                                    else
                                      let l:ghc_type = ''
                                      let l:text = l:match[4][:0] is# ' ' ? l:match[4][1:] : l:match[4]
                                    endif
                            
                                    if l:ghc_type is? 'Warning'
                                        let l:type = 'W'
                                    else
                                        let l:type = 'E'
                                    endif
                            
                                    " Replace temporary filenames in problem messages with the basename
                                    let l:text = substitute(l:text, l:temp_filename_regex, l:basename, 'g')
                            
                                    call add(l:output, {   'lnum': l:match[2] + 0,   'col': l:match[3] + 0,   'text': l:text,   'type': l:type,})
                                endfor
                            
   17              0.000030     return l:output

FUNCTION  neocomplete#helper#complete_check()
Called 20 times
Total time:   0.001663
 Self time:   0.001125

count  total (s)   self (s)
   20   0.000356   0.000146   let neocomplete = neocomplete#get_current_neocomplete()
   20              0.000032   if g:neocomplete#enable_debug
                                echomsg split(reltimestr(reltime(neocomplete.start_time)))[0]
                              endif
   20   0.000921   0.000604   let ret = neocomplete#is_auto_complete()     && g:neocomplete#skip_auto_completion_time != ''     && split(reltimestr(reltime(neocomplete.start_time)))[0] >          g:neocomplete#skip_auto_completion_time
   20              0.000026   if ret
    1   0.000019   0.000012     let neocomplete = neocomplete#get_current_neocomplete()
    1              0.000004     let neocomplete.skipped = 1
                            
    1   0.000008   0.000004     call neocomplete#print_debug('Skipped.')
    1              0.000000   endif
                            
   20              0.000019   return ret

FUNCTION  <SNR>132_writefile()
Called 6 times
Total time:   0.003215
 Self time:   0.002289

count  total (s)   self (s)
    6   0.001006   0.000080   let cache_name = s:_encode_name(a:cache_dir, a:filename)
                            
    6              0.002195   call writefile(a:list, cache_name)

FUNCTION  ale#history#Add()
Called 56 times
Total time:   0.017360
 Self time:   0.017360

count  total (s)   self (s)
   56              0.000586     if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
                                endif
                            
   56              0.001276     let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
   56              0.000279     if len(l:history) >= g:ale_max_buffer_history_size
   30              0.003984         let l:history = l:history[1:]
   30              0.000104     endif
                            
   56              0.001182     call add(l:history, {   'status': a:status,   'job_id': a:job_id,   'command': a:command,})
                            
   56              0.008344     call setbufvar(a:buffer, 'ale_history', l:history)

FUNCTION  <SNR>128_FixList()
Called 46 times
Total time:   0.001361
 Self time:   0.001361

count  total (s)   self (s)
   46              0.000126     let l:new_list = []
                            
   46              0.000121     for l:item in a:list
                                    if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        let l:fixed_item = copy(l:item)
                                        call remove(l:fixed_item, 'bufnr')
                                    else
                                        " Don't copy the Dictionary if we do not need to.
                                        let l:fixed_item = l:item
                                    endif
                            
                                    call add(l:new_list, l:fixed_item)
                                endfor
                            
   46              0.000083     return l:new_list

FUNCTION  270()
Called 3 times
Total time:   0.021471
 Self time:   0.000930

count  total (s)   self (s)
    3   0.019913   0.000042   call s:check_async_cache(a:context)
                            
    3              0.000006   let keyword_list = []
   60   0.000760   0.000090   for source in s:get_sources_list(a:context)
   57              0.000682     let keyword_list += source.words
   57              0.000075   endfor
    3              0.000004   return keyword_list

FUNCTION  271()
Called 2 times
Total time:   0.000293
 Self time:   0.000293

count  total (s)   self (s)
    2              0.000002   lua << EOF
                            do
                              local candidates = vim.eval('a:context.candidates')
                              local t = {}
                              local input = string.lower(vim.eval('a:context.input'))
                              for i = 1, #candidates do
                                t[i] = candidates[i-1]
                                local ti = t[i]
                            
                                -- Match position.
                                ti.neocomplete__match = select(1, string.find(
                                    string.lower(ti.word), input, 1, true))
                                if ti.neocomplete__match == nil then
                                  ti.neocomplete__match = string.len(ti.word)
                                end
                            
                                if ti.rank == nil then
                                  ti.rank = 0
                                end
                              end
                              table.sort(t, function(a, b)
                                    return (a.rank == b.rank) and (a.neocomplete__match
                                        < b.neocomplete__match) or (a.rank > b.rank)
                                  end)
                              for i = 0, #candidates-1 do
                                candidates[i] = t[i+1]
                              end
                            end
                            EOF
    2              0.000006   return a:context.candidates

FUNCTION  neocomplete#context_filetype#filetypes()
Called 168 times
Total time:   0.002785
 Self time:   0.001262

count  total (s)   self (s)
  168   0.002695   0.001172   return copy(neocomplete#get_current_neocomplete().context_filetypes)

FUNCTION  274()
Called 2 times
Total time:   0.000272
 Self time:   0.000272

count  total (s)   self (s)
    2              0.000006   if g:neocomplete#max_keyword_width < 0
                                return a:context.candidates
                              endif
                            
    2              0.000004   lua << EOF
                            do
                              local candidates = vim.eval('a:context.candidates')
                              local max = vim.eval('g:neocomplete#max_keyword_width')
                              for i = 0, #candidates-1 do
                                local abbr = candidates[i].abbr == nil and
                                  candidates[i].word or candidates[i].abbr
                                if string.len(abbr) > max then
                                  vim.command("let a:context.candidates[".. i .."].abbr = neocomplete#util#truncate_smart("..
                                          "get(a:context.candidates[".. i .."], 'abbr', " ..
                                          "a:context.candidates[".. i .."].word), g:neocomplete#max_keyword_width," ..
                                          "g:neocomplete#max_keyword_width/2, '..')")
                                end
                              end
                            end
                            EOF
                            
    2              0.000004   return a:context.candidates

FUNCTION  277()
Called 4 times
Total time:   0.000302
 Self time:   0.000265

count  total (s)   self (s)
    4              0.000006   let list = []
                            
   12              0.000037   for ft in a:context.filetypes
    8              0.000024     if !has_key(s:dictionary_cache, ft)
                                  call s:make_cache(ft)
                                endif
    8   0.000099   0.000062     call neocomplete#cache#check_cache( 'dictionary_cache', ft, s:async_dictionary_list, s:dictionary_cache, 1)
                            
    8              0.000028     let list += get(s:dictionary_cache, ft, [])
    8              0.000008   endfor
                            
    4              0.000005   return list

FUNCTION  278()
Called 11 times
Total time:   0.002373
 Self time:   0.000618

count  total (s)   self (s)
   11              0.000026   let filetype = a:context.filetype
   11              0.000054   if filetype ==# 'vimshell' || filetype ==# 'unite' || filetype ==# 'int-ssh'
                                return -1
                              endif
                            
                              " Filename pattern.
   11   0.000746   0.000126   let pattern = neocomplete#get_keyword_pattern_end('filename', self.name)
   11   0.001084   0.000138   let [complete_pos, complete_str] = neocomplete#helper#match_word(a:context.input, pattern)
                            
   11   0.000387   0.000198   if complete_str =~ '//' || complete_str == '/' || (neocomplete#is_auto_complete() &&     complete_str !~ '/' ||     complete_str =~#          '\\[^ ;*?[]"={}'']\|\.\.\+$\|/c\%[ygdrive/]$\|\${')
                                " Not filename pattern.
   11              0.000013     return -1
                              endif
                            
                              if complete_str =~ '/'
                                let complete_pos += strridx(complete_str, '/') + 1
                              endif
                            
                              return complete_pos

FUNCTION  ale#linter#GetExecutable()
Called 56 times
Total time:   0.004210
 Self time:   0.001616

count  total (s)   self (s)
   56   0.003598   0.001004     return has_key(a:linter, 'executable_callback')   ? ale#util#GetFunction(a:linter.executable_callback)(a:buffer)   : a:linter.executable

FUNCTION  <SNR>128_ShouldOpen()
Called 71 times
Total time:   0.003666
 Self time:   0.001320

count  total (s)   self (s)
   71   0.002976   0.000630     let l:val = ale#Var(a:buffer, 'open_list')
   71              0.000333     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
   71              0.000219     return l:val is 1 || (l:val is# 'on_save' && l:saved)

FUNCTION  neocomplete#util#convert2list()
Called 24 times
Total time:   0.000157
 Self time:   0.000157

count  total (s)   self (s)
   24              0.000147   return type(a:expr) ==# type([]) ? a:expr : [a:expr]

FUNCTION  neocomplete#filters#converter_remove_overlap#length()
Called 9 times
Total time:   0.001016
 Self time:   0.001016

count  total (s)   self (s)
    9              0.000035   if a:left == '' || a:right == ''
                                return 0
                              endif
                            
    9              0.000016   let ret = 0
                            
    9              0.000007   lua << EOF
                            do
                              local ret = vim.eval('ret')
                              local left = vim.eval('a:left')
                              local right = vim.eval('a:right')
                              local left_len = string.len(left)
                              local right_len = string.len(right)
                            
                              if left_len > right_len then
                                left = string.sub(left, left_len-right_len, left_len)
                              elseif left_len < right_len then
                                right = string.sub(right, 0, left_len)
                              end
                            
                              if left == right then
                                ret = math.min(left_len, right_len)
                              else
                                local length = 1
                                left_len = string.len(left)
                                while 1 do
                                  local pattern = string.sub(left, left_len-length+1, left_len)
                                  local pos = string.find(right, pattern, 1, 1)
                                  if pos == nil then
                                    break
                                  end
                                  length = length + pos - 1
                                  if string.sub(left, left_len-length+1, left_len) ==
                                    string.sub(right, 1, length) then
                                    ret = length
                                    length = length + 1
                                  end
                                end
                              end
                              vim.command('let ret = ' .. ret)
                            end
                            EOF
                            
    9              0.000010   return ret

FUNCTION  <SNR>9_DetectElixir()
Called 4 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    4              0.000024   if getline(1) =~ '^#!.*\<elixir\>'
                                call s:setf('elixir')
                              endif

FUNCTION  <SNR>43_fzf_call()
Called 50 times
Total time:   0.001083
 Self time:   0.001083

count  total (s)   self (s)
   50              0.001018     return call(a:fn, a:000)

FUNCTION  ale#util#GetFunction()
Called 103 times
Total time:   0.001384
 Self time:   0.001384

count  total (s)   self (s)
  103              0.000639     if type(a:string_or_ref) == type('')
   46              0.000176         return function(a:string_or_ref)
                                endif
                            
   57              0.000127     return a:string_or_ref

FUNCTION  282()
Called 11 times
Total time:   0.000980
 Self time:   0.000886

count  total (s)   self (s)
                              " Check member prefix pattern.
   11              0.000027   let filetype = a:context.filetype
   11              0.000102   let prefix = get(g:neocomplete#sources#member#prefix_patterns, filetype, get(g:neocomplete#sources#member#prefix_patterns, '_', ''))
   11              0.000015   if prefix == ''
                                return -1
                              endif
                            
   11   0.000205   0.000111   let member = s:get_member_pattern(filetype)
   11              0.000557   let complete_pos = matchend(a:context.input, member . '\m\%(' . prefix . '\m\)\ze\w*$')
   11              0.000020   return complete_pos

FUNCTION  289()
Called 4 times
Total time:   0.000912
 Self time:   0.000226

count  total (s)   self (s)
    4              0.000044   if !has_key(s:async_tags_list, bufnr('%')) && !has_key(s:tags_list, bufnr('%'))
    1   0.000453   0.000007     call neocomplete#sources#tag#make_cache(0)
    1              0.000001   endif
                            
    4   0.000098   0.000015   if neocomplete#within_comment()
                                return []
                              endif
                            
    4   0.000242   0.000085   call neocomplete#cache#check_cache( 'tags_cache', bufnr('%'), s:async_tags_list, s:tags_list, 0)
                            
    4              0.000028   return copy(get(s:tags_list, bufnr('%'), []))

FUNCTION  <SNR>126_VimCloseCallback()
Called 48 times
Total time:   0.177027
 Self time:   0.024101

count  total (s)   self (s)
   48              0.001351     let l:job = ch_getjob(a:channel)
   48   0.004886   0.001731     let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
   48              0.015765     let l:info = get(s:job_map, l:job_id, {})
                            
   48              0.000214     if empty(l:info)
                                    return
                                endif
                            
                                " job_status() can trigger the exit handler.
                                " The channel can close before the job has exited.
   48   0.007736   0.001268     if job_status(l:job) is# 'dead'
   48              0.000063         try
   48              0.000271             if !empty(l:info) && has_key(l:info, 'exit_cb')
   48   0.145189   0.001886                 call ale#util#GetFunction(l:info.exit_cb)(l:job_id, l:info.exit_code)
   48              0.000046             endif
   48              0.000069         finally
                                        " Automatically forget about the job after it's done.
   48              0.000325             if has_key(s:job_map, l:job_id)
   39              0.000222                 call remove(s:job_map, l:job_id)
   39              0.000034             endif
   48              0.000054         endtry
   48              0.000028     endif

FUNCTION  neocomplete#helper#clear_result()
Called 15 times
Total time:   0.000605
 Self time:   0.000457

count  total (s)   self (s)
   15   0.000264   0.000116   let neocomplete = neocomplete#get_current_neocomplete()
                            
   15              0.000042   let neocomplete.complete_str = ''
   15              0.000050   let neocomplete.candidates = []
   15              0.000041   let neocomplete.complete_sources = []
   15              0.000025   let neocomplete.complete_pos = -1
                            
                              " Restore completeopt.
   15              0.000064   if neocomplete.completeopt !=# &completeopt
                                " Restore completeopt.
                                let &completeopt = neocomplete.completeopt
                              endif

FUNCTION  <SNR>43_escape()
Called 5 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
    5              0.000038   let path = fnameescape(a:path)
    5              0.000024   return s:is_win ? escape(path, '$') : path

FUNCTION  ale#sign#ReadSigns()
Called 46 times
Total time:   0.001975
 Self time:   0.001975

count  total (s)   self (s)
   46              0.000244     redir => l:output
   46              0.000524        silent execute 'sign place buffer=' . a:buffer
   46              0.000179     redir end
                            
   46              0.000940     return split(l:output, "\n")

FUNCTION  ale#engine#ProcessChain()
Called 48 times
Total time:   0.017541
 Self time:   0.016805

count  total (s)   self (s)
   48              0.000824     let l:output_stream = get(a:linter, 'output_stream', 'stdout')
   48              0.000182     let l:read_buffer = a:linter.read_buffer
   48              0.000150     let l:chain_index = a:chain_index
   48              0.000109     let l:input = a:input
                            
   48              0.000173     if has_key(a:linter, 'command_chain')
                                    while l:chain_index < len(a:linter.command_chain)
                                        " Run a chain of commands, one asynchronous command after the other,
                                        " so that many programs can be run in a sequence.
                                        let l:chain_item = a:linter.command_chain[l:chain_index]
                            
                                        if l:chain_index == 0
                                            " The first callback in the chain takes only a buffer number.
                                            let l:command = ale#util#GetFunction(l:chain_item.callback)(   a:buffer)
                                        else
                                            " The second callback in the chain takes some input too.
                                            let l:command = ale#util#GetFunction(l:chain_item.callback)(   a:buffer,   l:input)
                                        endif
                            
                                        if !empty(l:command)
                                            " We hit a command to run, so we'll execute that
                            
                                            " The chain item can override the output_stream option.
                                            if has_key(l:chain_item, 'output_stream')
                                                let l:output_stream = l:chain_item.output_stream
                                            endif
                            
                                            " The chain item can override the read_buffer option.
                                            if has_key(l:chain_item, 'read_buffer')
                                                let l:read_buffer = l:chain_item.read_buffer
                                            elseif l:chain_index != len(a:linter.command_chain) - 1
                                                " Don't read the buffer for commands besides the last one
                                                " in the chain by default.
                                                let l:read_buffer = 0
                                            endif
                            
                                            break
                                        endif
                            
                                        " Command chain items can return an empty string to indicate that
                                        " a command should be skipped, so we should try the next item
                                        " with no input.
                                        let l:input = []
                                        let l:chain_index += 1
                                    endwhile
                                else
   48   0.003125   0.002389         let l:command = ale#linter#GetCommand(a:buffer, a:linter)
   48              0.000053     endif
                            
   48              0.000642     return {   'command': l:command,   'buffer': a:buffer,   'linter': a:linter,   'output_stream': l:output_stream,   'next_chain_index': l:chain_index + 1,   'read_buffer': l:read_buffer,}

FUNCTION  neocomplete#variables#get_frequencies()
Called 2 times
Total time:   0.000105
 Self time:   0.000063

count  total (s)   self (s)
    2              0.000018   if !exists('s:filetype_frequencies')
                                let s:filetype_frequencies = {}
                              endif
    2   0.000057   0.000015   let filetype = neocomplete#get_context_filetype()
    2              0.000007   if !has_key(s:filetype_frequencies, filetype)
                                let s:filetype_frequencies[filetype] = {}
                              endif
                            
    2              0.000004   let frequencies = s:filetype_frequencies[filetype]
                            
    2              0.000003   return frequencies

FUNCTION  <SNR>43_common_sink()
Called 5 times
Total time:   0.299982
 Self time:   0.001694

count  total (s)   self (s)
    5              0.000022   if len(a:lines) < 2
                                return
                              endif
    5              0.000021   let key = remove(a:lines, 0)
    5              0.000039   let Cmd = get(a:action, key, 'e')
    5              0.000049   if type(Cmd) == type(function('call'))
                                return Cmd(a:lines)
                              endif
    5              0.000013   if len(a:lines) > 1
                                augroup fzf_swap
                                  autocmd SwapExists * let v:swapchoice='o'| call s:warn('fzf: E325: swap file exists: '.s:fzf_expand('<afile>'))
                                augroup END
                              endif
    5              0.000005   try
    5   0.000349   0.000131     let empty = empty(s:fzf_expand('%')) && line('$') == 1 && empty(getline(1)) && !&modified
    5              0.000017     let autochdir = &autochdir
    5              0.000073     set noautochdir
   10              0.000059     for item in a:lines
    5              0.000008       if empty
                                    execute 'e' s:escape(item)
                                    let empty = 0
                                  else
    5   0.298240   0.000170         call s:open(Cmd, item)
    5              0.000044       endif
    5              0.000128       if !has('patch-8.0.0177') && !has('nvim-0.2') && exists('#BufEnter') && isdirectory(item)
                                    doautocmd BufEnter
                                  endif
    5              0.000226     endfor
    5              0.000012   finally
    5              0.000082     let &autochdir = autochdir
    5              0.000174     silent! autocmd! fzf_swap
    5              0.000010   endtry

FUNCTION  <SNR>21_winshell()
Called 28 times
Total time:   0.000313
 Self time:   0.000313

count  total (s)   self (s)
   28              0.000287   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>108_encode_list()
Called 3585 times
Total time:   0.155735
 Self time:   0.101964

count  total (s)   self (s)
                              " End Of Value
 3585              0.006744   let EOV = "\xFF"
                              " EOV, encoded size0, data0, EOV, encoded size1, data1, EOV, ...
 3585   0.140859   0.087088   return empty(a:arr) ? '' : (EOV . join(map(copy(a:arr), 's:encode_size(strlen(v:val)) . v:val'), EOV) . EOV)

FUNCTION  <SNR>71_LintOnEnter()
Called 12 times
Total time:   0.000816
 Self time:   0.000296

count  total (s)   self (s)
   12   0.000705   0.000185     if ale#Var(a:buffer, 'enabled')&& g:ale_lint_on_enter&& has_key(b:, 'ale_file_changed')
                                    call remove(b:, 'ale_file_changed')
                                    call ale#Queue(0, 'lint_file', a:buffer)
                                endif

FUNCTION  291()
Called 11 times
Total time:   0.014485
 Self time:   0.000231

count  total (s)   self (s)
   11   0.000223   0.000072   if neocomplete#within_comment()
                                return -1
                              endif
                            
   11   0.014229   0.000126   return necoghc#get_keyword_pos(a:context.input)

FUNCTION  292()
Called 4 times
Total time:   0.636784
 Self time:   0.000117

count  total (s)   self (s)
    4              0.000021   let line = getline('.')[: a:context.complete_pos]
                            
    4   0.636755   0.000088   return necoghc#get_complete_words( a:context.complete_pos, a:context.complete_str)

FUNCTION  neocomplete#variables#get_filters()
Called 2 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    2              0.000029   if !exists('s:filters')
                                let s:filters = {}
                              endif
    2              0.000004   return s:filters

FUNCTION  ale#sign#GetSignCommands()
Called 46 times
Total time:   0.004334
 Self time:   0.004334

count  total (s)   self (s)
   46              0.000144     let l:command_list = []
   46              0.000168     let l:is_dummy_sign_set = a:was_sign_set
                            
                                " Set the dummy sign if we need to.
                                " The dummy sign is needed to keep the sign column open while we add
                                " and remove signs.
   46              0.000740     if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
                                    call add(l:command_list, 'sign place '   .  g:ale_sign_offset   . ' line=1 name=ALEDummySign buffer='   . a:buffer)
                                    let l:is_dummy_sign_set = 1
                                endif
                            
                                " Place new items first.
   46              0.000252     for [l:line_str, l:info] in items(a:sign_map)
                                    if l:info.new_id
                                        " Save the sign IDs we are setting back on our loclist objects.
                                        " These IDs will be used to preserve items which are set many times.
                                        for l:item in l:info.items
                                            let l:item.sign_id = l:info.new_id
                                        endfor
                            
                                        if index(l:info.current_id_list, l:info.new_id) < 0
                                            call add(l:command_list, 'sign place '   . (l:info.new_id)   . ' line=' . l:line_str   . ' name=' . (l:info.new_name)   . ' buffer=' . a:buffer)
                                        endif
                                    endif
                                endfor
                            
                                " Remove signs without new IDs.
   46              0.000163     for l:info in values(a:sign_map)
                                    for l:current_id in l:info.current_id_list
                                        if l:current_id isnot l:info.new_id
                                            call add(l:command_list, 'sign unplace '   . l:current_id   . ' buffer=' . a:buffer)
                                        endif
                                    endfor
                                endfor
                            
                                " Remove the dummy sign to close the sign column if we need to.
   46              0.000141     if l:is_dummy_sign_set && !g:ale_sign_column_always
                                    call add(l:command_list, 'sign unplace '   . g:ale_sign_offset   . ' buffer=' . a:buffer)
                                endif
                            
   46              0.000079     return l:command_list

FUNCTION  hindent#HindentOnSave()
Called 1 time
Total time:   0.071559
 Self time:   0.000106

count  total (s)   self (s)
    1              0.000009     if g:hindent_on_save == 1
    1   0.071537   0.000084         call hindent#Hindent()
    1              0.000003     endif

FUNCTION  <SNR>61_Highlight_Matching_Pair()
Called 305 times
Total time:   0.040612
 Self time:   0.040612

count  total (s)   self (s)
                              " Remove any previous match.
  305              0.001631   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  305              0.001848   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  305              0.001036   let c_lnum = line('.')
  305              0.000881   let c_col = col('.')
  305              0.000422   let before = 0
                            
  305              0.001025   let text = getline(c_lnum)
  305              0.008922   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  305              0.001034   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
  305              0.001764     let [c_before, c] = matches[1:2]
  305              0.000260   endif
  305              0.009585   let plist = split(&matchpairs, '.\zs[:,]')
  305              0.001328   let i = index(plist, c)
  305              0.000431   if i < 0
                                " not found, in Insert mode try character before the cursor
  305              0.001355     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   19              0.000068       let before = strlen(c_before)
   19              0.000027       let c = c_before
   19              0.000052       let i = index(plist, c)
   19              0.000014     endif
  305              0.000335     if i < 0
                                  " not found, nothing to do
  305              0.000382       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
                              let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
                              execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  <SNR>43_defaults()
Called 5 times
Total time:   0.000132
 Self time:   0.000132

count  total (s)   self (s)
    5              0.000037   let rules = copy(get(g:, 'fzf_colors', {}))
    5              0.000067   let colors = join(map(items(filter(map(rules, 'call("s:get_color", v:val)'), '!empty(v:val)')), 'join(v:val, ":")'), ',')
    5              0.000020   return empty(colors) ? '' : ('--color='.colors)

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
Called 277 times
Total time:   0.033735
 Self time:   0.019283

count  total (s)   self (s)
                                " Only echo the warnings in normal mode, otherwise we will get problems.
  277              0.002680     if mode() isnot# 'n'
                                    return
                                endif
                            
  277   0.007340   0.003046     call s:StopCursorTimer()
                            
  277              0.002752     let l:pos = getcurpos()[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
  277              0.000833     if l:pos != s:last_pos
  262   0.012760   0.002602         let l:delay = ale#Var(bufnr(''), 'echo_delay')
                            
  262              0.001028         let s:last_pos = l:pos
  262              0.001943         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
  262              0.000236     endif

FUNCTION  <SNR>132__create_hash()
Called 53 times
Total time:   0.007215
 Self time:   0.007215

count  total (s)   self (s)
   53              0.000413   if len(a:dir) + len(a:str) < 150
   53              0.006114     let hash = substitute(substitute( a:str, ':', '=-', 'g'), '[/\\]', '=+', 'g')
   53              0.000096   else
                                let hash = s:S.hash(a:str)
                              endif
                            
   53              0.000098   return hash

FUNCTION  vimproc#filepath#which()
Called 8 times
Total time:   0.000880
 Self time:   0.000148

count  total (s)   self (s)
    8   0.000875   0.000143   return s:which(a:command, a:path, a:maxcount)

FUNCTION  <SNR>7_DetectCoffee()
Called 4 times
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
    4              0.000057     if getline(1) =~ '^#!.*\<coffee\>'
                                    set filetype=coffee
                                endif

FUNCTION  fzf#run()
Called 5 times
Total time:  15.314073
 Self time:   0.003821

count  total (s)   self (s)
    5              0.000007 try
    5   0.000186   0.000060   let [shell, shellslash] = s:use_sh()
                            
    5   0.000187   0.000060   let dict   = exists('a:1') ? s:upgrade(a:1) : {}
    5   0.000361   0.000054   let temps  = { 'result': s:fzf_tempname() }
    5   0.000082   0.000039   let optstr = s:evaluate_opts(get(dict, 'options', ''))
    5              0.000006   try
    5   0.000566   0.000046     let fzf_exec = s:fzf_exec()
    5              0.000008   catch
                                throw v:exception
                              endtry
                            
    5              0.000030   if has('nvim') && !has_key(dict, 'dir')
                                let dict.dir = s:fzf_getcwd()
                              endif
    5              0.000022   if has('win32unix') && has_key(dict, 'dir')
                                let dict.dir = fnamemodify(dict.dir, ':p')
                              endif
                            
    5              0.000033   if !has_key(dict, 'source') && !empty($FZF_DEFAULT_COMMAND) && !s:is_win
    5   0.000075   0.000025     let temps.source = s:fzf_tempname()
    5   0.001565   0.001551     call writefile(s:wrap_cmds(split($FZF_DEFAULT_COMMAND, "\n")), temps.source)
    5   0.000358   0.000133     let dict.source = (empty($SHELL) ? &shell : $SHELL).' '.fzf#shellescape(temps.source)
    5              0.000005   endif
                            
    5              0.000014   if has_key(dict, 'source')
    5              0.000010     let source = dict.source
    5              0.000015     let type = type(source)
    5              0.000007     if type == 1
    5              0.000017       let prefix = '( '.source.' )|'
    5              0.000008     elseif type == 3
                                  let temps.input = s:fzf_tempname()
                                  call writefile(source, temps.input)
                                  let prefix = (s:is_win ? 'type ' : 'cat ').fzf#shellescape(temps.input).'|'
                                else
                                  throw 'Invalid source type'
                                endif
    5              0.000004   else
                                let prefix = ''
                              endif
                            
    5              0.000040   let prefer_tmux = get(g:, 'fzf_prefer_tmux', 0)
    5              0.000061   let use_height = has_key(dict, 'down') && !(has('nvim') || s:is_win || has('win32unix') || s:present(dict, 'up', 'left', 'right')) && executable('tput') && filereadable('/dev/tty')
    5              0.000098   let use_term = has('nvim-0.2.1') || (has('nvim') && !s:is_win) || (has('terminal') && has('patch-8.0.995') && (has('gui_running') || s:is_win))
    5   0.000223   0.000107   let use_tmux = (!use_height && !use_term || prefer_tmux) && !has('win32unix') && s:tmux_enabled() && s:splittable(dict)
    5              0.000007   if prefer_tmux && use_tmux
                                let use_height = 0
                                let use_term = 0
                              endif
    5              0.000006   if use_height
                                let height = s:calc_size(&lines, dict.down, dict)
                                let optstr .= ' --height='.height
                              elseif use_term
                                let optstr .= ' --no-height'
                                if !has('nvim') && !s:is_win
                                  let optstr .= ' --bind ctrl-j:accept'
                                endif
                              endif
    5              0.000103   let command = prefix.(use_tmux ? s:fzf_tmux(dict) : fzf_exec).' '.optstr.' > '.temps.result
                            
    5              0.000007   if use_term
                                return s:execute_term(dict, command, temps)
                              endif
                            
    5  15.007660   0.000218   let lines = use_tmux ? s:execute_tmux(dict, command, temps) : s:execute(dict, command, use_height, temps)
    5   0.301532   0.000250   call s:callback(dict, lines)
    5              0.000018   return lines
                            finally
    5              0.000284   let [&shell, &shellslash] = [shell, shellslash]
    5              0.000042 endtry

FUNCTION  <SNR>43_tmux_enabled()
Called 5 times
Total time:   0.000116
 Self time:   0.000116

count  total (s)   self (s)
    5              0.000046   if has('gui_running')
                                return 0
                              endif
                            
    5              0.000020   if exists('s:tmux')
    5              0.000011     return s:tmux
                              endif
                            
                              let s:tmux = 0
                              if exists('$TMUX') && executable(s:fzf_tmux)
                                let output = system('tmux -V')
                                let s:tmux = !v:shell_error && output >= 'tmux 1.7'
                              endif
                              return s:tmux

FUNCTION  <SNR>116_GetAliasedFiletype()
Called 63 times
Total time:   0.003542
 Self time:   0.003542

count  total (s)   self (s)
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
  252              0.001029     for l:dict in [   get(b:, 'ale_linter_aliases', {}),   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
  189              0.000738         if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
                                    endif
  189              0.000293     endfor
                            
   63              0.000109     return a:original_filetype

FUNCTION  vimproc#util#systemencoding()
Called 3657 times
Total time:   0.011254
 Self time:   0.011254

count  total (s)   self (s)
 3657              0.009279   return s:is_windows ? 'utf-8' : 'char'

FUNCTION  neocomplete#is_auto_complete()
Called 70 times
Total time:   0.001153
 Self time:   0.000530

count  total (s)   self (s)
   70   0.000975   0.000352   let neocomplete = neocomplete#get_current_neocomplete()
   70              0.000119   return neocomplete.is_auto_complete

FUNCTION  neocomplete#util#is_complete_select()
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000009   return has('patch-7.4.775')

FUNCTION  <SNR>12_LoadFTPlugin()
Called 4 times
Total time:   0.022306
 Self time:   0.017062

count  total (s)   self (s)
    4              0.000063     if exists("b:undo_ftplugin")
    2              0.000201       exe b:undo_ftplugin
    2              0.000021       unlet! b:undo_ftplugin b:did_ftplugin
    2              0.000003     endif
                            
    4              0.000028     let s = expand("<amatch>")
    4              0.000008     if s != ""
    4              0.000058       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    8              0.000064       for name in split(s, '\.')
    4   0.021750   0.016506 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    4              0.000013       endfor
    4              0.000005     endif

FUNCTION  neocomplete#cache#get_cache_list()
Called 31 times
Total time:   0.017646
 Self time:   0.004052

count  total (s)   self (s)
   31              0.000081   let cache_list = a:async_cache_list
                            
   31              0.000053   let loaded_keywords = []
   31              0.000037   let loaded = 0
   47              0.002479   for cache in filter(copy(cache_list), 'filereadable(v:val.cachename)')
   16              0.000038     let loaded = 1
   16   0.013861   0.000267     let loaded_keywords = neocomplete#cache#load_from_cache( a:cache_dir, cache.filename, 1)
   16              0.000020   endfor
                            
   31              0.000680   call filter(cache_list, '!filereadable(v:val.cachename)')
                            
   31              0.000087   return [loaded, loaded_keywords]

FUNCTION  <SNR>78_get_prelude()
Called 53 times
Total time:   0.000792
 Self time:   0.000792

count  total (s)   self (s)
   53              0.000400   if !exists('s:Prelude')
                                let s:Prelude = neocomplete#util#get_vital().import('Prelude')
                              endif
   53              0.000075   return s:Prelude

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    5  15.320768   0.000993  fzf#vim#files()
    5  15.317943   0.001239  <SNR>136_fzf()
    5  15.314073   0.003821  fzf#run()
    5  15.007442   1.368829  <SNR>43_execute()
 3585   1.649938   1.217819  <SNR>108_libcall()
   15   1.505919   0.540965  <SNR>108_garbage_collect()
   11   0.743810   0.000447  <SNR>99_complete_delay()
   11   0.743363   0.002423  <SNR>99_do_auto_complete()
   11   0.732480   0.001208  neocomplete#complete#_get_results()
  338   0.709674   0.032590  ale#CallWithCooldown()
    4   0.678128   0.012567  neocomplete#complete#_set_results_words()
    4   0.636784   0.000117  292()
    4   0.636667   0.001437  necoghc#get_complete_words()
    9   0.632539   0.000212  necoghc#browse()
    2   0.632327   0.000187  <SNR>134_ghc_mod_caching_browse()
    2   0.626657   0.001669  <SNR>134_ghc_mod()
    2   0.624988   0.000334  <SNR>134_system()
    2   0.624654   0.000269  vimproc#system()
    2   0.624385   0.001189  <SNR>108_system()
    8   0.609948   0.001072  <SNR>108_read_pgroup()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    5  15.007442   1.368829  <SNR>43_execute()
 3585   1.649938   1.217819  <SNR>108_libcall()
   15   1.505919   0.540965  <SNR>108_garbage_collect()
 3657   0.198322   0.146260  vimproc#util#iconv()
 3585   0.155735   0.101964  <SNR>108_encode_list()
   48   0.107475   0.092507  ale#job#Start()
 3561   0.070854   0.069268  <SNR>108_decode_list()
 3739              0.053771  <SNR>108_encode_size()
 3657              0.052062  vimproc#util#has_iconv()
 1214              0.050113  ale#Var()
  368   0.095026   0.046232  ale#ShouldDoNothing()
   15   0.043190   0.043051  <SNR>94_make_cache_lines()
   48   0.245682   0.041671  <SNR>123_RunJob()
  305              0.040612  <SNR>61_Highlight_Matching_Pair()
  338   0.709674   0.032590  ale#CallWithCooldown()
   26   0.215583   0.029510  <SNR>85_check_source()
   48   0.177027   0.024101  <SNR>126_VimCloseCallback()
   32   0.351899   0.023837  ale#engine#RunLinters()
    5              0.023736  <SNR>134_extract_modules()
   63   0.033263   0.022545  ale#linter#Get()

